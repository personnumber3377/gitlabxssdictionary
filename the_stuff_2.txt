querying_spec.rb:require 'fast_spec_helper'
querying_spec.rb:  describe '.css' do
querying_spec.rb:    it 'optimizes queries for elements with classes' do
querying_spec.rb:      described_class.css(document, 'a.gfm')
renderer_spec.rb:require 'spec_helper'
renderer_spec.rb:    object = double('object')
renderer_spec.rb:    allow(object).to receive(:cached_html_for).with(:field).and_return('field_html')
renderer_spec.rb:    object = double('cacheless object')
renderer_spec.rb:  describe '#cache_collection_render' do
renderer_spec.rb:    let(:context) { { cache_key: [merge_request, 'field'], rendered: merge_request.field_html } }
renderer_spec.rb:    context 'when an item has a rendered field' do
renderer_spec.rb:        allow(merge_request).to receive(:field).and_return('This is the field')
renderer_spec.rb:        allow(merge_request).to receive(:field_html).and_return('This is the field')
renderer_spec.rb:      it 'does not touch redis if the field is in the cache' do
renderer_spec.rb:  describe '#render_field' do
renderer_spec.rb:    context 'without cache' do
renderer_spec.rb:      it 'returns cacheless render field' do
renderer_spec.rb:    context 'with cache' do
renderer_spec.rb:      context 'with a stale cache' do
renderer_spec.rb:        it 'caches and returns the result' do
renderer_spec.rb:          is_expected.to eq('field_html')
renderer_spec.rb:          is_expected.to eq('field_html')
renderer_spec.rb:      context 'with an up-to-date cache' do
renderer_spec.rb:        it 'uses the cache' do
renderer_spec.rb:          is_expected.to eq('field_html')
renderer_spec.rb:  describe '#cacheless_render' do
renderer_spec.rb:    context 'without cache' do
renderer_spec.rb:      it 'returns cacheless render field' do
renderer_spec.rb:        allow(renderer).to receive(:render_result).and_return(output: 'test')
renderer_spec.rb:        expect(renderer).to receive(:render_result).with('test', {})
renderer_spec.rb:        renderer.cacheless_render('test')
renderer_spec.rb:  describe '#post_process' do
renderer_spec.rb:    let(:html) { 'Consequatur aperiam et nesciunt modi aut assumenda quo id. ' }
renderer_spec.rb:    let(:post_processed_html) { double(html_safe: 'safe doc') }
renderer_spec.rb:    context 'when xhtml' do
renderer_spec.rb:      let(:context_options) { { xhtml: ' ' } }
renderer_spec.rb:      context 'without :post_process_pipeline key' do
renderer_spec.rb:        it 'uses PostProcessPipeline' do
renderer_spec.rb:      context 'with :post_process_pipeline key' do
renderer_spec.rb:        let(:context_options) { { post_process_pipeline: Object, xhtml: ' ' } }
renderer_spec.rb:        it 'uses passed post process pipeline' do
renderer_spec.rb:    context 'when not xhtml' do
renderer_spec.rb:      context 'without :post_process_pipeline key' do
renderer_spec.rb:        it 'uses PostProcessPipeline' do
renderer_spec.rb:      context 'with :post_process_pipeline key' do
renderer_spec.rb:        it 'uses passed post process pipeline' do
renderer_spec.rb:  describe '#full_cache_key' do
renderer_spec.rb:    it 'returns nil when no cache_key' do
renderer_spec.rb:    it 'returns a valid full cache key' do
renderer_spec.rb:      cache_key = described_class.full_cache_key('my_cache_key', :emoji)
renderer_spec.rb:    it 'pipeline name defaults to :full' do
renderer_spec.rb:      cache_key = described_class.full_cache_key('my_cache_key', nil)
renderer_spec.rb:  describe 'instrumentation in render_result' do
renderer_spec.rb:    it 'calculates pipeline timing' do
renderer_spec.rb:      expect(ActiveSupport::Notifications).to receive(:monotonic_subscribe).with('call_filter.html_pipeline')
renderer_spec.rb:      result = renderer.render_result('test', pipeline: :plain_markdown, project: nil)
renderer_spec.rb:    it 'enables debug output' do
renderer_spec.rb:      expect(ActiveSupport::Notifications).to receive(:monotonic_subscribe).with('call_filter.html_pipeline')
renderer_spec.rb:      renderer.render_result('test', pipeline: :plain_markdown, project: nil, debug: true)
renderer_spec.rb:    it 'enables debug_timing output' do
renderer_spec.rb:      expect(ActiveSupport::Notifications).to receive(:monotonic_subscribe).with('call_filter.html_pipeline')
renderer_spec.rb:      renderer.render_result('test', pipeline: :plain_markdown, project: nil, debug_timing: true)
renderer_spec.rb:    it 'generates a color for the duration' do
renderer_spec.rb:    it 'formats duration' do
renderer_spec.rb:      expect(described_class.formatted_duration(0.5)).to eq '0.500000_s'
renderer_spec.rb:      expect(described_class.formatted_duration(1.5)).to eq '1.500000_s'
renderer_spec.rb:      expect(described_class.formatted_duration(2.5)).to eq '2.500000_s'
object_renderer_spec.rb:require 'spec_helper'
object_renderer_spec.rb:      redaction_context: { custom_value: 'value' }
object_renderer_spec.rb:  let(:object) { Note.new(note: 'hello', note_html: '<p dir="auto">hello</p>', cached_markdown_version: Gitlab::MarkdownCache::CACHE_COMMONMARK_VERSION_SHIFTED) }
object_renderer_spec.rb:  describe '#render' do
object_renderer_spec.rb:    context 'with cache' do
object_renderer_spec.rb:      it 'renders and redacts an Array of objects' do
object_renderer_spec.rb:        expect(object.redacted_note_html).to eq '<p dir="auto">hello</p>'
object_renderer_spec.rb:      it 'calls Banzai::ReferenceRedactor to perform redaction' do
object_renderer_spec.rb:      it 'retrieves field content using Banzai::Renderer.render_field' do
object_renderer_spec.rb:      it 'passes context to PostProcessPipeline' do
object_renderer_spec.rb:          note: 'hello',
object_renderer_spec.rb:          note_html: 'hello',
object_renderer_spec.rb:            custom_value: 'value'
object_renderer_spec.rb:    context 'without cache' do
object_renderer_spec.rb:          thing.title = "Merge branch 'branch-merged' into 'master'"
object_renderer_spec.rb:      it 'renders and redacts an Array of objects' do
object_renderer_spec.rb:        expect(cacheless_thing.redacted_title_html).to eq("Merge branch 'branch-merged' into 'master'")
object_renderer_spec.rb:      it 'calls Banzai::ReferenceRedactor to perform redaction' do
object_renderer_spec.rb:      it 'retrieves field content using Banzai::Renderer.cacheless_render_field' do
pipeline_spec.rb:require 'fast_spec_helper'
pipeline_spec.rb:  describe '.[]' do
pipeline_spec.rb:    shared_examples 'error' do |exception, message|
pipeline_spec.rb:    context 'for nil' do
pipeline_spec.rb:    context 'for symbols' do
pipeline_spec.rb:      context 'when known' do
pipeline_spec.rb:      context 'when unknown' do
pipeline_spec.rb:        it_behaves_like 'error', NameError,
pipeline_spec.rb:          'uninitialized constant Banzai::Pipeline::UnknownPipeline'
pipeline_spec.rb:    context 'for classes' do
pipeline_spec.rb:      context 'subclassing Banzai::Pipeline::BasePipeline' do
pipeline_spec.rb:      context 'subclassing other types' do
pipeline_spec.rb:          stub_const('Foo', klass)
pipeline_spec.rb:        it_behaves_like 'error', ArgumentError,
pipeline_spec.rb:          'unsupported pipeline name Foo (Class)'
pipeline_spec.rb:    context 'for other types' do
pipeline_spec.rb:      let(:name) { 'label' }
pipeline_spec.rb:      it_behaves_like 'error', ArgumentError,
pipeline_spec.rb:        'unsupported pipeline name "label" (String)'
issuable_extractor_spec.rb:require 'spec_helper'
issuable_extractor_spec.rb:      "<a href='' data-issue='#{issue.id}' data-reference-type='issue' class='gfm'>text</a>"
issuable_extractor_spec.rb:      "<a href='' data-work-item='#{work_item.id}' data-reference-type='work_item' class='gfm'>text</a>"
issuable_extractor_spec.rb:      "<a href='' data-work-item='#{group_work_item.id}' data-reference-type='work_item' class='gfm'>text</a>"
issuable_extractor_spec.rb:      "<a href='' data-merge-request='#{merge_request.id}' data-reference-type='merge_request' class='gfm'>text</a>"
issuable_extractor_spec.rb:  it 'returns instances of issuables for nodes with references' do
issuable_extractor_spec.rb:  describe 'caching', :request_store do
issuable_extractor_spec.rb:    it 'saves records to cache' do
cross_project_reference_spec.rb:require 'spec_helper'
cross_project_reference_spec.rb:  describe '#parent_from_ref' do
cross_project_reference_spec.rb:    context 'when no project was referenced' do
cross_project_reference_spec.rb:      it 'returns the project from context' do
cross_project_reference_spec.rb:    context 'when no project was referenced in group context' do
cross_project_reference_spec.rb:      it 'returns the group from context' do
cross_project_reference_spec.rb:    context 'when referenced project does not exist' do
cross_project_reference_spec.rb:      it 'returns nil' do
cross_project_reference_spec.rb:        expect(including_class.parent_from_ref('invalid/reference')).to be_nil
cross_project_reference_spec.rb:    context 'when referenced project exists' do
cross_project_reference_spec.rb:      it 'returns the referenced project' do
cross_project_reference_spec.rb:        project2 = double('referenced project')
cross_project_reference_spec.rb:          .with('cross/reference').and_return(project2)
cross_project_reference_spec.rb:        expect(including_class.parent_from_ref('cross/reference')).to eq project2
cross_project_reference_spec.rb:    context 'when reference cache is loaded' do
cross_project_reference_spec.rb:      let(:project2) { double('referenced project') }
cross_project_reference_spec.rb:        allow(reference_cache).to receive(:parent_per_reference).and_return({ 'cross/reference' => project2 })
cross_project_reference_spec.rb:      it 'pulls from the reference cache' do
cross_project_reference_spec.rb:        expect(including_class.parent_from_ref('cross/reference')).to eq project2
extract_dictionary.py:	# matches = re.findall(r'"(.*?)"', data) # Extract the stuff from the thing...
extract_dictionary.py:	# 	print(f'"{s}"')
extract_dictionary.py:	matches = re.findall(r'\'(.*?)\'', data) # Extract the stuff from the thing...
extract_dictionary.py:		print(f'"{s}"')
filter_array_spec.rb:require 'fast_spec_helper'
filter_array_spec.rb:  describe '#insert_after' do
filter_array_spec.rb:    it 'inserts an element after a provided element' do
filter_array_spec.rb:      filters.insert_after('b', '1')
filter_array_spec.rb:    it 'inserts an element at the end when the provided element does not exist' do
filter_array_spec.rb:      filters.insert_after('d', '1')
filter_array_spec.rb:  describe '#insert_before' do
filter_array_spec.rb:    it 'inserts an element before a provided element' do
filter_array_spec.rb:      filters.insert_before('b', '1')
filter_array_spec.rb:    it 'inserts an element at the beginning when the provided element does not exist' do
filter_array_spec.rb:      filters.insert_before('d', '1')
render_context_spec.rb:require 'spec_helper'
render_context_spec.rb:  let(:document) { Nokogiri::HTML.fragment('<p>hello</p>') }
render_context_spec.rb:  describe '#project_for_node' do
render_context_spec.rb:    it 'returns the default project if no associated project was found' do
render_context_spec.rb:      project = instance_double('Project')
render_context_spec.rb:    it 'returns the associated project if one was associated explicitly' do
render_context_spec.rb:      project = instance_double('Project')
render_context_spec.rb:      obj = double('object', project: project)
render_context_spec.rb:    it 'returns the project associated with a DocumentFragment when using a node' do
render_context_spec.rb:      project = instance_double('Project')
render_context_spec.rb:      obj = double('object', project: project)
reference_parser/mentioned_group_parser_spec.rb:require 'spec_helper'
reference_parser/mentioned_group_parser_spec.rb:  describe '#gather_references' do
reference_parser/mentioned_group_parser_spec.rb:    context 'when the link has a data-group attribute' do
reference_parser/mentioned_group_parser_spec.rb:      context 'using an existing group ID where user does not have access' do
reference_parser/mentioned_group_parser_spec.rb:        it 'returns empty array' do
reference_parser/mentioned_group_parser_spec.rb:          link['data-group'] = project.group.id.to_s
reference_parser/mentioned_group_parser_spec.rb:      context 'using an existing group ID' do
reference_parser/mentioned_group_parser_spec.rb:          link['data-group'] = project.group.id.to_s
reference_parser/mentioned_group_parser_spec.rb:        it 'returns groups' do
reference_parser/mentioned_group_parser_spec.rb:      context 'using a non-existing group ID' do
reference_parser/mentioned_group_parser_spec.rb:        it 'returns an empty Array' do
reference_parser/mentioned_group_parser_spec.rb:          link['data-group'] = 'test-non-existing'
reference_parser/label_parser_spec.rb:require 'spec_helper'
reference_parser/label_parser_spec.rb:  describe '#nodes_visible_to_user' do
reference_parser/label_parser_spec.rb:    context 'when the link has a data-issue attribute' do
reference_parser/label_parser_spec.rb:        link['data-label'] = label.id.to_s
reference_parser/label_parser_spec.rb:  describe '#referenced_by' do
reference_parser/label_parser_spec.rb:    describe 'when the link has a data-label attribute' do
reference_parser/label_parser_spec.rb:      context 'using an existing label ID' do
reference_parser/label_parser_spec.rb:        it 'returns an Array of labels' do
reference_parser/label_parser_spec.rb:          link['data-label'] = label.id.to_s
reference_parser/label_parser_spec.rb:      context 'using a non-existing label ID' do
reference_parser/label_parser_spec.rb:        it 'returns an empty Array' do
reference_parser/label_parser_spec.rb:          link['data-label'] = ''
reference_parser/mentioned_project_parser_spec.rb:require 'spec_helper'
reference_parser/mentioned_project_parser_spec.rb:  describe '#gather_references' do
reference_parser/mentioned_project_parser_spec.rb:    context 'when the link has a data-project attribute' do
reference_parser/mentioned_project_parser_spec.rb:      context 'using an existing project ID where user does not have access' do
reference_parser/mentioned_project_parser_spec.rb:        it 'returns empty Array' do
reference_parser/mentioned_project_parser_spec.rb:          link['data-project'] = project.id.to_s
reference_parser/mentioned_project_parser_spec.rb:      context 'using an existing project ID' do
reference_parser/mentioned_project_parser_spec.rb:          link['data-project'] = project.id.to_s
reference_parser/mentioned_project_parser_spec.rb:        it 'returns an Array of referenced projects' do
reference_parser/mentioned_project_parser_spec.rb:      context 'using a non-existing project ID' do
reference_parser/mentioned_project_parser_spec.rb:        it 'returns an empty Array' do
reference_parser/mentioned_project_parser_spec.rb:          link['data-project'] = 'inexisting-project-id'
reference_parser/commit_range_parser_spec.rb:require 'spec_helper'
reference_parser/commit_range_parser_spec.rb:  describe '#nodes_visible_to_user' do
reference_parser/commit_range_parser_spec.rb:    context 'when the link has a data-project attribute' do
reference_parser/commit_range_parser_spec.rb:        link['data-project'] = project.id.to_s
reference_parser/commit_range_parser_spec.rb:      it 'includes the link if can_read_reference? returns true' do
reference_parser/commit_range_parser_spec.rb:      it 'excludes the link if can_read_reference? returns false' do
reference_parser/commit_range_parser_spec.rb:    context 'when the link does not have a data-project attribute' do
reference_parser/commit_range_parser_spec.rb:      it 'returns the nodes' do
reference_parser/commit_range_parser_spec.rb:  describe '#referenced_by' do
reference_parser/commit_range_parser_spec.rb:    context 'when the link has a data-project attribute' do
reference_parser/commit_range_parser_spec.rb:        link['data-project'] = project.id.to_s
reference_parser/commit_range_parser_spec.rb:      context 'when the link as a data-commit-range attribute' do
reference_parser/commit_range_parser_spec.rb:          link['data-commit-range'] = '123..456'
reference_parser/commit_range_parser_spec.rb:        it 'returns an Array of commit ranges' do
reference_parser/commit_range_parser_spec.rb:            .with(project, '123..456')
reference_parser/commit_range_parser_spec.rb:        it 'returns an empty Array when the commit range could not be found' do
reference_parser/commit_range_parser_spec.rb:            .with(project, '123..456')
reference_parser/commit_range_parser_spec.rb:      context 'when the link does not have a data-commit-range attribute' do
reference_parser/commit_range_parser_spec.rb:        it 'returns an empty Array' do
reference_parser/commit_range_parser_spec.rb:    context 'when the link does not have a data-project attribute' do
reference_parser/commit_range_parser_spec.rb:      it 'returns an empty Array' do
reference_parser/commit_range_parser_spec.rb:  describe '#commit_range_ids_per_project' do
reference_parser/commit_range_parser_spec.rb:      link['data-project'] = project.id.to_s
reference_parser/commit_range_parser_spec.rb:    it 'returns a Hash containing range IDs per project' do
reference_parser/commit_range_parser_spec.rb:      link['data-commit-range'] = '123..456'
reference_parser/commit_range_parser_spec.rb:      expect(hash[project.id].to_a).to eq(['123..456'])
reference_parser/commit_range_parser_spec.rb:    it 'does not add a project when the data-commit-range attribute is empty' do
reference_parser/commit_range_parser_spec.rb:  describe '#find_ranges' do
reference_parser/commit_range_parser_spec.rb:    it 'returns an Array of range objects' do
reference_parser/commit_range_parser_spec.rb:        .with(project, '123..456')
reference_parser/commit_range_parser_spec.rb:      expect(subject.find_ranges(project, ['123..456'])).to eq([range])
reference_parser/commit_range_parser_spec.rb:    it 'skips ranges that could not be found' do
reference_parser/commit_range_parser_spec.rb:        .with(project, '123..456')
reference_parser/commit_range_parser_spec.rb:      expect(subject.find_ranges(project, ['123..456'])).to eq([])
reference_parser/commit_range_parser_spec.rb:  describe '#find_object' do
reference_parser/commit_range_parser_spec.rb:    context 'when the range has valid commits' do
reference_parser/commit_range_parser_spec.rb:      it 'returns the commit range' do
reference_parser/commit_range_parser_spec.rb:        expect(subject.find_object(project, '123..456')).to eq(range)
reference_parser/commit_range_parser_spec.rb:    context 'when the range does not have any valid commits' do
reference_parser/commit_range_parser_spec.rb:      it 'returns nil' do
reference_parser/commit_range_parser_spec.rb:        expect(subject.find_object(project, '123..456')).to be_nil
reference_parser/commit_range_parser_spec.rb:    context 'group context' do
reference_parser/commit_range_parser_spec.rb:      it 'returns nil' do
reference_parser/commit_range_parser_spec.rb:        expect(subject.find_object(group, '123..456')).to be_nil
reference_parser/commit_range_parser_spec.rb:  context 'when checking commits ranges on another projects', :request_store do
reference_parser/commit_range_parser_spec.rb:    it_behaves_like 'no project N+1 queries'
reference_parser/issue_parser_spec.rb:require 'spec_helper'
reference_parser/issue_parser_spec.rb:  describe '#nodes_visible_to_user' do
reference_parser/issue_parser_spec.rb:    context 'when the link has a data-issue attribute' do
reference_parser/issue_parser_spec.rb:        link['data-issue'] = issue.id.to_s
reference_parser/issue_parser_spec.rb:      it 'returns the nodes when the user can read the issue' do
reference_parser/issue_parser_spec.rb:      it 'returns an empty Array when the user can not read the issue' do
reference_parser/issue_parser_spec.rb:      context 'when the user cannot read cross project' do
reference_parser/issue_parser_spec.rb:        it 'returns the nodes when the user can read the issue' do
reference_parser/issue_parser_spec.rb:        it 'returns an empty Array when the user can not read the issue' do
reference_parser/issue_parser_spec.rb:        context 'when the issue is not cross project' do
reference_parser/issue_parser_spec.rb:          it 'does not check `can_read_reference` if the issue is not cross project' do
reference_parser/issue_parser_spec.rb:    context 'when the link does not have a data-issue attribute' do
reference_parser/issue_parser_spec.rb:      it 'returns an empty Array' do
reference_parser/issue_parser_spec.rb:  describe '#referenced_by' do
reference_parser/issue_parser_spec.rb:    context 'when the link has a data-issue attribute' do
reference_parser/issue_parser_spec.rb:      context 'using an existing issue ID' do
reference_parser/issue_parser_spec.rb:          link['data-issue'] = issue.id.to_s
reference_parser/issue_parser_spec.rb:        it 'returns an Array of issues' do
reference_parser/issue_parser_spec.rb:        it 'returns an empty Array when the list of nodes is empty' do
reference_parser/issue_parser_spec.rb:      context 'when issue with given ID does not exist' do
reference_parser/issue_parser_spec.rb:          link['data-issue'] = '-1'
reference_parser/issue_parser_spec.rb:        it 'returns an empty Array' do
reference_parser/issue_parser_spec.rb:  describe '#records_for_nodes' do
reference_parser/issue_parser_spec.rb:    it 'returns a Hash containing the issues for a list of nodes' do
reference_parser/issue_parser_spec.rb:      link['data-issue'] = issue.id.to_s
reference_parser/issue_parser_spec.rb:  context 'when checking multiple issues on another project' do
reference_parser/issue_parser_spec.rb:    it_behaves_like 'no N+1 queries'
reference_parser/work_item_parser_spec.rb:require 'spec_helper'
reference_parser/work_item_parser_spec.rb:  describe '#records_for_nodes' do
reference_parser/work_item_parser_spec.rb:    it 'returns a Hash containing the work items for a list of nodes' do
reference_parser/work_item_parser_spec.rb:      link['data-work-item'] = work_item.id.to_s
reference_parser/work_item_parser_spec.rb:  context 'when checking multiple work items on another project' do
reference_parser/work_item_parser_spec.rb:    it_behaves_like 'no N+1 queries'
reference_parser/design_parser_spec.rb:require 'spec_helper'
reference_parser/design_parser_spec.rb:  describe '#nodes_visible_to_user' do
reference_parser/design_parser_spec.rb:    it_behaves_like 'referenced feature visibility', 'issues' do
reference_parser/design_parser_spec.rb:    describe 'specific states' do
reference_parser/design_parser_spec.rb:      it 'redacts links we should not have access to' do
reference_parser/design_parser_spec.rb:      context 'design management is not available' do
reference_parser/design_parser_spec.rb:        it 'redacts all nodes' do
reference_parser/design_parser_spec.rb:  describe '#process' do
reference_parser/design_parser_spec.rb:    it 'returns the correct designs' do
reference_parser/design_parser_spec.rb:    node['class'] = 'gfm'
reference_parser/design_parser_spec.rb:    node['data-reference-type'] = 'design'
reference_parser/design_parser_spec.rb:    node['data-project'] = design.project.id.to_s
reference_parser/design_parser_spec.rb:    node['data-issue'] = design.issue.id.to_s
reference_parser/design_parser_spec.rb:    node['data-design'] = design.id.to_s
reference_parser/design_parser_spec.rb:    frag = Nokogiri::HTML.fragment('')
reference_parser/merge_request_parser_spec.rb:require 'spec_helper'
reference_parser/merge_request_parser_spec.rb:  describe '#nodes_visible_to_user' do
reference_parser/merge_request_parser_spec.rb:    context 'when the link has a data-issue attribute' do
reference_parser/merge_request_parser_spec.rb:        link['data-project'] = merge_request.project_id.to_s
reference_parser/merge_request_parser_spec.rb:        link['data-merge-request'] = merge_request.id.to_s
reference_parser/merge_request_parser_spec.rb:  describe '#referenced_by' do
reference_parser/merge_request_parser_spec.rb:    describe 'when the link has a data-merge-request attribute' do
reference_parser/merge_request_parser_spec.rb:      context 'using an existing merge request ID' do
reference_parser/merge_request_parser_spec.rb:        it 'returns an Array of merge requests' do
reference_parser/merge_request_parser_spec.rb:          link['data-project'] = merge_request.project_id.to_s
reference_parser/merge_request_parser_spec.rb:          link['data-merge-request'] = merge_request.id.to_s
reference_parser/merge_request_parser_spec.rb:      context 'using a non-existing merge request ID' do
reference_parser/merge_request_parser_spec.rb:        it 'returns an empty Array' do
reference_parser/merge_request_parser_spec.rb:          link['data-project'] = merge_request.project_id.to_s
reference_parser/merge_request_parser_spec.rb:          link['data-merge-request'] = ''
reference_parser/merge_request_parser_spec.rb:  context 'when checking multiple merge requests on another project' do
reference_parser/merge_request_parser_spec.rb:    it_behaves_like 'no N+1 queries'
reference_parser/merge_request_parser_spec.rb:  describe '#can_read_reference?' do
reference_parser/merge_request_parser_spec.rb:    context 'when merge request belongs to the private project' do
reference_parser/merge_request_parser_spec.rb:      it 'prevents user from reading merge request references' do
reference_parser/merge_request_parser_spec.rb:      context 'when user has access to the project' do
reference_parser/merge_request_parser_spec.rb:    context 'with memoization' do
reference_parser/merge_request_parser_spec.rb:      context 'when project is the same' do
reference_parser/merge_request_parser_spec.rb:        it 'calls #can? only once' do
reference_parser/merge_request_parser_spec.rb:      context 'when merge requests belong to different projects' do
reference_parser/merge_request_parser_spec.rb:        it 'calls #can? for each project' do
reference_parser/base_parser_spec.rb:require 'spec_helper'
reference_parser/base_parser_spec.rb:  describe '.reference_class' do
reference_parser/base_parser_spec.rb:    context 'when the method is not defined' do
reference_parser/base_parser_spec.rb:      it 'build the reference class' do
reference_parser/base_parser_spec.rb:    context 'when the method is redefined' do
reference_parser/base_parser_spec.rb:      it 'uses specified reference class' do
reference_parser/base_parser_spec.rb:  describe '.reference_type=' do
reference_parser/base_parser_spec.rb:    it 'sets the reference type' do
reference_parser/base_parser_spec.rb:  describe '#project_for_node' do
reference_parser/base_parser_spec.rb:    it 'returns the Project for a node' do
reference_parser/base_parser_spec.rb:      document = double('document', fragment?: false)
reference_parser/base_parser_spec.rb:      project = instance_double('Project')
reference_parser/base_parser_spec.rb:      object = double('object', project: project)
reference_parser/base_parser_spec.rb:      node = double('node', document: document)
reference_parser/base_parser_spec.rb:  describe '#nodes_visible_to_user' do
reference_parser/base_parser_spec.rb:    context 'when the link has a data-project attribute' do
reference_parser/base_parser_spec.rb:        link['data-project'] = project.id.to_s
reference_parser/base_parser_spec.rb:      it 'includes the link if can_read_reference? returns true' do
reference_parser/base_parser_spec.rb:      it 'excludes the link if can_read_reference? returns false' do
reference_parser/base_parser_spec.rb:    context 'when the link does not have a data-project attribute' do
reference_parser/base_parser_spec.rb:      it 'returns the nodes' do
reference_parser/base_parser_spec.rb:  describe '#nodes_user_can_reference' do
reference_parser/base_parser_spec.rb:    it 'returns the nodes' do
reference_parser/base_parser_spec.rb:  describe '#referenced_by' do
reference_parser/base_parser_spec.rb:    context 'when references_relation is implemented' do
reference_parser/base_parser_spec.rb:      context 'and ids_only is set to false' do
reference_parser/base_parser_spec.rb:        it 'returns a collection of objects' do
reference_parser/base_parser_spec.rb:          links = Nokogiri::HTML.fragment("<a data-foo='#{user.id}'></a>")
reference_parser/base_parser_spec.rb:      context 'and ids_only is set to true' do
reference_parser/base_parser_spec.rb:        it 'returns a collection of id values without performing a db query' do
reference_parser/base_parser_spec.rb:          links = Nokogiri::HTML.fragment("<a data-foo='1'></a><a data-foo='2'></a>").children
reference_parser/base_parser_spec.rb:        context 'and the html fragment does not contain any attributes' do
reference_parser/base_parser_spec.rb:          it 'returns an empty array' do
reference_parser/base_parser_spec.rb:    context 'when references_relation is not implemented' do
reference_parser/base_parser_spec.rb:      it 'raises NotImplementedError' do
reference_parser/base_parser_spec.rb:        links = Nokogiri::HTML.fragment('<a data-foo="1"></a>').children
reference_parser/base_parser_spec.rb:  describe '#references_relation' do
reference_parser/base_parser_spec.rb:    it 'raises NotImplementedError' do
reference_parser/base_parser_spec.rb:  describe '#gather_attributes_per_project' do
reference_parser/base_parser_spec.rb:    it 'returns a Hash containing attribute values per project' do
reference_parser/base_parser_spec.rb:      link = Nokogiri::HTML.fragment('<a data-project="1" data-foo="2"></a>')
reference_parser/base_parser_spec.rb:      hash = subject.gather_attributes_per_project([link], 'data-foo')
reference_parser/base_parser_spec.rb:      expect(hash[1].to_a).to eq(['2'])
reference_parser/base_parser_spec.rb:  describe '#grouped_objects_for_nodes' do
reference_parser/base_parser_spec.rb:    it 'returns a Hash grouping objects per node' do
reference_parser/base_parser_spec.rb:        .with('data-user')
reference_parser/base_parser_spec.rb:        .with('data-user')
reference_parser/base_parser_spec.rb:        .with(nodes, 'data-user')
reference_parser/base_parser_spec.rb:      hash = subject.grouped_objects_for_nodes(nodes, User, 'data-user')
reference_parser/base_parser_spec.rb:    it 'returns an empty Hash when entry does not exist in the database', :request_store do
reference_parser/base_parser_spec.rb:          .with('data-user')
reference_parser/base_parser_spec.rb:          .with('data-user')
reference_parser/base_parser_spec.rb:          .and_return('1')
reference_parser/base_parser_spec.rb:          .with(nodes, 'data-user')
reference_parser/base_parser_spec.rb:      hash = subject.grouped_objects_for_nodes(nodes, User, 'data-user')
reference_parser/base_parser_spec.rb:  describe '#unique_attribute_values' do
reference_parser/base_parser_spec.rb:    it 'returns an Array of unique values' do
reference_parser/base_parser_spec.rb:        .with('data-foo')
reference_parser/base_parser_spec.rb:        .with('data-foo')
reference_parser/base_parser_spec.rb:        .and_return('1')
reference_parser/base_parser_spec.rb:      expect(subject.unique_attribute_values(nodes, 'data-foo')).to eq(['1'])
reference_parser/base_parser_spec.rb:  describe '#process' do
reference_parser/base_parser_spec.rb:    it 'gathers the references for every node matching the reference type' do
reference_parser/base_parser_spec.rb:      document_c = Nokogiri::HTML.fragment('')
reference_parser/base_parser_spec.rb:        .to contain_exactly(document_a.css('a')[1], document_b.css('a')[0])
reference_parser/base_parser_spec.rb:  describe '#gather_references' do
reference_parser/base_parser_spec.rb:    it 'returns referenceable and visible objects, alongside all and visible nodes' do
reference_parser/base_parser_spec.rb:    it 'is always empty if the input is empty' do
reference_parser/base_parser_spec.rb:  describe '#can?' do
reference_parser/base_parser_spec.rb:    it 'delegates the permissions check to the Ability class' do
reference_parser/base_parser_spec.rb:  describe '#find_projects_for_hash_keys' do
reference_parser/base_parser_spec.rb:    it 'returns a list of Projects' do
reference_parser/base_parser_spec.rb:  describe '#collection_objects_for_ids' do
reference_parser/base_parser_spec.rb:    context 'with RequestStore disabled' do
reference_parser/base_parser_spec.rb:      it 'queries the collection directly' do
reference_parser/base_parser_spec.rb:    context 'with RequestStore enabled', :request_store do
reference_parser/base_parser_spec.rb:      it 'queries the collection on the first call' do
reference_parser/base_parser_spec.rb:      it 'does not query previously queried objects' do
reference_parser/base_parser_spec.rb:      it 'casts String based IDs to Fixnums before querying objects' do
reference_parser/base_parser_spec.rb:      it 'queries any additional objects after the first call' do
reference_parser/base_parser_spec.rb:      it 'caches objects on a per collection class basis' do
reference_parser/base_parser_spec.rb:      it 'will not overflow the stack' do
reference_parser/base_parser_spec.rb:  describe '#collection_cache_key' do
reference_parser/base_parser_spec.rb:    it 'returns the cache key for a Class' do
reference_parser/base_parser_spec.rb:    it 'returns the cache key for an ActiveRecord::Relation' do
reference_parser/milestone_parser_spec.rb:require 'spec_helper'
reference_parser/milestone_parser_spec.rb:  describe '#nodes_visible_to_user' do
reference_parser/milestone_parser_spec.rb:    context 'when the link has a data-issue attribute' do
reference_parser/milestone_parser_spec.rb:        link['data-milestone'] = milestone.id.to_s
reference_parser/milestone_parser_spec.rb:  describe '#referenced_by' do
reference_parser/milestone_parser_spec.rb:    describe 'when the link has a data-milestone attribute' do
reference_parser/milestone_parser_spec.rb:      context 'using an existing milestone ID' do
reference_parser/milestone_parser_spec.rb:        it 'returns an Array of milestones' do
reference_parser/milestone_parser_spec.rb:          link['data-milestone'] = milestone.id.to_s
reference_parser/milestone_parser_spec.rb:      context 'using a non-existing milestone ID' do
reference_parser/milestone_parser_spec.rb:        it 'returns an empty Array' do
reference_parser/milestone_parser_spec.rb:          link['data-milestone'] = ''
reference_parser/wiki_page_parser_spec.rb:require 'spec_helper'
reference_parser/wiki_page_parser_spec.rb:  describe '#nodes_visible_to_user' do
reference_parser/wiki_page_parser_spec.rb:      link['data-reference-type'] = 'wiki_page'
reference_parser/wiki_page_parser_spec.rb:    context 'when the link has a data-project attribute' do
reference_parser/wiki_page_parser_spec.rb:        link['data-project'] = project.id
reference_parser/wiki_page_parser_spec.rb:      it 'redacts the link if the user cannot read the project' do
reference_parser/wiki_page_parser_spec.rb:    context 'when the link has a data-group attribute' do
reference_parser/wiki_page_parser_spec.rb:        link['data-group'] = group.id
reference_parser/wiki_page_parser_spec.rb:      it 'redacts the link if the user cannot read the group' do
reference_parser/wiki_page_parser_spec.rb:    context 'if no data-project or data-group attribute is present' do
reference_parser/wiki_page_parser_spec.rb:      it 'returns the link' do
reference_parser/user_parser_spec.rb:require 'spec_helper'
reference_parser/user_parser_spec.rb:  describe '#referenced_by' do
reference_parser/user_parser_spec.rb:    context 'when the link has a data-group attribute' do
reference_parser/user_parser_spec.rb:      context 'using an existing group ID' do
reference_parser/user_parser_spec.rb:          link['data-group'] = project.group.id.to_s
reference_parser/user_parser_spec.rb:        it 'returns an empty Array when the group has no users' do
reference_parser/user_parser_spec.rb:        context 'when group has members' do
reference_parser/user_parser_spec.rb:          it 'returns the relevant users of the group with enough access' do
reference_parser/user_parser_spec.rb:          it 'returns an empty Array when the group has mentions disabled' do
reference_parser/user_parser_spec.rb:      context 'using a non-existing group ID' do
reference_parser/user_parser_spec.rb:        it 'returns an empty Array' do
reference_parser/user_parser_spec.rb:          link['data-group'] = ''
reference_parser/user_parser_spec.rb:    context 'when the link has a data-user attribute' do
reference_parser/user_parser_spec.rb:      it 'returns an Array of users' do
reference_parser/user_parser_spec.rb:        link['data-user'] = user.id.to_s
reference_parser/user_parser_spec.rb:      context 'when RequestStore is active', :request_store do
reference_parser/user_parser_spec.rb:        it 'does not return users from the first call in the second' do
reference_parser/user_parser_spec.rb:          link['data-user'] = user.id.to_s
reference_parser/user_parser_spec.rb:          link['data-user'] = other_user.id.to_s
reference_parser/user_parser_spec.rb:    context 'when the link has a data-project attribute' do
reference_parser/user_parser_spec.rb:      context 'using an existing project ID' do
reference_parser/user_parser_spec.rb:        it 'returns the members of a project' do
reference_parser/user_parser_spec.rb:          link['data-project'] = project.id.to_s
reference_parser/user_parser_spec.rb:          # This uses an explicit sort to make sure this spec doesn't randomly
reference_parser/user_parser_spec.rb:      context 'using a non-existing project ID' do
reference_parser/user_parser_spec.rb:        it 'returns an empty Array' do
reference_parser/user_parser_spec.rb:          link['data-project'] = ''
reference_parser/user_parser_spec.rb:  describe '#nodes_visible_to_user' do
reference_parser/user_parser_spec.rb:    context 'when the link has a data-group attribute' do
reference_parser/user_parser_spec.rb:      context 'using an existing group ID' do
reference_parser/user_parser_spec.rb:          link['data-group'] = group.id.to_s
reference_parser/user_parser_spec.rb:        it 'returns the nodes if the user can read the group' do
reference_parser/user_parser_spec.rb:        it 'returns an empty Array if the user can not read the group' do
reference_parser/user_parser_spec.rb:      context 'when the link does not have a data-group attribute' do
reference_parser/user_parser_spec.rb:        context 'with a data-project attribute' do
reference_parser/user_parser_spec.rb:          it 'returns the nodes if the attribute value equals the current project ID' do
reference_parser/user_parser_spec.rb:            link['data-project'] = project.id.to_s
reference_parser/user_parser_spec.rb:          it 'returns the nodes if the user can read the project' do
reference_parser/user_parser_spec.rb:            link['data-project'] = other_project.id.to_s
reference_parser/user_parser_spec.rb:          it 'returns an empty Array if the user can not read the project' do
reference_parser/user_parser_spec.rb:            link['data-project'] = other_project.id.to_s
reference_parser/user_parser_spec.rb:        context 'without a data-project attribute' do
reference_parser/user_parser_spec.rb:          it 'returns the nodes' do
reference_parser/user_parser_spec.rb:  describe '#nodes_user_can_reference' do
reference_parser/user_parser_spec.rb:    context 'when the link has a data-author attribute' do
reference_parser/user_parser_spec.rb:      it 'returns the nodes when the user is a member of the project' do
reference_parser/user_parser_spec.rb:        link['data-project'] = other_project.id.to_s
reference_parser/user_parser_spec.rb:        link['data-author'] = user.id.to_s
reference_parser/user_parser_spec.rb:      it 'returns an empty Array when the project could not be found' do
reference_parser/user_parser_spec.rb:        link['data-project'] = ''
reference_parser/user_parser_spec.rb:        link['data-author'] = user.id.to_s
reference_parser/user_parser_spec.rb:      it 'returns an empty Array when the user could not be found' do
reference_parser/user_parser_spec.rb:        link['data-project'] = other_project.id.to_s
reference_parser/user_parser_spec.rb:        link['data-author'] = ''
reference_parser/user_parser_spec.rb:      it 'returns an empty Array when the user is not a team member' do
reference_parser/user_parser_spec.rb:        link['data-project'] = other_project.id.to_s
reference_parser/user_parser_spec.rb:        link['data-author'] = user.id.to_s
reference_parser/user_parser_spec.rb:      it 'returns the nodes if the project attribute value equals the current project ID' do
reference_parser/user_parser_spec.rb:        link['data-project'] = project.id.to_s
reference_parser/user_parser_spec.rb:        link['data-author'] = other_user.id.to_s
reference_parser/user_parser_spec.rb:    context 'when the link does not have a data-author attribute' do
reference_parser/user_parser_spec.rb:      it 'returns the nodes' do
reference_parser/feature_flag_parser_spec.rb:require 'spec_helper'
reference_parser/feature_flag_parser_spec.rb:  describe '#nodes_visible_to_user' do
reference_parser/feature_flag_parser_spec.rb:    context 'when the link has a data-issue attribute' do
reference_parser/feature_flag_parser_spec.rb:        link['data-feature-flag'] = feature_flag.id.to_s
reference_parser/feature_flag_parser_spec.rb:  describe '#referenced_by' do
reference_parser/feature_flag_parser_spec.rb:    describe 'when the link has a data-feature-flag attribute' do
reference_parser/feature_flag_parser_spec.rb:      context 'using an existing feature flag ID' do
reference_parser/feature_flag_parser_spec.rb:        it 'returns an Array of feature flags' do
reference_parser/feature_flag_parser_spec.rb:          link['data-feature-flag'] = feature_flag.id.to_s
reference_parser/feature_flag_parser_spec.rb:      context 'using a non-existing feature flag ID' do
reference_parser/feature_flag_parser_spec.rb:        it 'returns an empty Array' do
reference_parser/feature_flag_parser_spec.rb:          link['data-feature-flag'] = ''
reference_parser/commit_parser_spec.rb:require 'spec_helper'
reference_parser/commit_parser_spec.rb:  describe '#nodes_visible_to_user' do
reference_parser/commit_parser_spec.rb:    context 'when the link has a data-project attribute' do
reference_parser/commit_parser_spec.rb:        link['data-project'] = project.id.to_s
reference_parser/commit_parser_spec.rb:      it 'includes the link if can_read_reference? returns true' do
reference_parser/commit_parser_spec.rb:      it 'excludes the link if can_read_reference? returns false' do
reference_parser/commit_parser_spec.rb:    context 'when the link does not have a data-project attribute' do
reference_parser/commit_parser_spec.rb:      it 'returns the nodes' do
reference_parser/commit_parser_spec.rb:  describe '#referenced_by' do
reference_parser/commit_parser_spec.rb:    context 'when the link has a data-project attribute' do
reference_parser/commit_parser_spec.rb:        link['data-project'] = project.id.to_s
reference_parser/commit_parser_spec.rb:      context 'when the link has a data-commit attribute' do
reference_parser/commit_parser_spec.rb:          link['data-commit'] = '123'
reference_parser/commit_parser_spec.rb:        it 'returns an Array of commits' do
reference_parser/commit_parser_spec.rb:            .with(project, ['123'])
reference_parser/commit_parser_spec.rb:        it 'returns an empty Array when the commit could not be found' do
reference_parser/commit_parser_spec.rb:            .with(project, ['123'])
reference_parser/commit_parser_spec.rb:        it 'skips projects without valid repositories' do
reference_parser/commit_parser_spec.rb:      context 'when the link does not have a data-commit attribute' do
reference_parser/commit_parser_spec.rb:        it 'returns an empty Array' do
reference_parser/commit_parser_spec.rb:    context 'when the link does not have a data-project attribute' do
reference_parser/commit_parser_spec.rb:      it 'returns an empty Array' do
reference_parser/commit_parser_spec.rb:  describe '#commit_ids_per_project' do
reference_parser/commit_parser_spec.rb:      link['data-project'] = project.id.to_s
reference_parser/commit_parser_spec.rb:    it 'returns a Hash containing commit IDs per project' do
reference_parser/commit_parser_spec.rb:      link['data-commit'] = '123'
reference_parser/commit_parser_spec.rb:      expect(hash[project.id].to_a).to eq(['123'])
reference_parser/commit_parser_spec.rb:    it 'does not add a project when the data-commit attribute is empty' do
reference_parser/commit_parser_spec.rb:  describe '#find_commits' do
reference_parser/commit_parser_spec.rb:    it 'is empty when repo is invalid' do
reference_parser/commit_parser_spec.rb:    it 'returns commits by the specified ids' do
reference_parser/commit_parser_spec.rb:    it 'is limited' do
reference_parser/commit_parser_spec.rb:  context 'when checking commits on another projects', :request_store do
reference_parser/commit_parser_spec.rb:    it_behaves_like 'no project N+1 queries'
reference_parser/alert_parser_spec.rb:require 'spec_helper'
reference_parser/alert_parser_spec.rb:  describe '#nodes_visible_to_user' do
reference_parser/alert_parser_spec.rb:    context 'when the link has a data-issue attribute' do
reference_parser/alert_parser_spec.rb:        link['data-alert'] = alert.id.to_s
reference_parser/alert_parser_spec.rb:  describe '#referenced_by' do
reference_parser/alert_parser_spec.rb:    describe 'when the link has a data-alert attribute' do
reference_parser/alert_parser_spec.rb:      context 'using an existing alert ID' do
reference_parser/alert_parser_spec.rb:        it 'returns an Array of alerts' do
reference_parser/alert_parser_spec.rb:          link['data-alert'] = alert.id.to_s
reference_parser/alert_parser_spec.rb:      context 'using a non-existing alert ID' do
reference_parser/alert_parser_spec.rb:        it 'returns an empty Array' do
reference_parser/alert_parser_spec.rb:          link['data-alert'] = ''
reference_parser/project_parser_spec.rb:require 'spec_helper'
reference_parser/project_parser_spec.rb:  describe '#referenced_by' do
reference_parser/project_parser_spec.rb:    describe 'when the link has a data-project attribute' do
reference_parser/project_parser_spec.rb:      context 'using an existing project ID' do
reference_parser/project_parser_spec.rb:        it 'returns an Array of projects' do
reference_parser/project_parser_spec.rb:          link['data-project'] = project.id.to_s
reference_parser/project_parser_spec.rb:      context 'using a non-existing project ID' do
reference_parser/project_parser_spec.rb:        it 'returns an empty Array' do
reference_parser/project_parser_spec.rb:          link['data-project'] = ''
reference_parser/project_parser_spec.rb:      context 'using a private project ID' do
reference_parser/project_parser_spec.rb:        it 'returns an empty Array when unauthorized' do
reference_parser/project_parser_spec.rb:          link['data-project'] = private_project.id.to_s
reference_parser/project_parser_spec.rb:        it 'returns an Array when authorized' do
reference_parser/project_parser_spec.rb:          link['data-project'] = private_project.id.to_s
reference_parser/external_issue_parser_spec.rb:require 'spec_helper'
reference_parser/external_issue_parser_spec.rb:  describe '#nodes_visible_to_user' do
reference_parser/external_issue_parser_spec.rb:    context 'when the link has a data-issue attribute' do
reference_parser/external_issue_parser_spec.rb:        link['data-external-issue'] = 123
reference_parser/external_issue_parser_spec.rb:  describe '#referenced_by' do
reference_parser/external_issue_parser_spec.rb:    context 'when the link has a data-project attribute' do
reference_parser/external_issue_parser_spec.rb:        link['data-project'] = project.id.to_s
reference_parser/external_issue_parser_spec.rb:      context 'when the link has a data-external-issue attribute' do
reference_parser/external_issue_parser_spec.rb:        it 'returns an Array of ExternalIssue instances' do
reference_parser/external_issue_parser_spec.rb:          link['data-external-issue'] = '123'
reference_parser/external_issue_parser_spec.rb:          expect(refs).to eq([ExternalIssue.new('123', project)])
reference_parser/external_issue_parser_spec.rb:      context 'when the link does not have a data-external-issue attribute' do
reference_parser/external_issue_parser_spec.rb:        it 'returns an empty Array' do
reference_parser/external_issue_parser_spec.rb:    context 'when the link does not have a data-project attribute' do
reference_parser/external_issue_parser_spec.rb:      it 'returns an empty Array' do
reference_parser/external_issue_parser_spec.rb:  describe '#issue_ids_per_project' do
reference_parser/external_issue_parser_spec.rb:      link['data-project'] = project.id.to_s
reference_parser/external_issue_parser_spec.rb:    it 'returns a Hash containing range IDs per project' do
reference_parser/external_issue_parser_spec.rb:      link['data-external-issue'] = '123'
reference_parser/external_issue_parser_spec.rb:      expect(hash[project.id].to_a).to eq(['123'])
reference_parser/external_issue_parser_spec.rb:    it 'does not add a project when the data-external-issue attribute is empty' do
reference_parser/snippet_parser_spec.rb:require 'spec_helper'
reference_parser/snippet_parser_spec.rb:    link['data-project'] = project.id.to_s
reference_parser/snippet_parser_spec.rb:    link['data-snippet'] = snippet.id.to_s
reference_parser/snippet_parser_spec.rb:  describe '#nodes_visible_to_user' do
reference_parser/snippet_parser_spec.rb:    context 'when a project is public and the snippets feature is enabled for everyone' do
reference_parser/snippet_parser_spec.rb:      it 'avoids N+1 cached queries', :use_sql_query_cache do
reference_parser/snippet_parser_spec.rb:      it 'creates a reference for guest for a public snippet' do
reference_parser/snippet_parser_spec.rb:      it 'creates a reference for a regular user for a public snippet' do
reference_parser/snippet_parser_spec.rb:      it 'creates a reference for a regular user for an internal snippet' do
reference_parser/snippet_parser_spec.rb:      it 'does not create a reference for an external user for an internal snippet' do
reference_parser/snippet_parser_spec.rb:      it 'creates a reference for a project member for a private snippet' do
reference_parser/snippet_parser_spec.rb:      it 'does not create a reference for a regular user for a private snippet' do
reference_parser/snippet_parser_spec.rb:    context 'when a project is public and the snippets feature is enabled for project team members' do
reference_parser/snippet_parser_spec.rb:      it 'creates a reference for a project member for a public snippet' do
reference_parser/snippet_parser_spec.rb:      it 'does not create a reference for guest for a public snippet' do
reference_parser/snippet_parser_spec.rb:      it 'does not create a reference for a regular user for a public snippet' do
reference_parser/snippet_parser_spec.rb:      it 'creates a reference for a project member for an internal snippet' do
reference_parser/snippet_parser_spec.rb:      it 'does not create a reference for a regular user for an internal snippet' do
reference_parser/snippet_parser_spec.rb:      it 'creates a reference for a project member for a private snippet' do
reference_parser/snippet_parser_spec.rb:      it 'does not create a reference for a regular user for a private snippet' do
reference_parser/snippet_parser_spec.rb:    context 'when a project is internal and the snippets feature is enabled for everyone' do
reference_parser/snippet_parser_spec.rb:      it 'does not create a reference for guest for a public snippet' do
reference_parser/snippet_parser_spec.rb:      it 'does not create a reference for an external user for a public snippet' do
reference_parser/snippet_parser_spec.rb:      it 'creates a reference for a regular user for a public snippet' do
reference_parser/snippet_parser_spec.rb:      it 'creates a reference for a regular user for an internal snippet' do
reference_parser/snippet_parser_spec.rb:      it 'does not create a reference for an external user for an internal snippet' do
reference_parser/snippet_parser_spec.rb:      it 'creates a reference for a project member for a private snippet' do
reference_parser/snippet_parser_spec.rb:      it 'does not create a reference for a regular user for a private snippet' do
reference_parser/snippet_parser_spec.rb:    context 'when a project is internal and the snippets feature is enabled for project team members' do
reference_parser/snippet_parser_spec.rb:      it 'creates a reference for a project member for a public snippet' do
reference_parser/snippet_parser_spec.rb:      it 'does not create a reference for guest for a public snippet' do
reference_parser/snippet_parser_spec.rb:      it 'does not create reference for a regular user for a public snippet' do
reference_parser/snippet_parser_spec.rb:      it 'creates a reference for a project member for an internal snippet' do
reference_parser/snippet_parser_spec.rb:      it 'does not create a reference for a regular user for an internal snippet' do
reference_parser/snippet_parser_spec.rb:      it 'creates a reference for a project member for a private snippet' do
reference_parser/snippet_parser_spec.rb:      it 'does not create reference for a regular user for a private snippet' do
reference_parser/snippet_parser_spec.rb:    context 'when a project is private and the snippets feature is enabled for project team members' do
reference_parser/snippet_parser_spec.rb:      it 'creates a reference for a project member for a public snippet' do
reference_parser/snippet_parser_spec.rb:      it 'does not create a reference for guest for a public snippet' do
reference_parser/snippet_parser_spec.rb:      it 'does not create a reference for a regular user for a public snippet' do
reference_parser/snippet_parser_spec.rb:      it 'creates a reference for a project member for an internal snippet' do
reference_parser/snippet_parser_spec.rb:      it 'does not create a reference for a regular user for an internal snippet' do
reference_parser/snippet_parser_spec.rb:      it 'creates a reference for a project member for a private snippet' do
reference_parser/snippet_parser_spec.rb:      it 'does not create a reference for a regular user for a private snippet' do
reference_parser/snippet_parser_spec.rb:  describe '#referenced_by' do
reference_parser/snippet_parser_spec.rb:    describe 'when the link has a data-snippet attribute' do
reference_parser/snippet_parser_spec.rb:      context 'using an existing snippet ID' do
reference_parser/snippet_parser_spec.rb:        it 'returns an Array of snippets' do
reference_parser/snippet_parser_spec.rb:          link['data-snippet'] = snippet.id.to_s
reference_parser/snippet_parser_spec.rb:      context 'using a non-existing snippet ID' do
reference_parser/snippet_parser_spec.rb:        it 'returns an empty Array' do
reference_parser/snippet_parser_spec.rb:          link['data-snippet'] = ''
reference_parser/mentioned_user_parser_spec.rb:require 'spec_helper'
reference_parser/mentioned_user_parser_spec.rb:  describe '#gather_references' do
reference_parser/mentioned_user_parser_spec.rb:    context 'when the link has a data-group attribute' do
reference_parser/mentioned_user_parser_spec.rb:      context 'using an existing group ID' do
reference_parser/mentioned_user_parser_spec.rb:          link['data-group'] = project.group.id.to_s
reference_parser/mentioned_user_parser_spec.rb:        it 'returns empty list of users' do
reference_parser/mentioned_user_parser_spec.rb:    context 'when the link has a data-project attribute' do
reference_parser/mentioned_user_parser_spec.rb:      context 'using an existing project ID' do
reference_parser/mentioned_user_parser_spec.rb:          link['data-project'] = project.id.to_s
reference_parser/mentioned_user_parser_spec.rb:        it 'returns empty list of users' do
reference_parser/mentioned_user_parser_spec.rb:    context 'when the link has a data-user attribute' do
reference_parser/mentioned_user_parser_spec.rb:      it 'returns an Array of users' do
reference_parser/mentioned_user_parser_spec.rb:        link['data-user'] = user.id.to_s
pipeline/single_line_markdown_pipeline_spec.rb:require 'spec_helper'
pipeline/single_line_markdown_pipeline_spec.rb:  it_behaves_like 'sanitize pipeline'
pipeline/single_line_markdown_pipeline_spec.rb:  it 'processes markdown and does not surround output with a paragraph tag' do
pipeline/single_line_markdown_pipeline_spec.rb:    text = '_italic_ and `code`'
pipeline/single_line_markdown_pipeline_spec.rb:    expect(to_html(text)).to eq('<em>italic</em> and <code>code</code>')
pipeline/single_line_markdown_pipeline_spec.rb:  it 'removes additional block level tags pre, p, img, ol, ul, and li' do
pipeline/single_line_markdown_pipeline_spec.rb:  it 'handles emojis and autolinking' do
pipeline/single_line_markdown_pipeline_spec.rb:    text = ':smile: using http://example.com'
pipeline/single_line_markdown_pipeline_spec.rb:    expect(result).to include('gl-emoji')
pipeline/single_line_markdown_pipeline_spec.rb:    expect(result).to include('<a href="http://example.com"')
pipeline/single_line_markdown_pipeline_spec.rb:  it 'recognizes references' do
pipeline/single_line_markdown_pipeline_spec.rb:    expect(result).to include('data-reference-type="issue"')
pipeline/single_line_markdown_pipeline_spec.rb:    expect(result).to include('data-reference-type="user"')
pipeline/single_line_markdown_pipeline_spec.rb:  it 'does not recognize references in inline code' do
pipeline/single_line_markdown_pipeline_spec.rb:    expect(result).not_to include('data-reference-type="issue"')
pipeline/single_line_markdown_pipeline_spec.rb:    expect(result).not_to include('data-reference-type="user"')
pipeline/plain_markdown_pipeline_spec.rb:require 'spec_helper'
pipeline/plain_markdown_pipeline_spec.rb:  context 'with project' do
pipeline/plain_markdown_pipeline_spec.rb:    let_it_be(:ref)            { 'markdown' }
pipeline/plain_markdown_pipeline_spec.rb:    let_it_be(:requested_path) { '/' }
pipeline/plain_markdown_pipeline_spec.rb:    context 'when include directive' do
pipeline/plain_markdown_pipeline_spec.rb:      context 'with path to non-existing file' do
pipeline/plain_markdown_pipeline_spec.rb:        let(:include_path) { 'not-exists.md' }
pipeline/plain_markdown_pipeline_spec.rb:        it 'renders Unresolved directive placeholder' do
pipeline/plain_markdown_pipeline_spec.rb:          is_expected.to include error_message(include_path, 'not found')
pipeline/plain_markdown_pipeline_spec.rb:      shared_examples 'invalid include' do
pipeline/plain_markdown_pipeline_spec.rb:        let(:include_path) { 'dk.png' }
pipeline/plain_markdown_pipeline_spec.rb:        it 'does not read the blob' do
pipeline/plain_markdown_pipeline_spec.rb:        it 'renders Unresolved directive placeholder' do
pipeline/plain_markdown_pipeline_spec.rb:          is_expected.to include error_message(include_path, 'not found')
pipeline/plain_markdown_pipeline_spec.rb:      context 'with path to a binary file' do
pipeline/plain_markdown_pipeline_spec.rb:        let(:blob) { fake_blob(path: 'dk.png', binary: true) }
pipeline/plain_markdown_pipeline_spec.rb:        include_examples 'invalid include'
pipeline/plain_markdown_pipeline_spec.rb:      context 'with path to file in external storage' do
pipeline/plain_markdown_pipeline_spec.rb:        let(:blob) { fake_blob(path: 'dk.png', lfs: true) }
pipeline/plain_markdown_pipeline_spec.rb:        include_examples 'invalid include'
pipeline/plain_markdown_pipeline_spec.rb:      context 'with a URI that returns 404' do
pipeline/plain_markdown_pipeline_spec.rb:        let(:include_path) { 'https://example.com/some_file.md' }
pipeline/plain_markdown_pipeline_spec.rb:          stub_request(:get, include_path).to_return(status: 404, body: 'not found')
pipeline/plain_markdown_pipeline_spec.rb:        it 'renders not readable directive placeholder' do
pipeline/plain_markdown_pipeline_spec.rb:          is_expected.to include error_message(include_path, 'not readable')
pipeline/plain_markdown_pipeline_spec.rb:      context 'with path to a textual file' do
pipeline/plain_markdown_pipeline_spec.rb:        let(:include_path) { 'sample.md' }
pipeline/plain_markdown_pipeline_spec.rb:        shared_examples 'valid include' do
pipeline/plain_markdown_pipeline_spec.rb:            ['/doc/sample.md',  'doc/sample.md',     'absolute path'],
pipeline/plain_markdown_pipeline_spec.rb:            ['sample.md',       'doc/api/sample.md', 'relative path'],
pipeline/plain_markdown_pipeline_spec.rb:            ['./sample.md',     'doc/api/sample.md', 'relative path with leading ./'],
pipeline/plain_markdown_pipeline_spec.rb:            ['../sample.md',    'doc/sample.md',     'relative path to a file up one directory'],
pipeline/plain_markdown_pipeline_spec.rb:            ['../../sample.md', 'sample.md',         'relative path for a file up multiple directories']
pipeline/plain_markdown_pipeline_spec.rb:                create_and_delete_files(project, { file_path => "Content from #{include_path}" }, branch_name: 'markdown') do
pipeline/plain_markdown_pipeline_spec.rb:              it 'includes content of the file' do
pipeline/plain_markdown_pipeline_spec.rb:                is_expected.to include('<p>Include this:</p>')
pipeline/plain_markdown_pipeline_spec.rb:        context 'when requested path is a file in the repo' do
pipeline/plain_markdown_pipeline_spec.rb:          let(:requested_path) { 'doc/api/test.md' }
pipeline/plain_markdown_pipeline_spec.rb:          include_examples 'valid include'
pipeline/plain_markdown_pipeline_spec.rb:          context 'without a commit (only ref)' do
pipeline/plain_markdown_pipeline_spec.rb:            include_examples 'valid include'
pipeline/plain_markdown_pipeline_spec.rb:        context 'when requested path is a directory in the repo' do
pipeline/plain_markdown_pipeline_spec.rb:          let(:requested_path) { 'doc/api/' }
pipeline/plain_markdown_pipeline_spec.rb:          include_examples 'valid include'
pipeline/plain_markdown_pipeline_spec.rb:          context 'without a commit (only ref)' do
pipeline/plain_markdown_pipeline_spec.rb:            include_examples 'valid include'
pipeline/plain_markdown_pipeline_spec.rb:      context 'when repository is passed into the context' do
pipeline/plain_markdown_pipeline_spec.rb:        let(:include_path) { 'wiki_file.md' }
pipeline/plain_markdown_pipeline_spec.rb:        context 'when the file exists' do
pipeline/plain_markdown_pipeline_spec.rb:            create_file(include_path, 'Content from wiki', repository: wiki_repo)
pipeline/plain_markdown_pipeline_spec.rb:          it { is_expected.to include('<p>Content from wiki</p>') }
pipeline/plain_markdown_pipeline_spec.rb:        context 'when the file does not exist' do
pipeline/plain_markdown_pipeline_spec.rb:          it { is_expected.to include error_message(include_path, 'not found') }
pipeline/plain_markdown_pipeline_spec.rb:      describe 'the effect of max-includes' do
pipeline/plain_markdown_pipeline_spec.rb:            'doc/preface.md' => 'source: preface',
pipeline/plain_markdown_pipeline_spec.rb:            'doc/chapter-1.md' => 'source: chapter-1',
pipeline/plain_markdown_pipeline_spec.rb:            'license.md' => 'source: license'
pipeline/plain_markdown_pipeline_spec.rb:          create_and_delete_files(project, project_files, branch_name: 'markdown') do
pipeline/plain_markdown_pipeline_spec.rb:          stub_request(:get, 'https://example.com/some_file.md')
pipeline/plain_markdown_pipeline_spec.rb:            .to_return(status: 200, body: 'source: interwebs')
pipeline/plain_markdown_pipeline_spec.rb:          stub_request(:get, 'https://example.com/other_file.md')
pipeline/plain_markdown_pipeline_spec.rb:            .to_return(status: 200, body: 'source: intertubes')
pipeline/plain_markdown_pipeline_spec.rb:        it 'includes the content of all sources' do
pipeline/plain_markdown_pipeline_spec.rb:          expect(output.gsub(/<[^>]+>/, '').gsub(/\n\s*/, "\n").strip).to eq <<~MD.strip
pipeline/plain_markdown_pipeline_spec.rb:        context 'when the document includes more than asciidoc_max_includes' do
pipeline/plain_markdown_pipeline_spec.rb:          it 'includes only the content of the first 2 sources' do
pipeline/plain_markdown_pipeline_spec.rb:            expect(output.gsub(/<[^>]+>/, '').gsub(/\n\s*/, "\n").strip).to eq <<~MD.strip
pipeline/plain_markdown_pipeline_spec.rb:          message: "Add #{path}", branch_name: 'markdown')
pipeline/plain_markdown_pipeline_spec.rb:        repository.delete_file(project.creator, path, message: "Delete #{path}", branch_name: 'markdown')
pipeline/plain_markdown_pipeline_spec.rb:        %(Error including '<a href="#{filename}">#{filename}</a>' : #{reason})
pipeline/plain_markdown_pipeline_spec.rb:  describe 'legacy backslash handling', :aggregate_failures do
pipeline/plain_markdown_pipeline_spec.rb:    it 'converts all escapable punctuation to literals' do
pipeline/plain_markdown_pipeline_spec.rb:        char = item[:char] == '&' ? '&amp;' : item[:char]
pipeline/plain_markdown_pipeline_spec.rb:    it 'ensure we handle all the GitLab reference characters', :eager_load do
pipeline/plain_markdown_pipeline_spec.rb:    it 'does not convert non-reference/latex punctuation to spans' do
pipeline/plain_markdown_pipeline_spec.rb:      markdown = %q(\"\'\*\+\,\-\.\/\:\;\<\=\>\?\[\]\`\|) + %q[\(\)\\\\]
pipeline/plain_markdown_pipeline_spec.rb:      expect(output).not_to include('<span')
pipeline/plain_markdown_pipeline_spec.rb:    it 'does not convert other characters to literals' do
pipeline/plain_markdown_pipeline_spec.rb:      expected = '\\A\a\ \3\\'
pipeline/plain_markdown_pipeline_spec.rb:    describe 'backslash escapes are untouched in code blocks, code spans, autolinks, or raw HTML' do
pipeline/plain_markdown_pipeline_spec.rb:    describe 'work in all other contexts, including URLs and link titles, link references, and info strings in fenced code blocks' do
pipeline/plain_markdown_pipeline_spec.rb:      it 'renders correct html' do
pipeline/plain_markdown_pipeline_spec.rb:    it 'does not have a polynomial regex' do
pipeline/plain_markdown_pipeline_spec.rb:      markdown = "x \\#\n\n#{'mliteralcmliteral-' * 450000}mliteral"
pipeline/pre_process_pipeline_spec.rb:require 'spec_helper'
pipeline/pre_process_pipeline_spec.rb:  it 'pre-processes the source text' do
pipeline/pre_process_pipeline_spec.rb:      expect(result[:output]).not_to include '---'
pipeline/pre_process_pipeline_spec.rb:  it 'truncates the text if requested' do
pipeline/pre_process_pipeline_spec.rb:    text = (['foo'] * 10).join(' ')
pipeline/pre_process_pipeline_spec.rb:    expect(result[:output]).to eq('foo foo f...')
pipeline/quick_action_pipeline_spec.rb:require 'spec_helper'
pipeline/quick_action_pipeline_spec.rb:  it 'does not detect a quick action' do
pipeline/quick_action_pipeline_spec.rb:  it 'does detect a quick action' do
pipeline/quick_action_pipeline_spec.rb:  it 'does detect a multiple quick actions but not in a multi-line blockquote' do
pipeline/quick_action_pipeline_spec.rb:  it 'does not detect a quick action in a code block' do
pipeline/quick_action_pipeline_spec.rb:  it 'does not detect a quick action in raw html with a sourcepos' do
pipeline/single_line_pipeline_spec.rb:require 'spec_helper'
pipeline/single_line_pipeline_spec.rb:  it_behaves_like 'sanitize pipeline'
pipeline/single_line_pipeline_spec.rb:  it 'does not process markdown' do
pipeline/single_line_pipeline_spec.rb:    text = '_italic_'
pipeline/single_line_pipeline_spec.rb:  it 'escapes HTML' do
pipeline/single_line_pipeline_spec.rb:    text = '<p>Hello<br>World</p>'
pipeline/single_line_pipeline_spec.rb:    expect(to_html(text)).to eq('&lt;p&gt;Hello&lt;br&gt;World&lt;/p&gt;')
pipeline/single_line_pipeline_spec.rb:  it 'handles emojis and autolinking' do
pipeline/single_line_pipeline_spec.rb:    text = ':smile: using http://example.com'
pipeline/single_line_pipeline_spec.rb:    expect(result).to include('gl-emoji')
pipeline/single_line_pipeline_spec.rb:    expect(result).to include('<a href="http://example.com"')
pipeline/single_line_pipeline_spec.rb:  it 'recognizes references' do
pipeline/single_line_pipeline_spec.rb:    expect(result).to include('data-reference-type="issue"')
pipeline/single_line_pipeline_spec.rb:    expect(result).to include('data-reference-type="user"')
pipeline/full_pipeline_spec.rb:require 'spec_helper'
pipeline/full_pipeline_spec.rb:  it_behaves_like 'sanitize pipeline'
pipeline/full_pipeline_spec.rb:  describe 'References' do
pipeline/full_pipeline_spec.rb:    it 'handles markdown inside a reference' do
pipeline/full_pipeline_spec.rb:      link_content = result[:output].css('a').inner_html
pipeline/full_pipeline_spec.rb:      expect(link_content).to eq('some <code>code</code> inside')
pipeline/full_pipeline_spec.rb:    it 'sanitizes reference HTML' do
pipeline/full_pipeline_spec.rb:      link_label = '<script>bad things</script>'
pipeline/full_pipeline_spec.rb:    it 'prevents xss by not replacing the same reference in one anchor multiple times' do
pipeline/full_pipeline_spec.rb:        <a alt='&quot;#{reference_link}'></a>
pipeline/full_pipeline_spec.rb:        <a alt='"#{reference_link}'></a></i></a>
pipeline/full_pipeline_spec.rb:      expect(result).to include "<a alt='\"#{reference_link}'></a>"
pipeline/full_pipeline_spec.rb:    it 'escapes the data-original attribute on a reference' do
pipeline/full_pipeline_spec.rb:      expect(result).to include(%(data-original='\"&amp;gt;bad things'))
pipeline/full_pipeline_spec.rb:  describe 'footnotes' do
pipeline/full_pipeline_spec.rb:    it 'properly adds the necessary ids and classes' do
pipeline/full_pipeline_spec.rb:  describe 'links are detected as malicious' do
pipeline/full_pipeline_spec.rb:    it 'has tooltips for malicious links' do
pipeline/full_pipeline_spec.rb:        link   = result.css('a').first
pipeline/full_pipeline_spec.rb:        expect(link[:class]).to include('has-tooltip')
pipeline/full_pipeline_spec.rb:    it 'has no tooltips for safe links' do
pipeline/full_pipeline_spec.rb:        link   = result.css('a').first
pipeline/full_pipeline_spec.rb:  describe 'table of contents' do
pipeline/full_pipeline_spec.rb:    shared_examples 'table of contents tag' do |tag, tag_html|
pipeline/full_pipeline_spec.rb:      it 'inserts a table of contents' do
pipeline/full_pipeline_spec.rb:      it 'does not insert a table of contents' do
pipeline/full_pipeline_spec.rb:    context 'with [[_TOC_]] as tag' do
pipeline/full_pipeline_spec.rb:      it_behaves_like 'table of contents tag', '[[_TOC_]]', '<a href="_TOC_" data-wikilink="true">_TOC_</a>'
pipeline/full_pipeline_spec.rb:    context 'with [toc] as tag' do
pipeline/full_pipeline_spec.rb:      it_behaves_like 'table of contents tag', '[toc]', '[toc]'
pipeline/full_pipeline_spec.rb:      it_behaves_like 'table of contents tag', '[TOC]', '[TOC]'
pipeline/full_pipeline_spec.rb:  describe 'backslash escapes' do
pipeline/full_pipeline_spec.rb:    it 'does not convert an escaped reference' do
pipeline/full_pipeline_spec.rb:    it 'converts user reference with escaped underscore because of italics' do
pipeline/full_pipeline_spec.rb:      markdown = '_@test\__'
pipeline/full_pipeline_spec.rb:      expect(output).to include('<em>@test_</em>')
pipeline/full_pipeline_spec.rb:    context 'when a reference (such as a label name) is autocompleted with characters that require escaping' do
pipeline/full_pipeline_spec.rb:        # true   | 'a~bug'      | '~"a\~bug"'
pipeline/full_pipeline_spec.rb:        # true   | 'b~~bug~~'   | '~"b\~\~bug\~\~"'
pipeline/full_pipeline_spec.rb:        true   | 'c_bug_'     | '~c_bug\_'
pipeline/full_pipeline_spec.rb:        true   | 'c_bug_'     | 'Label ~c_bug\_ and _more_ text'
pipeline/full_pipeline_spec.rb:        true   | 'd _bug_'    | '~"d \_bug\_"'
pipeline/full_pipeline_spec.rb:        true   | 'e*bug*'     | '~"e\*bug\*"'
pipeline/full_pipeline_spec.rb:        true   | 'f *bug*'    | '~"f \*bug\*"'
pipeline/full_pipeline_spec.rb:        true   | 'f *bug*'    | 'Label ~"f \*bug\*" **with** more text'
pipeline/full_pipeline_spec.rb:        true   | 'g`bug`'     | '~"g\`bug\`" '
pipeline/full_pipeline_spec.rb:        true   | 'h `bug`'    | '~"h \`bug\`"'
pipeline/full_pipeline_spec.rb:        it 'detects valid escaped reference' do
pipeline/full_pipeline_spec.rb:          expect(result[:output].css('a').first.attr('class')).to eq 'gfm gfm-label has-tooltip gl-link gl-label-link'
pipeline/full_pipeline_spec.rb:          expect(result[:output].css('a').first.content).to eq label_name
pipeline/full_pipeline_spec.rb:  context 'when input is malicious' do
pipeline/full_pipeline_spec.rb:    let_it_be(:markdown1) { '![a ' * 3 }
pipeline/full_pipeline_spec.rb:    let_it_be(:markdown7) { ':y: ' * 190000 }
pipeline/full_pipeline_spec.rb:    let_it_be(:markdown8) { '<img>' * 100000 }
pipeline/full_pipeline_spec.rb:      "'![a ' * 3"                                        | ref(:markdown1)
pipeline/full_pipeline_spec.rb:      '"$1$\n" * 190000'                                  | ref(:markdown2)
pipeline/full_pipeline_spec.rb:      '"[^1]\n[^1]:\n" * 100000'                          | ref(:markdown3)
pipeline/full_pipeline_spec.rb:      '"[](a)" * 190000'                                  | ref(:markdown4)
pipeline/full_pipeline_spec.rb:      '"|x|x|x|x|x|\n-|-|-|-|-|\n|a|\n|a|\n|a|\n" * 6900' | ref(:markdown5)
pipeline/full_pipeline_spec.rb:      '"`a^2+b^2=c^2` + " * 56000'                        | ref(:markdown5)
pipeline/full_pipeline_spec.rb:      "':y: ' * 190000"                                   | ref(:markdown7)
pipeline/full_pipeline_spec.rb:      "'<img>' * 100000"                                  | ref(:markdown8)
pipeline/full_pipeline_spec.rb:      it 'is not long running' do
pipeline/full_pipeline_spec.rb:  describe 'when using include in code segements' do
pipeline/full_pipeline_spec.rb:    let_it_be(:ref)            { 'markdown' }
pipeline/full_pipeline_spec.rb:    let_it_be(:requested_path) { '/' }
pipeline/full_pipeline_spec.rb:        'diagram.puml' => "@startuml\nBob -> Sara : Hello\n@enduml",
pipeline/full_pipeline_spec.rb:        'code.yaml' => "---\ntest: true"
pipeline/full_pipeline_spec.rb:    it 'renders PlanUML' do
pipeline/full_pipeline_spec.rb:      is_expected.to include 'http://localhost:8080/png/U9npA2v9B2efpStXSifFKj2rKmXEB4fKi5BmICt9oUToICrB0Se10EdD34a0'
pipeline/full_pipeline_spec.rb:    it 'renders code' do
pipeline/full_pipeline_spec.rb:      is_expected.to include 'language-yaml'
pipeline/full_pipeline_spec.rb:      is_expected.to include '<span class="na">test</span>'
pipeline/full_pipeline_spec.rb:      is_expected.to include '<span class="kc">true</span>'
pipeline/full_pipeline_spec.rb:  describe 'math does not get rendered as link' do
pipeline/full_pipeline_spec.rb:      '$$[(a+b)c](d+e)$$',
pipeline/full_pipeline_spec.rb:      '$`[(a+b)c](d+e)`$'
pipeline/full_pipeline_spec.rb:      it "when using '#{input}' as input" do
pipeline/full_pipeline_spec.rb:        expect(result.css('a').first).to be_nil
pipeline/commit_description_pipeline_spec.rb:require 'spec_helper'
pipeline/commit_description_pipeline_spec.rb:  describe 'formatting a cherry-picked commit description html' do
pipeline/commit_description_pipeline_spec.rb:    it 'formats correctly' do
pipeline/emoji_pipeline_spec.rb:require 'spec_helper'
pipeline/emoji_pipeline_spec.rb:  let(:emoji) { TanukiEmoji.find_by_alpha_code('100') }
pipeline/emoji_pipeline_spec.rb:  it_behaves_like 'sanitize pipeline'
pipeline/emoji_pipeline_spec.rb:  it 'replaces emoji' do
pipeline/emoji_pipeline_spec.rb:    expect(parse('Hello world :100:')).to eq(expected_result)
pipeline/emoji_pipeline_spec.rb:  it 'filters out HTML tags' do
pipeline/emoji_pipeline_spec.rb:    expect(parse('Hello <b>world</b> :100:')).to eq(expected_result)
pipeline/post_process_pipeline_spec.rb:require 'spec_helper'
pipeline/post_process_pipeline_spec.rb:  let(:context) { { project: project, ref: 'master' } }
pipeline/post_process_pipeline_spec.rb:  context 'when a document only has upload links' do
pipeline/post_process_pipeline_spec.rb:    it 'does not make any Gitaly calls', :request_store do
pipeline/post_process_pipeline_spec.rb:  context 'when both upload and repository links are present' do
pipeline/post_process_pipeline_spec.rb:    it 'searches for attributes only once' do
pipeline/gfm_pipeline_spec.rb:require 'spec_helper'
pipeline/gfm_pipeline_spec.rb:  it_behaves_like 'sanitize pipeline'
pipeline/gfm_pipeline_spec.rb:  describe 'integration between parsing regular and external issue references' do
pipeline/gfm_pipeline_spec.rb:    context 'when internal issue tracker is enabled' do
pipeline/gfm_pipeline_spec.rb:      context 'when shorthand pattern #ISSUE_ID is used' do
pipeline/gfm_pipeline_spec.rb:        it 'links an internal issues and keep updated nodes in result[:reference_filter_nodes]', :aggregate_failures do
pipeline/gfm_pipeline_spec.rb:          link = result[:output].css('a').first
pipeline/gfm_pipeline_spec.rb:          expect(link['href']).to eq(Gitlab::Routing.url_helpers.project_issue_path(project, issue))
pipeline/gfm_pipeline_spec.rb:      it 'executes :each_node only once for first reference filter' do
pipeline/gfm_pipeline_spec.rb:      context 'when shorthand pattern #ISSUE_ID is used' do
pipeline/gfm_pipeline_spec.rb:        it 'links an internal issue  if it exists' do
pipeline/gfm_pipeline_spec.rb:          link = result.css('a').first
pipeline/gfm_pipeline_spec.rb:          expect(link['href']).to eq(
pipeline/gfm_pipeline_spec.rb:        it 'does not link any issue if it does not exist on GitLab' do
pipeline/gfm_pipeline_spec.rb:          markdown = '#12'
pipeline/gfm_pipeline_spec.rb:          expect(result.css('a')).to be_empty
pipeline/gfm_pipeline_spec.rb:      it 'allows to use long external reference syntax for Redmine' do
pipeline/gfm_pipeline_spec.rb:        markdown = 'API_32-12'
pipeline/gfm_pipeline_spec.rb:        link = result.css('a').first
pipeline/gfm_pipeline_spec.rb:        expect(link['href']).to eq 'http://issues.example.com/issues/12'
pipeline/gfm_pipeline_spec.rb:      it 'parses cross-project references to regular issues' do
pipeline/gfm_pipeline_spec.rb:        link = result.css('a').first
pipeline/gfm_pipeline_spec.rb:        expect(link['href']).to eq(
pipeline/gfm_pipeline_spec.rb:    context 'when internal issue tracker is disabled' do
pipeline/gfm_pipeline_spec.rb:      it 'allows to use shorthand external reference syntax for Redmine' do
pipeline/gfm_pipeline_spec.rb:        markdown = '#12'
pipeline/gfm_pipeline_spec.rb:        link = result.css('a').first
pipeline/gfm_pipeline_spec.rb:        expect(link['href']).to eq 'http://issues.example.com/issues/12'
pipeline/gfm_pipeline_spec.rb:      it 'allows to use long external reference syntax for Redmine' do
pipeline/gfm_pipeline_spec.rb:        markdown = 'API_32-12'
pipeline/gfm_pipeline_spec.rb:        link = result.css('a').first
pipeline/gfm_pipeline_spec.rb:        expect(link['href']).to eq 'http://issues.example.com/issues/12'
pipeline/gfm_pipeline_spec.rb:      it 'parses cross-project references to regular issues' do
pipeline/gfm_pipeline_spec.rb:        link = result.css('a').first
pipeline/gfm_pipeline_spec.rb:        expect(link['href']).to eq(
pipeline/gfm_pipeline_spec.rb:  describe 'markdown link or image urls having spaces' do
pipeline/gfm_pipeline_spec.rb:    it 'rewrites links with spaces in url' do
pipeline/gfm_pipeline_spec.rb:    it 'rewrites images with spaces in url' do
pipeline/gfm_pipeline_spec.rb:    it 'sanitizes the fixed link' do
pipeline/gfm_pipeline_spec.rb:  describe 'emoji in references' do
pipeline/gfm_pipeline_spec.rb:    let(:emoji) { '' }
pipeline/gfm_pipeline_spec.rb:    it 'renders a label reference with emoji inside' do
pipeline/gfm_pipeline_spec.rb:    it 'renders a milestone reference with emoji inside' do
pipeline/gfm_pipeline_spec.rb:  context 'when label reference is similar to a commit SHA' do
pipeline/gfm_pipeline_spec.rb:    let(:numeric_commit_sha) { '8634272' }
pipeline/gfm_pipeline_spec.rb:    it 'renders a label reference' do
pipeline/gfm_pipeline_spec.rb:  describe 'asset proxy' do
pipeline/gfm_pipeline_spec.rb:    let(:image)   { '![proxy](http://example.com/test.png)' }
pipeline/gfm_pipeline_spec.rb:    let(:proxy)   { 'https://assets.example.com/08df250eeeef1a8cf2c761475ac74c5065105612/687474703a2f2f6578616d706c652e636f6d2f746573742e706e67' }
pipeline/gfm_pipeline_spec.rb:      stub_asset_proxy_setting(secret_key: 'shared-secret')
pipeline/gfm_pipeline_spec.rb:      stub_asset_proxy_setting(url: 'https://assets.example.com')
pipeline/gfm_pipeline_spec.rb:    it 'replaces a lazy loaded img src' do
pipeline/gfm_pipeline_spec.rb:      result = doc.css('img').first
pipeline/gfm_pipeline_spec.rb:      expect(result['data-src']).to eq(proxy)
pipeline/gfm_pipeline_spec.rb:    it 'autolinks images to the proxy' do
pipeline/gfm_pipeline_spec.rb:      result = doc.css('a').first
pipeline/gfm_pipeline_spec.rb:      expect(result['href']).to eq(proxy)
pipeline/gfm_pipeline_spec.rb:      expect(result['data-canonical-src']).to eq('http://example.com/test.png')
pipeline/gfm_pipeline_spec.rb:    it 'properly adds tooltips to link for IDN images' do
pipeline/gfm_pipeline_spec.rb:      image  = '![proxy](http://example.com/test.png)'
pipeline/gfm_pipeline_spec.rb:      proxy  = 'https://assets.example.com/6d8b634c412a23c6bfe1b2963f174febf5635ddd/687474703a2f2f6578612546302539462539382538346d706c652e636f6d2f746573742e706e67'
pipeline/gfm_pipeline_spec.rb:      result = doc.css('a').first
pipeline/gfm_pipeline_spec.rb:      expect(result['href']).to eq(proxy)
pipeline/gfm_pipeline_spec.rb:      expect(result['data-canonical-src']).to eq('http://exa%F0%9F%98%84mple.com/test.png')
pipeline/gfm_pipeline_spec.rb:      expect(result['title']).to eq 'http://xn--example-6p25f.com/test.png'
pipeline/email_pipeline_spec.rb:require 'spec_helper'
pipeline/email_pipeline_spec.rb:  describe '.filters' do
pipeline/email_pipeline_spec.rb:    it_behaves_like 'sanitize pipeline'
pipeline/email_pipeline_spec.rb:    it 'returns the expected type' do
pipeline/email_pipeline_spec.rb:    it 'excludes ImageLazyLoadFilter' do
pipeline/email_pipeline_spec.rb:    it 'shows punycode for autolinks' do
pipeline/email_pipeline_spec.rb:        link   = result.css('a').first
pipeline/email_pipeline_spec.rb:        expect(link.content).to include('http://xn--')
pipeline/jira_import/adf_commonmark_pipeline_spec.rb:require 'spec_helper'
pipeline/jira_import/adf_commonmark_pipeline_spec.rb:  let_it_be(:fixtures_path) { 'lib/kramdown/atlassian_document_format' }
pipeline/jira_import/adf_commonmark_pipeline_spec.rb:  it 'converts text in Atlassian Document Format' do
pipeline/jira_import/adf_commonmark_pipeline_spec.rb:    source = fixture_file(File.join(fixtures_path, 'paragraph.json'))
pipeline/jira_import/adf_commonmark_pipeline_spec.rb:    target = fixture_file(File.join(fixtures_path, 'paragraph.md'))
pipeline/broadcast_message_pipeline_spec.rb:require 'spec_helper'
pipeline/broadcast_message_pipeline_spec.rb:  it_behaves_like 'sanitize pipeline'
pipeline/service_desk_email_pipeline_spec.rb:require 'spec_helper'
pipeline/service_desk_email_pipeline_spec.rb:  it_behaves_like 'sanitize pipeline'
pipeline/service_desk_email_pipeline_spec.rb:  describe '.filters' do
pipeline/service_desk_email_pipeline_spec.rb:    it 'returns the expected type' do
pipeline/service_desk_email_pipeline_spec.rb:    it 'excludes ServiceDeskUploadLinkFilter' do
pipeline/description_pipeline_spec.rb:require 'spec_helper'
pipeline/description_pipeline_spec.rb:    unwrap = !html.start_with?('<p ')
pipeline/description_pipeline_spec.rb:    output.gsub!(%r{\A<p dir="auto">(.*)</p>(.*)\z}, '\1\2') if unwrap
pipeline/description_pipeline_spec.rb:  it_behaves_like 'sanitize pipeline'
pipeline/description_pipeline_spec.rb:  it 'uses a limited allowlist' do
pipeline/description_pipeline_spec.rb:    doc = parse('# Description')
pipeline/description_pipeline_spec.rb:    expect(doc.strip).to eq 'Description'
pipeline/description_pipeline_spec.rb:    it "removes '#{elem}' elements" do
pipeline/description_pipeline_spec.rb:      expect(parse(act).strip).to eq 'Description'
pipeline/description_pipeline_spec.rb:    it "still allows '#{elem}' elements" do
pipeline/description_pipeline_spec.rb:  it "still allows 'p' elements" do
pipeline/wiki_pipeline_spec.rb:require 'spec_helper'
pipeline/wiki_pipeline_spec.rb:  let_it_be(:page)      { build(:wiki_page, wiki: wiki, title: 'nested/twice/start-page') }
pipeline/wiki_pipeline_spec.rb:  it_behaves_like 'sanitize pipeline'
pipeline/wiki_pipeline_spec.rb:  describe 'TableOfContents' do
pipeline/wiki_pipeline_spec.rb:    it 'replaces the tag with the TableOfContentsTagFilter result' do
pipeline/wiki_pipeline_spec.rb:        expect(result[:output].text).not_to include '[['
pipeline/wiki_pipeline_spec.rb:        expect(result[:output].text).not_to include 'TOC'
pipeline/wiki_pipeline_spec.rb:    it 'is not case-sensitive' do
pipeline/wiki_pipeline_spec.rb:    it 'works with alternative [toc] tag' do
pipeline/wiki_pipeline_spec.rb:    it 'handles an empty pipeline result' do
pipeline/wiki_pipeline_spec.rb:        expect(output).not_to include('<ul>')
pipeline/wiki_pipeline_spec.rb:        expect(output).not_to include('[[<em>TOC</em>]]')
pipeline/wiki_pipeline_spec.rb:    { 'when GitLab is hosted at a root URL' => '',
pipeline/wiki_pipeline_spec.rb:      'when GitLab is hosted at a relative URL' => '/nested/relative/gitlab' }.each do |test_name, relative_url_root|
pipeline/wiki_pipeline_spec.rb:            it 'rewrites non-file links to be at the scope of the wiki root' do
pipeline/wiki_pipeline_spec.rb:            it 'rewrites non-file links (with spaces) to be at the scope of the wiki root' do
pipeline/wiki_pipeline_spec.rb:            it 'rewrites links with anchor' do
pipeline/wiki_pipeline_spec.rb:              markdown = '[Link to Header](start-page#title)'
pipeline/wiki_pipeline_spec.rb:            it 'rewrites links (with spaces) with anchor' do
pipeline/wiki_pipeline_spec.rb:              markdown = '[Link to Header](start page#title)'
pipeline/wiki_pipeline_spec.rb:            it 'rewrites non-file links to be at the scope of the wiki root' do
pipeline/wiki_pipeline_spec.rb:            it 'rewrites file links to be at the scope of the wiki root' do
pipeline/wiki_pipeline_spec.rb:          it "doesn't rewrite links" do
pipeline/wiki_pipeline_spec.rb:            expect(output).to include('href="http://example.com/page"')
pipeline/wiki_pipeline_spec.rb:              it "doesn't include a prohibited slug in a (.) relative link '#{link}'" do
pipeline/wiki_pipeline_spec.rb:              it "doesn't include a prohibited slug in a (..) relative link '#{link}'" do
pipeline/wiki_pipeline_spec.rb:  describe 'videos and audio' do
pipeline/wiki_pipeline_spec.rb:    it 'generates video html structure' do
pipeline/wiki_pipeline_spec.rb:    it 'rewrites and replaces video links names with white spaces to %20' do
pipeline/wiki_pipeline_spec.rb:    it 'generates audio html structure' do
pipeline/wiki_pipeline_spec.rb:    it 'rewrites and replaces audio links names with white spaces to %20' do
pipeline/wiki_pipeline_spec.rb:  describe 'gollum tag filters' do
pipeline/wiki_pipeline_spec.rb:    context 'when local image file exists' do
pipeline/wiki_pipeline_spec.rb:      it 'sets the proper attributes for the image' do
pipeline/wiki_pipeline_spec.rb:        gollum_file_double = double('Gollum::File',
pipeline/wiki_pipeline_spec.rb:          mime_type: 'image/jpeg',
pipeline/wiki_pipeline_spec.rb:          name: 'images/image.jpg',
pipeline/wiki_pipeline_spec.rb:          path: 'images/image.jpg',
pipeline/wiki_pipeline_spec.rb:          data: '')
pipeline/wiki_pipeline_spec.rb:        expect(doc.css('a')[0].attr('href')).to eq(full_path)
pipeline/wiki_pipeline_spec.rb:        expect(doc.css('img')[0].attr('class')).to eq('gfm lazy')
pipeline/wiki_pipeline_spec.rb:        expect(doc.css('img')[0].attr('data-src')).to eq(full_path)
pipeline/incident_management/timeline_event_pipeline_spec.rb:require 'spec_helper'
pipeline/incident_management/timeline_event_pipeline_spec.rb:  it_behaves_like 'sanitize pipeline'
pipeline/incident_management/timeline_event_pipeline_spec.rb:  describe '.filters' do
pipeline/incident_management/timeline_event_pipeline_spec.rb:    it 'contains required filters' do
pipeline/incident_management/timeline_event_pipeline_spec.rb:  describe '.to_html' do
pipeline/incident_management/timeline_event_pipeline_spec.rb:    context 'when markdown contains font style transformations' do
pipeline/incident_management/timeline_event_pipeline_spec.rb:      let(:markdown) { '**bold** _italic_ `code`' }
pipeline/incident_management/timeline_event_pipeline_spec.rb:      it { is_expected.to eq('<p><strong>bold</strong> <em>italic</em> <code>code</code></p>') }
pipeline/incident_management/timeline_event_pipeline_spec.rb:    context 'when markdown contains banned HTML tags' do
pipeline/incident_management/timeline_event_pipeline_spec.rb:      let(:markdown) { '<div>div</div><h1>h1</h1>' }
pipeline/incident_management/timeline_event_pipeline_spec.rb:      it 'filters out banned tags' do
pipeline/incident_management/timeline_event_pipeline_spec.rb:        is_expected.to eq(' div  h1 ')
pipeline/incident_management/timeline_event_pipeline_spec.rb:    context 'when markdown contains links' do
pipeline/incident_management/timeline_event_pipeline_spec.rb:      let(:markdown) { '[GitLab](https://gitlab.com)' }
pipeline/incident_management/timeline_event_pipeline_spec.rb:    context 'when markdown contains images' do
pipeline/incident_management/timeline_event_pipeline_spec.rb:      let(:markdown) { '![Name](/path/to/image.png)' }
pipeline/incident_management/timeline_event_pipeline_spec.rb:      it 'replaces image with a link to the image' do
pipeline/incident_management/timeline_event_pipeline_spec.rb:          '<p><a class="with-attachment-icon" href="/path/to/image.png" target="_blank" rel="noopener noreferrer">Name</a></p>'
pipeline/incident_management/timeline_event_pipeline_spec.rb:    context 'when markdown contains emojis' do
pipeline/incident_management/timeline_event_pipeline_spec.rb:      let(:markdown) { ':+1:' }
pipeline/incident_management/timeline_event_pipeline_spec.rb:      it 'renders emojis wrapped in <gl-emoji> tag' do
pipeline/incident_management/timeline_event_pipeline_spec.rb:    context 'when markdown contains labels' do
pipeline/incident_management/timeline_event_pipeline_spec.rb:      let(:label) { create(:label, project: project, title: 'backend') }
pipeline/incident_management/timeline_event_pipeline_spec.rb:      it 'replaces existing label to a link' do
pipeline/incident_management/timeline_event_pipeline_spec.rb:    context 'when markdown contains table' do
pipeline/incident_management/timeline_event_pipeline_spec.rb:      let(:markdown) { '<table><tr><th>table head</th><tr><tr><td>table content</td></tr></table>' }
pipeline/incident_management/timeline_event_pipeline_spec.rb:      it { is_expected.to eq('table headtable content') }
pipeline/incident_management/timeline_event_pipeline_spec.rb:    context 'when markdown contains a reference to an issue' do
pipeline/incident_management/timeline_event_pipeline_spec.rb:      it 'contains a link to the issue' do
pipeline/incident_management/timeline_event_pipeline_spec.rb:    context 'when markdown contains a reference to a merge request' do
pipeline/incident_management/timeline_event_pipeline_spec.rb:      it 'contains a link to the merge request' do
color_parser_spec.rb:require 'fast_spec_helper'
color_parser_spec.rb:  describe '.parse' do
color_parser_spec.rb:    context 'HEX format' do
color_parser_spec.rb:        '#abc', '#ABC',
color_parser_spec.rb:        '#d2d2d2', '#D2D2D2',
color_parser_spec.rb:        '#123a', '#123A',
color_parser_spec.rb:        '#123456aa', '#123456AA'
color_parser_spec.rb:        '#', '#1', '#12', '#12g', '#12G',
color_parser_spec.rb:        '#12345', '#r2r2r2', '#R2R2R2', '#1234567',
color_parser_spec.rb:        '# 123', '# 1234', '# 123456', '# 12345678',
color_parser_spec.rb:        '#1 2 3', '#123 4', '#12 34 56', '#123456 78'
color_parser_spec.rb:    context 'RGB format' do
color_parser_spec.rb:        'rgb(0,0,0)', 'rgb(255,255,255)',
color_parser_spec.rb:        'rgb(0, 0, 0)', 'RGB(0,0,0)',
color_parser_spec.rb:        'rgb(0,0,0,0)',  'rgb(0,0,0,0.0)',  'rgb(0,0,0,.0)',
color_parser_spec.rb:        'rgb(0,0,0, 0)', 'rgb(0,0,0, 0.0)', 'rgb(0,0,0, .0)',
color_parser_spec.rb:        'rgb(0,0,0,1)',  'rgb(0,0,0,1.0)',
color_parser_spec.rb:        'rgba(0,0,0)', 'rgba(0,0,0,0)', 'RGBA(0,0,0)',
color_parser_spec.rb:        'rgb(0%,0%,0%)', 'rgba(0%,0%,0%,0%)'
color_parser_spec.rb:        'FOOrgb(0,0,0)', 'rgb(0,0,0)BAR',
color_parser_spec.rb:        'rgb(0,0,-1)', 'rgb(0,0,-0)', 'rgb(0,0,256)',
color_parser_spec.rb:        'rgb(0,0,0,-0.1)', 'rgb(0,0,0,-0.0)', 'rgb(0,0,0,-.1)',
color_parser_spec.rb:        'rgb(0,0,0,1.1)',  'rgb(0,0,0,2)',
color_parser_spec.rb:        'rgba(0,0,0,)', 'rgba(0,0,0,0.)', 'rgba(0,0,0,1.)',
color_parser_spec.rb:        'rgb(0,0,0%)', 'rgb(101%,0%,0%)'
color_parser_spec.rb:    context 'HSL format' do
color_parser_spec.rb:        'hsl(0,0%,0%)', 'hsl(0,100%,100%)',
color_parser_spec.rb:        'hsl(540,0%,0%)', 'hsl(-720,0%,0%)',
color_parser_spec.rb:        'hsl(0deg,0%,0%)', 'hsl(0DEG,0%,0%)',
color_parser_spec.rb:        'hsl(0, 0%, 0%)', 'HSL(0,0%,0%)',
color_parser_spec.rb:        'hsl(0,0%,0%,0)', 'hsl(0,0%,0%,0.0)', 'hsl(0,0%,0%,.0)',
color_parser_spec.rb:        'hsl(0,0%,0%, 0)', 'hsl(0,0%,0%, 0.0)', 'hsl(0,0%,0%, .0)',
color_parser_spec.rb:        'hsl(0,0%,0%,1)', 'hsl(0,0%,0%,1.0)',
color_parser_spec.rb:        'hsla(0,0%,0%)', 'hsla(0,0%,0%,0)', 'HSLA(0,0%,0%)',
color_parser_spec.rb:        'hsl(1rad,0%,0%)', 'hsl(1.1rad,0%,0%)', 'hsl(.1rad,0%,0%)',
color_parser_spec.rb:        'hsl(-1rad,0%,0%)', 'hsl(1RAD,0%,0%)'
color_parser_spec.rb:        'hsl(+0,0%,0%)', 'hsl(0,0,0%)', 'hsl(0,0%,0)', 'hsl(0 deg,0%,0%)',
color_parser_spec.rb:        'hsl(0,-0%,0%)', 'hsl(0,101%,0%)', 'hsl(0,-1%,0%)',
color_parser_spec.rb:        'hsl(0,0%,0%,-0.1)', 'hsl(0,0%,0%,-.1)',
color_parser_spec.rb:        'hsl(0,0%,0%,1.1)', 'hsl(0,0%,0%,2)',
color_parser_spec.rb:        'hsl(0,0%,0%,)', 'hsl(0,0%,0%,0.)', 'hsl(0,0%,0%,1.)',
color_parser_spec.rb:        'hsl(deg,0%,0%)', 'hsl(rad,0%,0%)'
the_stuff_1.txt:object_renderer_spec.rb:  let(:object) { Note.new(note: 'hello', note_html: '<p dir="auto">hello</p>', cached_markdown_version: Gitlab::MarkdownCache::CACHE_COMMONMARK_VERSION_SHIFTED) }
the_stuff_1.txt:object_renderer_spec.rb:        expect(object.redacted_note_html).to eq '<p dir="auto">hello</p>'
the_stuff_1.txt:object_renderer_spec.rb:          thing.title = "Merge branch 'branch-merged' into 'master'"
the_stuff_1.txt:object_renderer_spec.rb:        expect(cacheless_thing.redacted_title_html).to eq("Merge branch 'branch-merged' into 'master'")
the_stuff_1.txt:pipeline_spec.rb:        'unsupported pipeline name "label" (String)'
the_stuff_1.txt:issuable_extractor_spec.rb:      "<a href='' data-issue='#{issue.id}' data-reference-type='issue' class='gfm'>text</a>"
the_stuff_1.txt:issuable_extractor_spec.rb:      "<a href='' data-work-item='#{work_item.id}' data-reference-type='work_item' class='gfm'>text</a>"
the_stuff_1.txt:issuable_extractor_spec.rb:      "<a href='' data-work-item='#{group_work_item.id}' data-reference-type='work_item' class='gfm'>text</a>"
the_stuff_1.txt:issuable_extractor_spec.rb:      "<a href='' data-merge-request='#{merge_request.id}' data-reference-type='merge_request' class='gfm'>text</a>"
the_stuff_1.txt:extract_dictionary.py:	matches = re.findall(r'"(.*?)"', data) # Extract the stuff from the thing...
the_stuff_1.txt:extract_dictionary.py:		print(f'"{s}"')
the_stuff_1.txt:reference_parser/base_parser_spec.rb:          links = Nokogiri::HTML.fragment("<a data-foo='#{user.id}'></a>")
the_stuff_1.txt:reference_parser/base_parser_spec.rb:          links = Nokogiri::HTML.fragment("<a data-foo='1'></a><a data-foo='2'></a>").children
the_stuff_1.txt:reference_parser/base_parser_spec.rb:        links = Nokogiri::HTML.fragment('<a data-foo="1"></a>').children
the_stuff_1.txt:reference_parser/base_parser_spec.rb:      link = Nokogiri::HTML.fragment('<a data-project="1" data-foo="2"></a>')
the_stuff_1.txt:pipeline/single_line_markdown_pipeline_spec.rb:    expect(result).to include('<a href="http://example.com"')
the_stuff_1.txt:pipeline/single_line_markdown_pipeline_spec.rb:    expect(result).to include('data-reference-type="issue"')
the_stuff_1.txt:pipeline/single_line_markdown_pipeline_spec.rb:    expect(result).to include('data-reference-type="user"')
the_stuff_1.txt:pipeline/single_line_markdown_pipeline_spec.rb:    expect(result).not_to include('data-reference-type="issue"')
the_stuff_1.txt:pipeline/single_line_markdown_pipeline_spec.rb:    expect(result).not_to include('data-reference-type="user"')
the_stuff_1.txt:pipeline/plain_markdown_pipeline_spec.rb:                create_and_delete_files(project, { file_path => "Content from #{include_path}" }, branch_name: 'markdown') do
the_stuff_1.txt:pipeline/plain_markdown_pipeline_spec.rb:          expect(output.gsub(/<[^>]+>/, '').gsub(/\n\s*/, "\n").strip).to eq <<~MD.strip
the_stuff_1.txt:pipeline/plain_markdown_pipeline_spec.rb:            expect(output.gsub(/<[^>]+>/, '').gsub(/\n\s*/, "\n").strip).to eq <<~MD.strip
the_stuff_1.txt:pipeline/plain_markdown_pipeline_spec.rb:          message: "Add #{path}", branch_name: 'markdown')
the_stuff_1.txt:pipeline/plain_markdown_pipeline_spec.rb:        repository.delete_file(project.creator, path, message: "Delete #{path}", branch_name: 'markdown')
the_stuff_1.txt:pipeline/plain_markdown_pipeline_spec.rb:        %(Error including '<a href="#{filename}">#{filename}</a>' : #{reason})
the_stuff_1.txt:pipeline/plain_markdown_pipeline_spec.rb:      markdown = %q(\"\'\*\+\,\-\.\/\:\;\<\=\>\?\[\]\`\|) + %q[\(\)\\\\]
the_stuff_1.txt:pipeline/plain_markdown_pipeline_spec.rb:      markdown = "x \\#\n\n#{'mliteralcmliteral-' * 450000}mliteral"
the_stuff_1.txt:pipeline/single_line_pipeline_spec.rb:    expect(result).to include('<a href="http://example.com"')
the_stuff_1.txt:pipeline/single_line_pipeline_spec.rb:    expect(result).to include('data-reference-type="issue"')
the_stuff_1.txt:pipeline/single_line_pipeline_spec.rb:    expect(result).to include('data-reference-type="user"')
the_stuff_1.txt:pipeline/full_pipeline_spec.rb:        <a alt='"#{reference_link}'></a></i></a>
the_stuff_1.txt:pipeline/full_pipeline_spec.rb:      expect(result).to include "<a alt='\"#{reference_link}'></a>"
the_stuff_1.txt:pipeline/full_pipeline_spec.rb:      expect(result).to include(%(data-original='\"&amp;gt;bad things'))
the_stuff_1.txt:pipeline/full_pipeline_spec.rb:      it_behaves_like 'table of contents tag', '[[_TOC_]]', '<a href="_TOC_" data-wikilink="true">_TOC_</a>'
the_stuff_1.txt:pipeline/full_pipeline_spec.rb:        # true   | 'a~bug'      | '~"a\~bug"'
the_stuff_1.txt:pipeline/full_pipeline_spec.rb:        # true   | 'b~~bug~~'   | '~"b\~\~bug\~\~"'
the_stuff_1.txt:pipeline/full_pipeline_spec.rb:        true   | 'd _bug_'    | '~"d \_bug\_"'
the_stuff_1.txt:pipeline/full_pipeline_spec.rb:        true   | 'e*bug*'     | '~"e\*bug\*"'
the_stuff_1.txt:pipeline/full_pipeline_spec.rb:        true   | 'f *bug*'    | '~"f \*bug\*"'
the_stuff_1.txt:pipeline/full_pipeline_spec.rb:        true   | 'f *bug*'    | 'Label ~"f \*bug\*" **with** more text'
the_stuff_1.txt:pipeline/full_pipeline_spec.rb:        true   | 'g`bug`'     | '~"g\`bug\`" '
the_stuff_1.txt:pipeline/full_pipeline_spec.rb:        true   | 'h `bug`'    | '~"h \`bug\`"'
the_stuff_1.txt:pipeline/full_pipeline_spec.rb:      "'![a ' * 3"                                        | ref(:markdown1)
the_stuff_1.txt:pipeline/full_pipeline_spec.rb:      '"$1$\n" * 190000'                                  | ref(:markdown2)
the_stuff_1.txt:pipeline/full_pipeline_spec.rb:      '"[^1]\n[^1]:\n" * 100000'                          | ref(:markdown3)
the_stuff_1.txt:pipeline/full_pipeline_spec.rb:      '"[](a)" * 190000'                                  | ref(:markdown4)
the_stuff_1.txt:pipeline/full_pipeline_spec.rb:      '"|x|x|x|x|x|\n-|-|-|-|-|\n|a|\n|a|\n|a|\n" * 6900' | ref(:markdown5)
the_stuff_1.txt:pipeline/full_pipeline_spec.rb:      '"`a^2+b^2=c^2` + " * 56000'                        | ref(:markdown5)
the_stuff_1.txt:pipeline/full_pipeline_spec.rb:      "':y: ' * 190000"                                   | ref(:markdown7)
the_stuff_1.txt:pipeline/full_pipeline_spec.rb:      "'<img>' * 100000"                                  | ref(:markdown8)
the_stuff_1.txt:pipeline/full_pipeline_spec.rb:        'diagram.puml' => "@startuml\nBob -> Sara : Hello\n@enduml",
the_stuff_1.txt:pipeline/full_pipeline_spec.rb:        'code.yaml' => "---\ntest: true"
the_stuff_1.txt:pipeline/full_pipeline_spec.rb:      is_expected.to include '<span class="na">test</span>'
the_stuff_1.txt:pipeline/full_pipeline_spec.rb:      is_expected.to include '<span class="kc">true</span>'
the_stuff_1.txt:pipeline/full_pipeline_spec.rb:      it "when using '#{input}' as input" do
the_stuff_1.txt:pipeline/description_pipeline_spec.rb:    output.gsub!(%r{\A<p dir="auto">(.*)</p>(.*)\z}, '\1\2') if unwrap
the_stuff_1.txt:pipeline/description_pipeline_spec.rb:    it "removes '#{elem}' elements" do
the_stuff_1.txt:pipeline/description_pipeline_spec.rb:    it "still allows '#{elem}' elements" do
the_stuff_1.txt:pipeline/description_pipeline_spec.rb:  it "still allows 'p' elements" do
the_stuff_1.txt:pipeline/wiki_pipeline_spec.rb:          it "doesn't rewrite links" do
the_stuff_1.txt:pipeline/wiki_pipeline_spec.rb:            expect(output).to include('href="http://example.com/page"')
the_stuff_1.txt:pipeline/wiki_pipeline_spec.rb:              it "doesn't include a prohibited slug in a (.) relative link '#{link}'" do
the_stuff_1.txt:pipeline/wiki_pipeline_spec.rb:              it "doesn't include a prohibited slug in a (..) relative link '#{link}'" do
the_stuff_1.txt:pipeline/incident_management/timeline_event_pipeline_spec.rb:          '<p><a class="with-attachment-icon" href="/path/to/image.png" target="_blank" rel="noopener noreferrer">Name</a></p>'
the_stuff_1.txt:reference_redactor_spec.rb:               .fragment('<a class="gfm" href="https://www.gitlab.com" data-reference-type="issue">foo</a>')
the_stuff_1.txt:reference_redactor_spec.rb:               .fragment('<a class="gfm" href="https://www.gitlab.com" data-reference-type="issue">bar</a>')
the_stuff_1.txt:reference_redactor_spec.rb:        doc = Nokogiri::HTML.fragment("<a class='gfm' href='https://www.gitlab.com' data-reference-type='issue'>foo</a>")
the_stuff_1.txt:reference_redactor_spec.rb:          doc = Nokogiri::HTML.fragment("<a class='gfm' href='https://www.gitlab.com' data-reference-type='issue' data-original='#{original_content}'>bar</a>")
the_stuff_1.txt:reference_redactor_spec.rb:          html = "<a href='https://www.gitlab.com' data-link-reference='true' class='gfm' data-reference-type='issue' data-reference-type='issue' data-original='Marge'>Marge</a>"
the_stuff_1.txt:reference_redactor_spec.rb:          expect(doc.to_html).to eq('<a href="https://www.gitlab.com">Marge</a>')
the_stuff_1.txt:reference_redactor_spec.rb:          html = "<a href='https://www.gitlab.com' data-link-reference='true' class='gfm' data-reference-type='issue' data-reference-type='issue' data-original='Homer'>Marge</a>"
the_stuff_1.txt:reference_redactor_spec.rb:          expect(doc.to_html).to eq('<a href="https://www.gitlab.com">Homer</a>')
the_stuff_1.txt:reference_redactor_spec.rb:        doc = Nokogiri::HTML.fragment("<a class='gfm' href='https://www.gitlab.com' data-reference-type='issue' data-issue='#{issue.id}'>foo</a>")
the_stuff_1.txt:reference_redactor_spec.rb:        doc = Nokogiri::HTML.fragment("<a class='gfm' href='https://www.gitlab.com' data-reference-type='issue' data-external-issue='#{issue.id}' data-project='#{project.id}'>foo</a>")
the_stuff_1.txt:reference_redactor_spec.rb:        doc1_html = '<a class="gfm" data-reference-type="issue">foo</a>'
the_stuff_1.txt:reference_redactor_spec.rb:        doc2_html = '<a class="gfm" data-reference-type="issue">bar</a>'
the_stuff_1.txt:reference_redactor_spec.rb:        doc = Nokogiri::HTML.fragment('<a class="gfm" href="https://gitlab.com/path/to/project/-/wikis/foo" data-reference-type="wiki_page" data-gollum="true">foo</a>')
the_stuff_1.txt:reference_redactor_spec.rb:      doc = Nokogiri::HTML.fragment('<a href="foo">foo</a>')
the_stuff_1.txt:reference_redactor_spec.rb:      doc = Nokogiri::HTML.fragment('<a data-reference-type="issue"></a>')
the_stuff_1.txt:reference_redactor_spec.rb:      doc = Nokogiri::HTML.fragment('<a data-reference-type="some_invalid_type"></a>')
the_stuff_1.txt:filter/spaced_link_filter_spec.rb:      link = '[example](page slug "title")'
the_stuff_1.txt:filter/spaced_link_filter_spec.rb:      image = '![example](img test.jpg "title")'
the_stuff_1.txt:filter/spaced_link_filter_spec.rb:    it "ignores valid links contained inside '#{xpath}' element" do
the_stuff_1.txt:filter/escaped_char_filter_spec.rb:    markdown = Banzai::Filter::EscapedCharFilter::REFERENCE_CHARS.map { |char| "\\#{char}" }.join(' ')
the_stuff_1.txt:filter/escaped_char_filter_spec.rb:    markdown = %q(\"\'\*\+\,\-\.\/\:\;\<\=\>\?\[\]\`\|) + %q[\(\)\\\\]
the_stuff_1.txt:filter/escaped_char_filter_spec.rb:    expect(filter(doc).to_s).to eq '<p data-sourcepos="1:1-1:14">[link](&lt;foo&gt;)</p>'
the_stuff_1.txt:filter/table_of_contents_tag_filter_spec.rb:        expect(doc.to_html).to include('<ul class="section-nav">')
the_stuff_1.txt:filter/table_of_contents_tag_filter_spec.rb:        expect(doc.to_html).to include('<li><a href="#foo">Foo</a></li>')
the_stuff_1.txt:filter/table_of_contents_tag_filter_spec.rb:        expect(doc.to_html).to include('this <a href="_toc_" data-wikilink="true">_toc_</a>')
the_stuff_1.txt:filter/table_of_contents_tag_filter_spec.rb:      "#{'#' * level} #{text}\n"
the_stuff_1.txt:filter/table_of_contents_tag_filter_spec.rb:    let(:results) { result("[toc]\n\n#{header(1, 'Header 1')}#{header(2, 'Header 2')}") }
the_stuff_1.txt:filter/table_of_contents_tag_filter_spec.rb:      let(:content) { '&lt;img src="x" onerror="alert(42)"&gt;' }
the_stuff_1.txt:filter/markdown_filter_spec.rb:      expect(result).to start_with('<pre lang="html"><code>')
the_stuff_1.txt:filter/markdown_filter_spec.rb:      expect(result).to start_with('<pre lang=""><code>')
the_stuff_1.txt:filter/markdown_filter_spec.rb:      expect(result).to include('lang="ruby:red"')
the_stuff_1.txt:filter/markdown_filter_spec.rb:      expect(result).to include('data-meta="gem foo"')
the_stuff_1.txt:filter/markdown_filter_spec.rb:      expect(result).to eq '<p data-sourcepos="1:1-1:4">test</p>'
the_stuff_1.txt:filter/markdown_filter_spec.rb:      expect(result).to include('<section class="footnotes" data-footnotes>')
the_stuff_1.txt:filter/markdown_filter_spec.rb:      expected = '<p><a href="https://example.com">https://example.com</a></p>'
the_stuff_1.txt:filter/markdown_filter_spec.rb:      expected = '<p><a href="smb:///Volumes/shared/foo.pdf">smb:///Volumes/shared/foo.pdf</a></p>'
the_stuff_1.txt:filter/sanitization_filter_spec.rb:      exp = act = '<a rel="license" href="http://example.com">rel-license</a>'
the_stuff_1.txt:filter/kroki_filter_spec.rb:    expect(doc.to_s).to eq '<img src="http://localhost:8000/nomnoml/svg/eNqLDsgsSixJrUmtTHXOL80rsVLwzCupKUrMTNHQtC7IzMlJTE_V0KzhUlCITkpNLEqJ1dWNLkgsKsoviUUSs7KLTssvzVHIzS8tyYjligUAMhEd0g==" class="js-render-kroki" data-diagram="nomnoml" data-diagram-src="data:text/plain;base64,W1BpcmF0ZXxleWVDb3VudDogSW50fHJhaWQoKTtwaWxsYWdlKCl8CiAgW2JlYXJkXS0tW3BhcnJvdF0KICBbYmVhcmRdLTo+W2ZvdWwgbW91dGhdCl0=">'
the_stuff_1.txt:filter/kroki_filter_spec.rb:    expect(doc.to_s).to eq '<img src="http://localhost:8000/nomnoml/svg/eNqLDsgsSixJrUmtTHXOL80rsVLwzCupKUrMTNHQtC7IzMlJTE_V0KzhUlCITkpNLEqJ1dWNLkgsKsoviUUSs7KLTssvzVHIzS8tyYjligUAMhEd0g==" class="js-render-kroki" data-diagram="nomnoml" data-diagram-src="data:text/plain;base64,W1BpcmF0ZXxleWVDb3VudDogSW50fHJhaWQoKTtwaWxsYWdlKCl8CiAgW2JlYXJkXS0tW3BhcnJvdF0KICBbYmVhcmRdLTo+W2ZvdWwgbW91dGhdCl0=">'
the_stuff_1.txt:filter/kroki_filter_spec.rb:    expect(doc.to_s).to start_with '<img src="http://localhost:8000/nomnoml/svg/eNrtzCEOgDAMAEC_V0wysQ9AgkHh8M1EyQosGYw0nSDZ47EInlB74mBJjEKNHppKvaS38yWNMcXODXfKGXfqXDPWwkrIMXgPNzIXCR_rR9hKzfYsVY5gggFttdVWW2211Vbb__YFciTqeA==" hidden="" class="js-render-kroki" data-diagram="nomnoml" data-diagram-src="data:text/plain;base64,W1BpcmF0ZXxleWVDb3VudDog'
the_stuff_1.txt:filter/kroki_filter_spec.rb:    expect(doc.to_s).to eq '<img src="http://localhost:8000/nomnoml/svg/eNqLDsgsSixJrUmtTHXOL80rsVLwzCupKUrMTNHQtC7IzMlJTE_V0KzhUlCITkpNLEqJ1dWNLkgsKsoviUUSs7KLTssvzVHIzS8tyYjligUAMhEd0g==" class="js-render-kroki" data-diagram="nomnoml" data-diagram-src="data:text/plain;base64,W1BpcmF0ZXxleWVDb3VudDogSW50fHJhaWQoKTtwaWxsYWdlKCl8CiAgW2JlYXJkXS0tW3BhcnJvdF0KICBbYmVhcmRdLTo+W2ZvdWwgbW91dGhdCl0=">'
the_stuff_1.txt:filter/kroki_filter_spec.rb:    doc = filter(%(<a><pre data-canonical-lang='f/" onerror=alert(1) onload=alert(1) '><code data-canonical-lang="wavedrom">xss</code></pre></a>))
the_stuff_1.txt:filter/kroki_filter_spec.rb:    expect(doc.to_s).to eq %(<a><pre data-canonical-lang='f/" onerror=alert(1) onload=alert(1) '><code data-canonical-lang="wavedrom">xss</code></pre></a>)
the_stuff_1.txt:filter/kroki_filter_spec.rb:  it "strips at most one trailing newline from the diagram's source" do
the_stuff_1.txt:filter/kroki_filter_spec.rb:    output = '<img src="http://localhost:8000/graphviz/svg/eNpLyUwvSizIUKhWSFTQtVNIUqjl0tdX8EutKFHIycxLVchJTStRyMwrSc0ryczPS8zJqVRIyknMy9bjAgArOBNq" class="js-render-kroki" data-diagram="graphviz" data-diagram-src="data:text/plain;base64,ZGlncmFwaCB7IGEgLT4gYiB9Ci8vIE5leHQgbGluZSBsZWZ0IGludGVudGlvbmFsbHkgYmxhbmsuCg==">'
the_stuff_1.txt:filter/autolink_filter_spec.rb:  let(:quotes) { ['"', "'"] }
the_stuff_1.txt:filter/autolink_filter_spec.rb:      doc = filter("See #{link}", context.merge(link_attr: { class: 'custom' }))
the_stuff_1.txt:filter/autolink_filter_spec.rb:      complicated_link = "(#{link}(a'b[c'd]))'"
the_stuff_1.txt:filter/autolink_filter_spec.rb:      expected_complicated_link = %{(<a href="#{link}(a'b[c'd]))">#{link}(a'b[c'd]))</a>'}
the_stuff_1.txt:filter/autolink_filter_spec.rb:      expect(doc.at_css('a')['href']).to eq "http://about.gitlab.com/evil%E2%80%AE3pm.exe"
the_stuff_1.txt:filter/autolink_filter_spec.rb:      it "ignores valid links contained inside '#{elem}' element" do
the_stuff_1.txt:filter/autolink_filter_spec.rb:    doc = "http://#{'&' * 1_000_000}x"
the_stuff_1.txt:filter/autolink_filter_spec.rb:    doc = "#{'h' * 1_000_000}://example.com"
the_stuff_1.txt:filter/autolink_filter_spec.rb:    doc = "#{'h' * 1_000_000}://"
the_stuff_1.txt:filter/attributes_filter_spec.rb:        "#{image}{width=100}"           | '<img src="example.jpg" width="100">'
the_stuff_1.txt:filter/attributes_filter_spec.rb:        "#{image}{  width=100 }"        | '<img src="example.jpg" width="100">'
the_stuff_1.txt:filter/attributes_filter_spec.rb:        "#{image}{width=\"100\"}"       | '<img src="example.jpg" width="100">'
the_stuff_1.txt:filter/attributes_filter_spec.rb:        "#{image}{width=100 width=200}" | '<img src="example.jpg" width="200">'
the_stuff_1.txt:filter/attributes_filter_spec.rb:        "#{image}{.test_class width=100 style=\"width:400\"}"   | '<img src="example.jpg" width="100">'
the_stuff_1.txt:filter/attributes_filter_spec.rb:        "<img src=\"example.jpg\" class=\"lazy\" />{width=100}" | '<img src="example.jpg" class="lazy" width="100">'
the_stuff_1.txt:filter/attributes_filter_spec.rb:        "#{image} {width=100}"             | '<img src="example.jpg"> {width=100}'
the_stuff_1.txt:filter/attributes_filter_spec.rb:        "#{image}{width=100 height=200px}" | '<img src="example.jpg" width="100" height="200px">'
the_stuff_1.txt:filter/attributes_filter_spec.rb:        "#{image}{width=100}"              | '<img src="example.jpg" width="100">'
the_stuff_1.txt:filter/attributes_filter_spec.rb:        "#{image}{width=100px}"            | '<img src="example.jpg" width="100px">'
the_stuff_1.txt:filter/attributes_filter_spec.rb:        "#{image}{height=100%}"            | '<img src="example.jpg" height="100%">'
the_stuff_1.txt:filter/attributes_filter_spec.rb:        "#{image}{width=\"100%\"}"         | '<img src="example.jpg" width="100%">'
the_stuff_1.txt:filter/attributes_filter_spec.rb:        "#{image}{width=100cs}"           | '<img src="example.jpg">'
the_stuff_1.txt:filter/attributes_filter_spec.rb:        "#{image}{width=auto height=200}" | '<img src="example.jpg" height="200">'
the_stuff_1.txt:filter/attributes_filter_spec.rb:        "#{image}{width=10000}"           | '<img src="example.jpg">'
the_stuff_1.txt:filter/attributes_filter_spec.rb:        "#{image}{width=-200}"            | '<img src="example.jpg">'
the_stuff_1.txt:filter/html_entity_filter_spec.rb:  let(:unescaped) { 'foo <strike attr="foo">&&amp;&</strike>' }
the_stuff_1.txt:filter/absolute_link_filter_spec.rb:          expect(doc.at_css('a')['href']).to eq "#{fake_url}/foo"
the_stuff_1.txt:filter/absolute_link_filter_spec.rb:          doc = filter(link("#{fake_url}/foo", 'gfm'), only_path_context)
the_stuff_1.txt:filter/absolute_link_filter_spec.rb:          expect(doc.at_css('a')['href']).to eq "#{fake_url}/foo"
the_stuff_1.txt:filter/absolute_link_filter_spec.rb:            doc = filter(link("/gitlab/foo", 'gfm'), only_path_context)
the_stuff_1.txt:filter/absolute_link_filter_spec.rb:            expect(doc.at_css('a')['href']).to eq "#{fake_url}/gitlab/foo"
the_stuff_1.txt:filter/table_of_contents_tag_legacy_filter_spec.rb:      "#{'#' * level} #{text}\n"
the_stuff_1.txt:filter/table_of_contents_tag_legacy_filter_spec.rb:    let(:results) { result("[toc]\n\n#{header(1, 'Header 1')}#{header(2, 'Header 2')}") }
the_stuff_1.txt:filter/table_of_contents_tag_legacy_filter_spec.rb:      let(:content) { '&lt;img src="x" onerror="alert(42)"&gt;' }
the_stuff_1.txt:filter/emoji_filter_spec.rb:    doc = filter("''")
the_stuff_1.txt:filter/emoji_filter_spec.rb:    doc = filter("''")
the_stuff_1.txt:filter/emoji_filter_spec.rb:    doc = filter("':see_no_evil::hear_no_evil::speak_no_evil:'")
the_stuff_1.txt:filter/issuable_reference_expansion_filter_spec.rb:    link = create_link("#{closed_issue.to_reference} (comment 1)", issue: closed_issue.id, reference_type: 'issue')
the_stuff_1.txt:filter/issuable_reference_expansion_filter_spec.rb:    expect(doc.css('a').last.text).to eq("#{closed_issue.to_reference} (comment 1)")
the_stuff_1.txt:filter/issuable_reference_expansion_filter_spec.rb:    expect(doc.css('a').last.text).to eq("#{merge_request.to_reference} (diffs)")
the_stuff_1.txt:filter/issuable_reference_expansion_filter_spec.rb:    expect(doc.css('a').last.text).to eq("#{closed_issue.to_reference(other_project)} (closed)")
the_stuff_1.txt:filter/issuable_reference_expansion_filter_spec.rb:    expect(doc.css('a').last.text).to eq("#{closed_issue.to_reference(other_project)} (closed)")
the_stuff_1.txt:filter/issuable_reference_expansion_filter_spec.rb:      expect(doc.css('a').last.text).to eq("#{moved_issuable.to_reference} (moved)")
the_stuff_1.txt:filter/issuable_reference_expansion_filter_spec.rb:      expect(doc.css('a').last.text).to eq("#{issuable.to_reference} (closed)")
the_stuff_1.txt:filter/issuable_reference_expansion_filter_spec.rb:      expect(doc.css('a').last.text).to eq("#{issuable.title} (#{issuable.to_reference})")
the_stuff_1.txt:filter/issuable_reference_expansion_filter_spec.rb:      expect(doc.css('a').last.text).to eq("#{issuable.title.truncate(50)} (#{issuable.to_reference})")
the_stuff_1.txt:filter/issuable_reference_expansion_filter_spec.rb:      expect(doc.css('a').last.text).to eq("#{issuable.title} (#{issuable.to_reference} - closed)")
the_stuff_1.txt:filter/issuable_reference_expansion_filter_spec.rb:        expect(doc.css('a').last.text.scan(/\p{Emoji_Presentation}/)).to eq([""])
the_stuff_1.txt:filter/issuable_reference_expansion_filter_spec.rb:        expect(doc.css('a').last.text.scan(/\p{Emoji_Presentation}/)).to eq([""])
the_stuff_1.txt:filter/issuable_reference_expansion_filter_spec.rb:        expect(doc.css('a').last.text.scan(/\p{Emoji_Presentation}/)).to eq(["", ""])
the_stuff_1.txt:filter/issuable_reference_expansion_filter_spec.rb:      expect(doc.css('a').last.text).to eq("#{issuable.title} (#{issuable.to_reference})  Unassigned")
the_stuff_1.txt:filter/issuable_reference_expansion_filter_spec.rb:      expect(doc.css('a').last.text).to eq("#{merge_request.to_reference} (closed)")
the_stuff_1.txt:filter/issuable_reference_expansion_filter_spec.rb:      expect(doc.css('a').last.text).to eq("#{merge_request.to_reference} (merged)")
the_stuff_1.txt:filter/issuable_reference_expansion_filter_spec.rb:      expect(doc.css('a').last.text).to eq("#{merge_request.title} (#{merge_request.to_reference})")
the_stuff_1.txt:filter/issuable_reference_expansion_filter_spec.rb:      expect(doc.css('a').last.text).to eq("#{merge_request.title} (#{merge_request.to_reference})  Unassigned")
the_stuff_1.txt:filter/external_link_filter_spec.rb:    it 'adds rel="nofollow" to external links' do
the_stuff_1.txt:filter/external_link_filter_spec.rb:    it 'adds rel="noreferrer" to external links' do
the_stuff_1.txt:filter/external_link_filter_spec.rb:    it 'adds rel="noopener" to external links' do
the_stuff_1.txt:filter/external_link_filter_spec.rb:      doc = filter %q(<p><a href="don't crash on broken urls">Google</a></p>)
the_stuff_1.txt:filter/external_link_filter_spec.rb:      expected = %q(<p><a href="don't%20crash%20on%20broken%20urls" rel="nofollow noreferrer noopener" target="_blank">Google</a></p>)
the_stuff_1.txt:filter/external_link_filter_spec.rb:        expect(doc.to_html).to include('class="has-tooltip"')
the_stuff_1.txt:filter/external_link_filter_spec.rb:        expect(doc.to_html).to include('title="http://xn--example-6p25f.com/test.png"')
the_stuff_1.txt:filter/external_link_filter_spec.rb:        expect(doc.to_html).to include('class="has-tooltip"')
the_stuff_1.txt:filter/external_link_filter_spec.rb:        expect(doc.to_html).to include('title="http://xn--example-6p25f.com/"')
the_stuff_1.txt:filter/external_link_filter_spec.rb:        expect(doc.to_html).to include('class="has-tooltip"')
the_stuff_1.txt:filter/external_link_filter_spec.rb:        expect(doc.to_html).to include('title="http://example.com/evil%E2%80%AE3pm.exe"')
the_stuff_1.txt:filter/mermaid_filter_spec.rb:    doc = filter("<pre class='code highlight js-syntax-highlight mermaid' data-canonical-lang='mermaid' v-pre='true'><code>graph TD;\n  A--&gt;B;\n</code></pre>")
the_stuff_1.txt:filter/code_language_filter_spec.rb:      expect(result.to_html.delete("\n")).to eq('<pre><code>def fun end</code></pre>')
the_stuff_1.txt:filter/code_language_filter_spec.rb:      result = filter('<pre lang="ruby"><code>def fun end</code></pre>')
the_stuff_1.txt:filter/code_language_filter_spec.rb:        .to eq('<pre data-canonical-lang="ruby"><code>def fun end</code></pre>')
the_stuff_1.txt:filter/code_language_filter_spec.rb:      result = filter('<pre><code lang="ruby">def fun end</code></pre>')
the_stuff_1.txt:filter/code_language_filter_spec.rb:        .to eq('<pre data-canonical-lang="ruby"><code>def fun end</code></pre>')
the_stuff_1.txt:filter/references/alert_reference_filter_spec.rb:    it "ignores valid references contained inside '#{elem}' element" do
the_stuff_1.txt:filter/references/alert_reference_filter_spec.rb:      expect(doc.css('a').first.text).to eql("#{project2.path}^alert##{alert.iid}")
the_stuff_1.txt:filter/references/alert_reference_filter_spec.rb:      expect(doc.css('a').first.text).to eql("#{project2.path}^alert##{alert.iid}")
the_stuff_1.txt:filter/references/milestone_reference_filter_spec.rb:      it "ignores valid references contained inside '#{elem}' element" do
the_stuff_1.txt:filter/references/milestone_reference_filter_spec.rb:      doc = reference_filter('See %"&lt;html&gt;"')
the_stuff_1.txt:filter/references/milestone_reference_filter_spec.rb:        links = reference_filter("See #{milestone.to_reference(full: true)} and #{group_milestone.to_reference}", context).css('a')
the_stuff_1.txt:filter/references/label_reference_filter_spec.rb:    it "ignores valid references contained inside '#{elem}' element" do
the_stuff_1.txt:filter/references/label_reference_filter_spec.rb:    labels_markdown = Array.new(10, "Label #{reference}").join('\n')
the_stuff_1.txt:filter/references/label_reference_filter_spec.rb:      doc = reference_filter('See ~"&lt;html&gt;"')
the_stuff_1.txt:filter/references/label_reference_filter_spec.rb:      act = '(format nil "~0f" 3.0) ; 3.0'
the_stuff_1.txt:filter/references/label_reference_filter_spec.rb:      expect(result.css('a').first.text).to eq "#{label.name} in #{project2.full_name}"
the_stuff_1.txt:filter/references/label_reference_filter_spec.rb:      expect(result.css('a').first.text).to eq "#{label.name} in #{project2.name}"
the_stuff_1.txt:filter/references/label_reference_filter_spec.rb:      expect(result.css('a').first.text).to eq "#{label.name} in #{project2.name}"
the_stuff_1.txt:filter/references/label_reference_filter_spec.rb:      expect(result.css('a').first.text).to eq "#{label.name} in #{project.full_name}"
the_stuff_1.txt:filter/references/reference_filter_spec.rb:      document = Nokogiri::HTML.fragment('<a href="foo">foo</a>')
the_stuff_1.txt:filter/references/reference_filter_spec.rb:      document = Nokogiri::HTML.fragment('<a href="foo">foo</a>')
the_stuff_1.txt:filter/references/reference_filter_spec.rb:    it 'skips links with a "gfm" class' do
the_stuff_1.txt:filter/references/reference_filter_spec.rb:      document = Nokogiri::HTML.fragment('<a href="foo" class="gfm">foo</a>')
the_stuff_1.txt:filter/references/reference_filter_spec.rb:      document = Nokogiri::HTML.fragment('<span class="idiff">foo</span>')
the_stuff_1.txt:filter/references/reference_filter_spec.rb:      document = Nokogiri::HTML.fragment('<a href="foo">foo</a>')
the_stuff_1.txt:filter/references/reference_filter_spec.rb:    let(:document) { Nokogiri::HTML.fragment('<p data-sourcepos="1:1-1:18"></p>') }
the_stuff_1.txt:filter/references/reference_filter_spec.rb:    let(:node) { Nokogiri::HTML.fragment('<a href="link">end text</a>') }
the_stuff_1.txt:filter/references/reference_filter_spec.rb:    let(:document) { Nokogiri::HTML.fragment('<a href="foo">foo</a>') }
the_stuff_1.txt:filter/references/reference_filter_spec.rb:    let(:document) { Nokogiri::HTML.fragment('<a href="foo">foo</a>') }
the_stuff_1.txt:filter/references/reference_filter_spec.rb:    let_it_be(:document) { Nokogiri::HTML.fragment('<a href="foo">foo</a>') }
the_stuff_1.txt:filter/references/reference_filter_spec.rb:    let(:document) { Nokogiri::HTML.fragment('<a href="foo">foo</a>') }
the_stuff_1.txt:filter/references/design_reference_filter_spec.rb:          ['with <script>console.log("pwded")<%2Fscript>.png'],
the_stuff_1.txt:filter/references/design_reference_filter_spec.rb:          ['foo"bar.png'],
the_stuff_1.txt:filter/references/design_reference_filter_spec.rb:          ['A "very" good file.png']
the_stuff_1.txt:filter/references/commit_reference_filter_spec.rb:    it "ignores valid references contained inside '#{elem}' element" do
the_stuff_1.txt:filter/references/commit_reference_filter_spec.rb:          reference_filter("A big list of SHAs #{oids.join(', ')}", noteable: noteable)
the_stuff_1.txt:filter/references/commit_reference_filter_spec.rb:      expect(doc.css('a').first.text).to eql("#{project2.full_path}@#{commit.short_id}")
the_stuff_1.txt:filter/references/commit_reference_filter_spec.rb:      expect(doc.css('a').first.text).to eql("#{project2.path}@#{commit.short_id}")
the_stuff_1.txt:filter/references/commit_reference_filter_spec.rb:      expect(doc.css('a').first.text).to eql("#{project2.path}@#{commit.short_id}")
the_stuff_1.txt:filter/references/commit_reference_filter_spec.rb:      expect(doc.css('a').first.attr('href')).to eq "#{link}/builds"
the_stuff_1.txt:filter/references/commit_reference_filter_spec.rb:      expect(reference_filter(act, context).css('a').first.text).to eql("#{project.full_path}@#{commit.short_id}")
the_stuff_1.txt:filter/references/external_issue_reference_filter_spec.rb:      it "ignores valid references contained inside '#{elem}' element" do
the_stuff_1.txt:filter/references/external_issue_reference_filter_spec.rb:      issue_id = doc.css('a').first.attr("data-external-issue")
the_stuff_1.txt:filter/references/external_issue_reference_filter_spec.rb:      issue_id = doc.css('a').first.attr("data-external-issue")
the_stuff_1.txt:filter/references/external_issue_reference_filter_spec.rb:      expect(doc.css('a').first.attr('title')).to include("Issue in #{project.external_issue_tracker.title}")
the_stuff_1.txt:filter/references/external_issue_reference_filter_spec.rb:      issue_id = doc.css('a').first["data-external-issue"]
the_stuff_1.txt:filter/references/external_issue_reference_filter_spec.rb:      expect_any_instance_of(project.external_issue_tracker.class).to receive(:issue_url) { 'javascript:alert("foo");' }
the_stuff_1.txt:filter/references/external_issue_reference_filter_spec.rb:      expect_any_instance_of(project.external_issue_tracker.class).to receive(:issue_path) { 'javascript:alert("foo");' }
the_stuff_1.txt:filter/references/work_item_reference_filter_spec.rb:      doc = reference_filter("<a href='#{href}'></a>")
the_stuff_1.txt:filter/references/work_item_reference_filter_spec.rb:  #   'See <a href=\"http://localhost/cross-namespace/cross-project/-/work_items/1\">Reference</a>''
the_stuff_1.txt:filter/references/work_item_reference_filter_spec.rb:      expect(link.attr('href')).to eq("#{work_item_url}#note_123")
the_stuff_1.txt:filter/references/work_item_reference_filter_spec.rb:      expect(link.attr('href')).to eq("#{work_item_url}#note_123")
the_stuff_1.txt:filter/references/user_reference_filter_spec.rb:    it "ignores valid references contained inside '#{elem}' element" do
the_stuff_1.txt:filter/references/reference_cache_spec.rb:      expect(cache.full_project_path(nil, 'cool')).to eq "#{project.namespace.full_path}/cool"
the_stuff_1.txt:filter/references/issue_reference_filter_spec.rb:    it "ignores valid references contained inside '#{elem}' element" do
the_stuff_1.txt:filter/references/issue_reference_filter_spec.rb:      doc = reference_filter("<a href='#{href}'></a>")
the_stuff_1.txt:filter/references/issue_reference_filter_spec.rb:      expect(doc.css('a').first.text).to eql("#{project2.full_path}##{issue.iid}")
the_stuff_1.txt:filter/references/issue_reference_filter_spec.rb:      expect(doc.css('a').first.text).to eql("#{project2.path}##{issue.iid}")
the_stuff_1.txt:filter/references/issue_reference_filter_spec.rb:      expect(doc.css('a').first.text).to eql("#{project2.path}##{issue.iid}")
the_stuff_1.txt:filter/references/issue_reference_filter_spec.rb:      doc = reference_filter("Fixed (#{issue_url + '/'}.)")
the_stuff_1.txt:filter/references/issue_reference_filter_spec.rb:    it 'includes the word "designs" after the reference in the text content', :aggregate_failures do
the_stuff_1.txt:filter/references/issue_reference_filter_spec.rb:      expect(link.attr('href')).to eq(issue_url + "#note_123")
the_stuff_1.txt:filter/references/issue_reference_filter_spec.rb:      expect(link.attr('href')).to eq(issue_url + "#note_123")
the_stuff_1.txt:filter/references/issue_reference_filter_spec.rb:    it "doesn't yield invalid references" do
the_stuff_1.txt:filter/references/issue_reference_filter_spec.rb:    it "doesn't yield unsupported references" do
the_stuff_1.txt:filter/references/commit_range_reference_filter_spec.rb:    it "ignores valid references contained inside '#{elem}' element" do
the_stuff_1.txt:filter/references/commit_range_reference_filter_spec.rb:      expect(reference_filter("See #{reference}").css('a').first.text).to eq exp
the_stuff_1.txt:filter/references/commit_range_reference_filter_spec.rb:      expect(reference_filter("See #{reference2}").css('a').first.text).to eq exp
the_stuff_1.txt:filter/references/commit_range_reference_filter_spec.rb:      expect(doc.css('a').first.attr('title')).to eq ""
the_stuff_1.txt:filter/references/commit_range_reference_filter_spec.rb:      expect(reference_filter("See #{reference}", context).css('a').first.text).to eql(reference)
the_stuff_1.txt:filter/references/snippet_reference_filter_spec.rb:    it "ignores valid references contained inside '#{elem}' element" do
the_stuff_1.txt:filter/references/snippet_reference_filter_spec.rb:      expect(doc.css('a').first.text).to eql("#{project2.path}$#{snippet.id}")
the_stuff_1.txt:filter/references/snippet_reference_filter_spec.rb:      expect(doc.css('a').first.text).to eql("#{project2.path}$#{snippet.id}")
the_stuff_1.txt:filter/references/feature_flag_reference_filter_spec.rb:    it "ignores valid references contained inside '#{elem}' element" do
the_stuff_1.txt:filter/references/feature_flag_reference_filter_spec.rb:      expect(doc.css('a').first.text).to eql("[feature_flag:#{project2.path}/#{feature_flag.iid}]")
the_stuff_1.txt:filter/references/feature_flag_reference_filter_spec.rb:      expect(doc.css('a').first.text).to eql("[feature_flag:#{project2.path}/#{feature_flag.iid}]")
the_stuff_1.txt:filter/references/project_reference_filter_spec.rb:    it_behaves_like 'fails fast', "mailto:#{'a-' * 499_000}@aaaaaaaa..aaaaaaaa.example.com"
the_stuff_1.txt:filter/references/project_reference_filter_spec.rb:    it "ignores valid references contained inside '#{elem}' element" do
the_stuff_1.txt:filter/references/merge_request_reference_filter_spec.rb:    it "ignores valid references contained inside '#{elem}' element" do
the_stuff_1.txt:filter/references/merge_request_reference_filter_spec.rb:      expect(tag_el["class"]).not_to include('has-tooltip')
the_stuff_1.txt:filter/references/merge_request_reference_filter_spec.rb:      expect(doc.css('a').first.text).to eq("#{project2.path}!#{merge.iid}")
the_stuff_1.txt:filter/references/merge_request_reference_filter_spec.rb:      expect(doc.css('a').first.text).to eq("#{project2.path}!#{merge.iid}")
the_stuff_1.txt:filter/minimum_markdown_sanitization_filter_spec.rb:    act = list.map { |tag| "<#{tag}>#{tag}</#{tag}>" }.join(' ')
the_stuff_1.txt:filter/minimum_markdown_sanitization_filter_spec.rb:    act = list.map { |tag| "<#{tag}>#{tag}</#{tag}>" }.join(' ')
the_stuff_1.txt:filter/table_of_contents_legacy_filter_spec.rb:      expect(doc.css("h#{i} a").first.attr('id')).to eq "user-content-header-#{i}"
the_stuff_1.txt:filter/table_of_contents_legacy_filter_spec.rb:        expect(doc.css('h1 a').first.attr('href')).to eq "##{CGI.escape('')}"
the_stuff_1.txt:filter/table_of_contents_legacy_filter_spec.rb:        expect(doc.css('h1 a').first.attr('href')).to eq "##{'a' * 255}"
the_stuff_1.txt:filter/table_of_contents_legacy_filter_spec.rb:      let(:content) { '&lt;img src="x" onerror="alert(42)"&gt;' }
the_stuff_1.txt:filter/gollum_tags_filter_spec.rb:      expect(doc.to_html).to eq 'This is <a href="link" data-wikilink="true">a link</a>'
the_stuff_1.txt:filter/gollum_tags_filter_spec.rb:        expect(doc.to_html).to eq 'This is <a href="&lt;script&gt;alert(0)&lt;/script&gt;" data-wikilink="true">a link</a>'
the_stuff_1.txt:filter/gollum_tags_filter_spec.rb:        expect(doc.to_html).to eq 'This is <a href="link" data-wikilink="true">&lt;script&gt;alert(0)&lt;/script&gt;</a>'
the_stuff_1.txt:filter/gollum_tags_filter_spec.rb:        expect(doc.to_html).to eq 'This is &lt;script&gt;alert(0)&lt;/script&gt; <a href="link" data-wikilink="true">a link</a>'
the_stuff_1.txt:filter/gollum_tags_filter_spec.rb:      tag = '[[a|http:\'"injected=attribute&gt;&lt;img/src="0"onerror="alert(0)"&gt;https://gitlab.com/gitlab-org/gitlab/-/issues/1]]'
the_stuff_1.txt:filter/gollum_tags_filter_spec.rb:      expect(doc.at_css('a').to_html).to eq '<a href="http:\'%22injected=attribute&gt;&lt;img/src=%220%22onerror=%22alert(0)%22&gt;https://gitlab.com/gitlab-org/gitlab/-/issues/1" data-wikilink="true">a</a>'
the_stuff_1.txt:filter/gollum_tags_filter_spec.rb:      tag = '<i>[[a|\'"&gt;&lt;svg&gt;&lt;i/class=gl-show-field-errors&gt;&lt;input/title="&lt;script&gt;alert(0)&lt;/script&gt;"/&gt;&lt;/svg&gt;https://gitlab.com/gitlab-org/gitlab/-/issues/1]]'
the_stuff_1.txt:filter/gollum_tags_filter_spec.rb:      expect(doc.at_css('i a').to_html).to eq "<a href=\"'%22&gt;&lt;svg&gt;&lt;i/class=gl-show-field-errors&gt;&lt;input/title=%22&lt;script&gt;alert(0)&lt;/script&gt;%22/&gt;&lt;/svg&gt;https://gitlab.com/gitlab-org/gitlab/-/issues/1\" data-wikilink=\"true\">a</a>"
the_stuff_1.txt:filter/gollum_tags_filter_spec.rb:      text = "]#{'[[a' * 200000}[]"
the_stuff_1.txt:filter/broadcast_message_placeholders_filter_spec.rb:      let(:text) { '<a href="http://example.com?email={{email}}"">link</a>' }
the_stuff_1.txt:filter/broadcast_message_placeholders_filter_spec.rb:      let(:text) { '<a href="http://example.com?name=%7B%7Bname%7D%7D">link</a>' }
the_stuff_1.txt:filter/plantuml_filter_spec.rb:    output = '<img class="plantuml" src="http://localhost:8080/png/U9npoazIqBLJ24uiIbImKl18pSd91m0rkGMq" data-diagram="plantuml" data-diagram-src="data:text/plain;base64,Qm9iIC0+IFNhcmEgOiBIZWxsbw==">'
the_stuff_1.txt:filter/plantuml_filter_spec.rb:    output = '<img class="plantuml" src="http://localhost:8080/png/U9npoazIqBLJ24uiIbImKl18pSd91m0rkGMq" data-diagram="plantuml" data-diagram-src="data:text/plain;base64,Qm9iIC0+IFNhcmEgOiBIZWxsbw==">'
the_stuff_1.txt:filter/plantuml_filter_spec.rb:  it "strips at most one trailing newline from the diagram's source" do
the_stuff_1.txt:filter/plantuml_filter_spec.rb:    input = %(<pre data-canonical-lang="plantuml"><code>Bob -&gt; Sara : Hello\n' Next line left intentionally blank.\n\n</code></pre>)
the_stuff_1.txt:filter/plantuml_filter_spec.rb:    output = '<img class="plantuml" src="http://localhost:8080/png/U9npoazIqBLJ24uiIbImKl18pSd9vr9Ny4kjA578oSnBLSX9JIjHoCmhISqhoSpFIyp9gLH8oadCozRZ0W0Q7XD1" data-diagram="plantuml" data-diagram-src="data:text/plain;base64,Qm9iIC0+IFNhcmEgOiBIZWxsbwonIE5leHQgbGluZSBsZWZ0IGludGVudGlvbmFsbHkgYmxhbmsuCg==">'
the_stuff_1.txt:filter/ascii_doc_post_processing_filter_spec.rb:    result = filter('<pre data-math-style="inline">some code</pre><div data-math>and</div>').to_html
the_stuff_1.txt:filter/ascii_doc_post_processing_filter_spec.rb:    expect(result).to eq('<pre data-math-style="inline" class="js-render-math">some code</pre><div data-math>and</div>')
the_stuff_1.txt:filter/ascii_doc_post_processing_filter_spec.rb:    result = filter('<pre data-mermaid-style="display">some code</pre>').to_html
the_stuff_1.txt:filter/ascii_doc_post_processing_filter_spec.rb:    expect(result).to eq('<pre data-mermaid-style="display" class="js-render-mermaid">some code</pre>')
the_stuff_1.txt:filter/commit_trailers_filter_spec.rb:      exp = message = commit_html(Array.new(5) { 'Merged-By:' }.join("\n"))
the_stuff_1.txt:filter/commit_trailers_filter_spec.rb:      expect(doc.xpath('pre').text).to start_with("\n\n")
the_stuff_1.txt:filter/syntax_highlight_filter_spec.rb:      expect(result.to_html.delete("\n")).to eq('<div class="gl-relative markdown-code-block js-markdown-code"><pre class="code highlight js-syntax-highlight language-plaintext" v-pre="true"><code><span id="LC1" class="line" lang="plaintext">def fun end</span></code></pre><copy-code></copy-code><insert-code-snippet></insert-code-snippet></div>')
the_stuff_1.txt:filter/syntax_highlight_filter_spec.rb:      result = filter('<pre data-mermaid-style="display" data-canonical-lang="mermaid"><code class="js-render-mermaid">mermaid code</code></pre>')
the_stuff_1.txt:filter/syntax_highlight_filter_spec.rb:      expect(result.to_html.delete("\n")).to eq('<div class="gl-relative markdown-code-block js-markdown-code"><pre data-mermaid-style="display" data-canonical-lang="mermaid" class="code highlight js-syntax-highlight language-mermaid" v-pre="true"><code class="js-render-mermaid"><span id="LC1" class="line" lang="mermaid">mermaid code</span></code></pre><copy-code></copy-code><insert-code-snippet></insert-code-snippet></div>')
the_stuff_1.txt:filter/syntax_highlight_filter_spec.rb:    it "captures all text and doesn't fail trying to replace a node with no parent" do
the_stuff_1.txt:filter/syntax_highlight_filter_spec.rb:      expect(result.to_html.delete("\n")).to eq('<div><div class="gl-relative markdown-code-block js-markdown-code"><pre class="code highlight js-syntax-highlight language-plaintext" v-pre="true"><code><span id="LC1" class="line" lang="plaintext"></span><span id="LC2" class="line" lang="plaintext">something</span><span id="LC3" class="line" lang="plaintext">else</span></code></pre><copy-code></copy-code><insert-code-snippet></insert-code-snippet></div></div>')
the_stuff_1.txt:filter/syntax_highlight_filter_spec.rb:      result = filter('<pre data-canonical-lang="ruby"><code>def fun end</code></pre>')
the_stuff_1.txt:filter/syntax_highlight_filter_spec.rb:      expect(result.to_html.delete("\n")).to eq('<div class="gl-relative markdown-code-block js-markdown-code"><pre data-canonical-lang="ruby" class="code highlight js-syntax-highlight language-ruby" v-pre="true"><code><span id="LC1" class="line" lang="ruby"><span class="k">def</span> <span class="nf">fun</span> <span class="k">end</span></span></code></pre><copy-code></copy-code><insert-code-snippet></insert-code-snippet></div>')
the_stuff_1.txt:filter/syntax_highlight_filter_spec.rb:      result = filter('<pre data-canonical-lang="gnuplot"><code>This is a test</code></pre>')
the_stuff_1.txt:filter/syntax_highlight_filter_spec.rb:      expect(result.to_html.delete("\n")).to eq('<div class="gl-relative markdown-code-block js-markdown-code"><pre data-canonical-lang="gnuplot" class="code highlight js-syntax-highlight language-plaintext" v-pre="true"><code><span id="LC1" class="line" lang="plaintext">This is a test</span></code></pre><copy-code></copy-code><insert-code-snippet></insert-code-snippet></div>')
the_stuff_1.txt:filter/syntax_highlight_filter_spec.rb:      result = filter('<pre data-sourcepos="1:1-3:3" data-canonical-lang="plaintext"><code>This is a test</code></pre>')
the_stuff_1.txt:filter/syntax_highlight_filter_spec.rb:      expect(result.to_html.delete("\n")).to eq('<div class="gl-relative markdown-code-block js-markdown-code"><pre data-sourcepos="1:1-3:3" data-canonical-lang="plaintext" class="code highlight js-syntax-highlight language-plaintext" v-pre="true"><code><span id="LC1" class="line" lang="plaintext">This is a test</span></code></pre><copy-code></copy-code><insert-code-snippet></insert-code-snippet></div>')
the_stuff_1.txt:filter/syntax_highlight_filter_spec.rb:      result = filter('<pre data-sourcepos="&#34;%22 href=&#34;x&#34;></pre><base href=http://unsafe-website.com/><pre x=&#34;"><code></code></pre>')
the_stuff_1.txt:filter/syntax_highlight_filter_spec.rb:      expect(result.to_html.delete("\n")).to eq('<div class="gl-relative markdown-code-block js-markdown-code"><pre data-sourcepos=\'"%22 href="x"&gt;&lt;/pre&gt;&lt;base href=http://unsafe-website.com/&gt;&lt;pre x="\' class="code highlight js-syntax-highlight language-plaintext" v-pre="true"><code></code></pre><copy-code></copy-code><insert-code-snippet></insert-code-snippet></div>')
the_stuff_1.txt:filter/syntax_highlight_filter_spec.rb:      result = filter('<pre data-canonical-lang="ruby"><code>This is a test</code></pre>')
the_stuff_1.txt:filter/syntax_highlight_filter_spec.rb:      expect(result.to_html.delete("\n")).to eq('<div class="gl-relative markdown-code-block js-markdown-code"><pre data-canonical-lang="ruby" class="code highlight js-syntax-highlight" v-pre="true"><code><span id="LC1" class="line" lang="">This is a test</span></code></pre><copy-code></copy-code><insert-code-snippet></insert-code-snippet></div>')
the_stuff_1.txt:filter/syntax_highlight_filter_spec.rb:    let(:text) { '<pre data-canonical-lang="ruby"><code>def fun end</code></pre>' }
the_stuff_1.txt:filter/inline_diff_filter_spec.rb:    expect(filter(doc).to_html).to eq('START <span class="idiff left right deletion">something deleted</span> END')
the_stuff_1.txt:filter/inline_diff_filter_spec.rb:    expect(filter(doc).to_html).to eq('START <span class="idiff left right deletion">something deleted</span> END')
the_stuff_1.txt:filter/inline_diff_filter_spec.rb:    expect(filter(doc).to_html).to eq('START <span class="idiff left right addition">something added</span> END')
the_stuff_1.txt:filter/inline_diff_filter_spec.rb:    expect(filter(doc).to_html).to eq('START <span class="idiff left right addition">something added</span> END')
the_stuff_1.txt:filter/inline_diff_filter_spec.rb:    doc = "START {+&lt;script&gt;alert('I steal cookies')&lt;/script&gt;+} END"
the_stuff_1.txt:filter/inline_diff_filter_spec.rb:    expect(filter(doc).to_html).to eq("START <span class=\"idiff left right addition\">&lt;script&gt;alert('I steal cookies')&lt;/script&gt;</span> END")
the_stuff_1.txt:filter/json_table_filter_spec.rb:      <div><table data-table-fields='[{"key":"starts_at","label":"Date \\u003c \\u0026 \\u003e","sortable":true},{"key":"url","label":"URL"}]' data-table-filter="true" data-table-markdown="true">
the_stuff_1.txt:filter/json_table_filter_spec.rb:      <div><table data-table-fields='[{"key":"starts_at"},{"key":"url"}]' data-table-markdown="true">
the_stuff_1.txt:filter/wiki_link_filter_spec.rb:  it "doesn't rewrite absolute links" do
the_stuff_1.txt:filter/wiki_link_filter_spec.rb:    filtered_link = filter("<a href='http://example.com:8000/'>Link</a>", wiki: wiki).children[0]
the_stuff_1.txt:filter/wiki_link_filter_spec.rb:  it "doesn't rewrite links to project uploads" do
the_stuff_1.txt:filter/wiki_link_filter_spec.rb:    filtered_link = filter("<a href='/uploads/a.test'>Link</a>", wiki: wiki).children[0]
the_stuff_1.txt:filter/wiki_link_filter_spec.rb:      filtered_elements = filter("<a href='#{original_path}'><img src='#{original_path}'>example</img></a>", wiki: wiki)
the_stuff_1.txt:filter/wiki_link_filter_spec.rb:      filtered_link = filter("<a href='/uploads/a.test'>Link</a>", wiki: wiki).children[0]
the_stuff_1.txt:filter/wiki_link_filter_spec.rb:      filtered_link = filter("<a href='#{path}'>Link</a>", wiki: wiki, page_slug: 'home').children[0]
the_stuff_1.txt:filter/wiki_link_filter_spec.rb:      filtered_link = filter("<a href='#{path}'>Link</a>", wiki: wiki, page_slug: 'home').children[0]
the_stuff_1.txt:filter/wiki_link_filter_spec.rb:    context 'with an "a" html tag' do
the_stuff_1.txt:filter/wiki_link_filter_spec.rb:        filtered_link = filter("<a href='#{repository_upload_folder}/a.test'>Link</a>", wiki: wiki).children[0]
the_stuff_1.txt:filter/wiki_link_filter_spec.rb:        expect(filtered_link.attribute('href').value).to eq("#{wiki.wiki_base_path}/#{repository_upload_folder}/a.test")
the_stuff_1.txt:filter/wiki_link_filter_spec.rb:    context 'with "img" html tag' do
the_stuff_1.txt:filter/wiki_link_filter_spec.rb:      context 'inside an "a" html tag' do
the_stuff_1.txt:filter/wiki_link_filter_spec.rb:          filtered_elements = filter("<a href='#{repository_upload_folder}/a.jpg'><img src='#{repository_upload_folder}/a.jpg'>example</img></a>", wiki: wiki)
the_stuff_1.txt:filter/wiki_link_filter_spec.rb:      context 'outside an "a" html tag' do
the_stuff_1.txt:filter/wiki_link_filter_spec.rb:          filtered_link = filter("<img src='#{repository_upload_folder}/a.jpg'>example</img>", wiki: wiki).children[0]
the_stuff_1.txt:filter/wiki_link_filter_spec.rb:    context 'with "video" html tag' do
the_stuff_1.txt:filter/wiki_link_filter_spec.rb:        filtered_link = filter("<video src='#{repository_upload_folder}/a.mp4'></video>", wiki: wiki).children[0]
the_stuff_1.txt:filter/wiki_link_filter_spec.rb:        expect(filtered_link.attribute('src').value).to eq("#{wiki.wiki_base_path}/#{repository_upload_folder}/a.mp4")
the_stuff_1.txt:filter/wiki_link_filter_spec.rb:    context 'with "audio" html tag' do
the_stuff_1.txt:filter/wiki_link_filter_spec.rb:        filtered_link = filter("<audio src='#{repository_upload_folder}/a.wav'></audio>", wiki: wiki).children[0]
the_stuff_1.txt:filter/wiki_link_filter_spec.rb:        expect(filtered_link.attribute('src').value).to eq("#{wiki.wiki_base_path}/#{repository_upload_folder}/a.wav")
the_stuff_1.txt:filter/wiki_link_filter_spec.rb:      it "doesn't rewrite invalid invalid_links like #{invalid_link}" do
the_stuff_1.txt:filter/wiki_link_filter_spec.rb:        filtered_link = filter("<a href='#{invalid_link}'>Link</a>", wiki: wiki).children[0]
the_stuff_1.txt:filter/markdown_engines/cmark_spec.rb:    expect(engine.render('# hi')).to eq %(<h1 data-sourcepos="1:1-1:4">hi</h1>\n)
the_stuff_1.txt:filter/wiki_link_gollum_filter_spec.rb:      expect(doc.to_html).to eq '<p dir="auto">See <a href="unknown" data-wikilink="true">Something</a></p>'
the_stuff_1.txt:filter/wiki_link_gollum_filter_spec.rb:      expect(doc.at_css('a')['href']).to eq "#{wiki.wiki_base_path}/%3Cscript%3Ealert(0)%3C/script%3E"
the_stuff_1.txt:filter/wiki_link_gollum_filter_spec.rb:      expect(doc.at_css('a')['href']).to eq "#{wiki.wiki_base_path}/link"
the_stuff_1.txt:filter/wiki_link_gollum_filter_spec.rb:      expect(doc.to_html).to start_with '<p dir="auto">This is &lt;script&gt;alert(0)&lt;/script&gt; <a href'
the_stuff_1.txt:filter/wiki_link_gollum_filter_spec.rb:    tag = '[[a|http:\'"injected=attribute&gt;&lt;img/src="0"onerror="alert(0)"&gt;https://gitlab.com/gitlab-org/gitlab/-/issues/1]]'
the_stuff_1.txt:filter/wiki_link_gollum_filter_spec.rb:    tag = '<i>[[a|\'"&gt;&lt;svg&gt;&lt;i/class=gl-show-field-errors&gt;&lt;input/title="&lt;script&gt;alert(0)&lt;/script&gt;"/&gt;&lt;/svg&gt;https://gitlab.com/gitlab-org/gitlab/-/issues/1]]'
the_stuff_1.txt:filter/wiki_link_gollum_filter_spec.rb:    expect(doc.at_css('i a')['href']).to eq "#{wiki.wiki_base_path}/'%22%3E%3Csvg%3E%3Ci/class=gl-show-field-errors%3E%3Cinput/title=%22%3Cscript%3Ealert(0)%3C/script%3E%22/%3E%3C/svg%3Ehttps://gitlab.com/gitlab-org/gitlab/-/issues/1"
the_stuff_1.txt:filter/wiki_link_gollum_filter_spec.rb:    expect(doc.at_css('i a')['data-canonical-src']).to eq "'%22%3E%3Csvg%3E%3Ci/class=gl-show-field-errors%3E%3Cinput/title=%22%3Cscript%3Ealert(0)%3C/script%3E%22/%3E%3C/svg%3Ehttps://gitlab.com/gitlab-org/gitlab/-/issues/1"
the_stuff_1.txt:filter/wiki_link_gollum_filter_spec.rb:      '<a href="http://example.com" data-wikilink="true" rel="nofollow noreferrer noopener" target="_blank">http://example.com</a></p>'
the_stuff_1.txt:filter/include_filter_spec.rb:          .to eq "**Error including '[missing.md](missing.md)' : not found**\n"
the_stuff_1.txt:filter/include_filter_spec.rb:            .to eq "**Error including '[http://example.com](http://example.com)' : not readable**\n"
the_stuff_1.txt:filter/include_filter_spec.rb:            .to eq "**Error including '[http://example.com/foo bar](http://example.com/foo bar)' : not found**\n"
the_stuff_1.txt:filter/quick_action_filter_spec.rb:    described_class.call('<p data-sourcepos="1:1-2:3">/quick</p>', {}, result)
the_stuff_1.txt:filter/quick_action_filter_spec.rb:    described_class.call('<blockquote data-sourcepos="1:1-1:1">/quick</blockquote>', {}, result)
the_stuff_1.txt:filter/quick_action_filter_spec.rb:    described_class.call('<li data-sourcepos="1:1-1:1">/quick</li>', {}, result)
the_stuff_1.txt:filter/quick_action_filter_spec.rb:    described_class.call('<code data-sourcepos="1:1-1:1">/quick</code>', {}, result)
the_stuff_1.txt:filter/service_desk_upload_link_filter_spec.rb:          expect(doc.at_css('strong').text).to eq("#{filename_in_text} (#{file_name})")
the_stuff_1.txt:filter/service_desk_upload_link_filter_spec.rb:          expect(doc.at_css("strong:contains('#{file_name}')")).not_to be_nil
the_stuff_1.txt:filter/service_desk_upload_link_filter_spec.rb:          expect(doc.at_css("strong:contains('#{file_name_1}')")).not_to be_nil
the_stuff_1.txt:filter/service_desk_upload_link_filter_spec.rb:          expect(doc.at_css("strong:contains('#{file_name}')")).not_to be_nil
the_stuff_1.txt:filter/service_desk_upload_link_filter_spec.rb:          expect(doc.at_css("a:contains('#{file_name_1}')")).not_to be_nil
the_stuff_1.txt:filter/ascii_doc_sanitization_filter_spec.rb:    result = filter('<p>This paragraph has a footnote.<sup>[<a id="_footnoteref_1" href="#_footnotedef_1" title="View footnote.">1</a>]</sup></p>').to_html
the_stuff_1.txt:filter/ascii_doc_sanitization_filter_spec.rb:    expect(result).to eq('<p>This paragraph has a footnote.<sup>[<a id="_footnoteref_1" href="#_footnotedef_1" title="View footnote.">1</a>]</sup></p>')
the_stuff_1.txt:filter/ascii_doc_sanitization_filter_spec.rb:    result = filter('<div id="_footnotedef_1">
the_stuff_1.txt:filter/ascii_doc_sanitization_filter_spec.rb:<a href="#_footnoteref_1">1</a>. This is the text of the footnote.</div>').to_html
the_stuff_1.txt:filter/ascii_doc_sanitization_filter_spec.rb:    result = filter('<p><a id="user-content-cross-references"></a>A link to another location within an AsciiDoc document.</p>').to_html
the_stuff_1.txt:filter/ascii_doc_sanitization_filter_spec.rb:    result = filter('<p><a id="cross-references"></a>A link to another location within an AsciiDoc document.</p>').to_html
the_stuff_1.txt:filter/repository_link_filter_spec.rb:    expect { filter(link("files/test.md"), requested_path: '%FF') }.not_to raise_error
the_stuff_1.txt:filter/repository_link_filter_spec.rb:      expect(doc.at_css('img')['src']).to eq "/#{project_path}/-/raw/#{Addressable::URI.escape(ref)}/#{escaped}"
the_stuff_1.txt:filter/repository_link_filter_spec.rb:        expect(doc.at_css('a')['href']).to eq "/#{project_path}/-/blob/#{Addressable::URI.escape(ref)}/doc/api/users.md"
the_stuff_1.txt:filter/repository_link_filter_spec.rb:        expect(doc.at_css('a')['href']).to eq "/#{project_path}/-/blob/#{Addressable::URI.escape(ref)}/doc/api/users.md"
the_stuff_1.txt:filter/repository_link_filter_spec.rb:        expect(doc.at_css('a')['href']).to eq "/#{project_path}/-/blob/#{Addressable::URI.escape(ref)}/foo/bar/.gitkeep"
the_stuff_1.txt:filter/repository_link_filter_spec.rb:        expect(doc.at_css('a')['href']).to eq "/#{project_path}/-/blob/#{Addressable::URI.escape(ref)}/with%20space/README.md"
the_stuff_1.txt:filter/truncate_visible_filter_spec.rb:    let(:markdown) { "```ruby\ndef test\n  'hello world'\nend\n```" }
the_stuff_1.txt:filter/truncate_visible_filter_spec.rb:      '<code><span id="LC1" class="line" lang="ruby">' \
the_stuff_1.txt:filter/truncate_visible_filter_spec.rb:      '<span class="k">def</span> <span class="nf">test</span>...</span>'
the_stuff_1.txt:filter/truncate_visible_filter_spec.rb:    expect(doc.css('a')[0].text).to eq "@#{user.username}"
the_stuff_1.txt:filter/math_filter_spec.rb:        expected = result_template.gsub('<math>', '<code data-math-style="inline" class="code math js-render-math">')
the_stuff_1.txt:filter/math_filter_spec.rb:      let_it_be(:template_prefix_with_pre) { '<pre data-canonical-lang="math" data-math-style="display" class="js-render-math"><code>' }
the_stuff_1.txt:filter/math_filter_spec.rb:      let_it_be(:template_prefix_with_code) { '<code data-math-style="display" class="code math js-render-math">' }
the_stuff_1.txt:filter/math_filter_spec.rb:        template_suffix = "</code>#{'</pre>' if use_pre_tags}"
the_stuff_1.txt:filter/math_filter_spec.rb:        input = '<pre data-canonical-lang="math">something</pre>'
the_stuff_1.txt:filter/math_filter_spec.rb:      expect(doc.search('[data-math-style="inline"]').count).to eq(2)
the_stuff_1.txt:filter/math_filter_spec.rb:      expect(doc.search('[data-math-style="display"]').count).to eq(1)
the_stuff_1.txt:filter/image_link_filter_spec.rb:    expect(doc.at_css('a')['data-diagram']).to eq "plantuml"
the_stuff_1.txt:filter/image_link_filter_spec.rb:    expect(doc.at_css('a')['data-diagram-src']).to eq "data:text/plain;base64,Qm9iIC0+IFNhcmEgOiBIZWxsbw=="
the_stuff_1.txt:filter/upload_link_filter_spec.rb:      expect(doc.at_css('a')['href']).to eq("/-/project/#{project.id}/uploads/%ED%95%9C%EA%B8%80.png")
the_stuff_1.txt:filter/upload_link_filter_spec.rb:      expect(doc.at_css('img')['src']).to eq("/-/project/#{project.id}/uploads/%ED%95%9C%EA%B8%80.png")
the_stuff_1.txt:filter/upload_link_filter_spec.rb:      'whitespace'                   | "d18213acd3732630991986120e167e3d/Landscape_8.jpg\nand more"
the_stuff_1.txt:filter/upload_link_filter_spec.rb:      'null byte'                    | "%00"
reference_redactor_spec.rb:require 'spec_helper'
reference_redactor_spec.rb:  describe '#redact' do
reference_redactor_spec.rb:    context 'when reference not visible to user' do
reference_redactor_spec.rb:      it 'redacts an array of documents' do
reference_redactor_spec.rb:               .fragment('<a class="gfm" href="https://www.gitlab.com" data-reference-type="issue">foo</a>')
reference_redactor_spec.rb:               .fragment('<a class="gfm" href="https://www.gitlab.com" data-reference-type="issue">bar</a>')
reference_redactor_spec.rb:        expect(doc1.to_html).to eq('foo')
reference_redactor_spec.rb:        expect(doc2.to_html).to eq('bar')
reference_redactor_spec.rb:      it 'replaces redacted reference with inner HTML' do
reference_redactor_spec.rb:        doc = Nokogiri::HTML.fragment("<a class='gfm' href='https://www.gitlab.com' data-reference-type='issue'>foo</a>")
reference_redactor_spec.rb:        expect(doc.to_html).to eq('foo')
reference_redactor_spec.rb:      context 'when data-original attribute provided' do
reference_redactor_spec.rb:        let(:original_content) { '&lt;script&gt;alert(1);&lt;/script&gt;' }
reference_redactor_spec.rb:        it 'replaces redacted reference with original content' do
reference_redactor_spec.rb:          doc = Nokogiri::HTML.fragment("<a class='gfm' href='https://www.gitlab.com' data-reference-type='issue' data-original='#{original_content}'>bar</a>")
reference_redactor_spec.rb:        it 'does not replace redacted reference with original content if href is given' do
reference_redactor_spec.rb:          html = "<a href='https://www.gitlab.com' data-link-reference='true' class='gfm' data-reference-type='issue' data-reference-type='issue' data-original='Marge'>Marge</a>"
reference_redactor_spec.rb:          expect(doc.to_html).to eq('<a href="https://www.gitlab.com">Marge</a>')
reference_redactor_spec.rb:        it 'uses the original content as the link content if given' do
reference_redactor_spec.rb:          html = "<a href='https://www.gitlab.com' data-link-reference='true' class='gfm' data-reference-type='issue' data-reference-type='issue' data-original='Homer'>Marge</a>"
reference_redactor_spec.rb:          expect(doc.to_html).to eq('<a href="https://www.gitlab.com">Homer</a>')
reference_redactor_spec.rb:    context 'when project is in pending delete' do
reference_redactor_spec.rb:      it 'redacts an issue attached' do
reference_redactor_spec.rb:        doc = Nokogiri::HTML.fragment("<a class='gfm' href='https://www.gitlab.com' data-reference-type='issue' data-issue='#{issue.id}'>foo</a>")
reference_redactor_spec.rb:        expect(doc.to_html).to eq('foo')
reference_redactor_spec.rb:      it 'redacts an external issue' do
reference_redactor_spec.rb:        doc = Nokogiri::HTML.fragment("<a class='gfm' href='https://www.gitlab.com' data-reference-type='issue' data-external-issue='#{issue.id}' data-project='#{project.id}'>foo</a>")
reference_redactor_spec.rb:        expect(doc.to_html).to eq('foo')
reference_redactor_spec.rb:    context 'when reference visible to user' do
reference_redactor_spec.rb:      it 'does not redact an array of documents' do
reference_redactor_spec.rb:        doc1_html = '<a class="gfm" data-reference-type="issue">foo</a>'
reference_redactor_spec.rb:        doc2_html = '<a class="gfm" data-reference-type="issue">bar</a>'
reference_redactor_spec.rb:    context 'when reference is a gollum wiki page link that is not visible to user' do
reference_redactor_spec.rb:      it 'replaces redacted reference with original content' do
reference_redactor_spec.rb:        doc = Nokogiri::HTML.fragment('<a class="gfm" href="https://gitlab.com/path/to/project/-/wikis/foo" data-reference-type="wiki_page" data-gollum="true">foo</a>')
reference_redactor_spec.rb:        expect(doc.to_html).to eq('foo')
reference_redactor_spec.rb:  context 'when the user cannot read cross project' do
reference_redactor_spec.rb:        '',
reference_redactor_spec.rb:        class: 'gfm has-tooltip',
reference_redactor_spec.rb:    it 'skips links to issues within the same project' do
reference_redactor_spec.rb:      result = doc.css('a').last
reference_redactor_spec.rb:      expect(result['class']).to include('has-tooltip')
reference_redactor_spec.rb:      expect(result['title']).to eq(issue.title)
reference_redactor_spec.rb:    it 'removes info from a cross project reference' do
reference_redactor_spec.rb:      result = doc.css('a').last
reference_redactor_spec.rb:      expect(result['class']).not_to include('has-tooltip')
reference_redactor_spec.rb:      expect(result['title']).to be_empty
reference_redactor_spec.rb:  describe '#redact_nodes' do
reference_redactor_spec.rb:    it 'redacts an Array of nodes' do
reference_redactor_spec.rb:      doc = Nokogiri::HTML.fragment('<a href="foo">foo</a>')
reference_redactor_spec.rb:      expect(doc.to_html).to eq('foo')
reference_redactor_spec.rb:  describe '#nodes_visible_to_user' do
reference_redactor_spec.rb:    it 'returns a Set containing the visible nodes' do
reference_redactor_spec.rb:      doc = Nokogiri::HTML.fragment('<a data-reference-type="issue"></a>')
reference_redactor_spec.rb:    it 'handles invalid references gracefully' do
reference_redactor_spec.rb:      doc = Nokogiri::HTML.fragment('<a data-reference-type="some_invalid_type"></a>')
commit_renderer_spec.rb:require 'spec_helper'
commit_renderer_spec.rb:  describe '.render', :clean_gitlab_redis_cache do
commit_renderer_spec.rb:    it 'renders a commit description and title' do
filter_spec.rb:require 'fast_spec_helper'
filter_spec.rb:  describe '#filter_item_limit_exceeded?' do
filter_spec.rb:    it 'properly detects limits' do
dict1.txt:"Merge branch 'branch-merged' into 'master'"
dict1.txt:"Merge branch 'branch-merged' into 'master'"
dict1.txt:"<a href='' data-issue='#{issue.id}' data-reference-type='issue' class='gfm'>text</a>"
dict1.txt:"<a href='' data-work-item='#{work_item.id}' data-reference-type='work_item' class='gfm'>text</a>"
dict1.txt:"<a href='' data-work-item='#{group_work_item.id}' data-reference-type='work_item' class='gfm'>text</a>"
dict1.txt:"<a href='' data-merge-request='#{merge_request.id}' data-reference-type='merge_request' class='gfm'>text</a>"
dict1.txt:"<a data-foo='#{user.id}'></a>"
dict1.txt:"<a data-foo='1'></a><a data-foo='2'></a>"
dict1.txt:"x \\#\n\n#{'mliteralcmliteral-' * 450000}mliteral"
dict1.txt:"<a alt='\"
dict1.txt:"'![a ' * 3"
dict1.txt:"':y: ' * 190000"
dict1.txt:"'<img>' * 100000"
dict1.txt:"when using '#{input}' as input"
dict1.txt:"removes '#{elem}' elements"
dict1.txt:"still allows '#{elem}' elements"
dict1.txt:"still allows 'p' elements"
dict1.txt:"doesn't rewrite links"
dict1.txt:"doesn't include a prohibited slug in a (.) relative link '#{link}'"
dict1.txt:"doesn't include a prohibited slug in a (..) relative link '#{link}'"
dict1.txt:"<a class='gfm' href='https://www.gitlab.com' data-reference-type='issue'>foo</a>"
dict1.txt:"<a class='gfm' href='https://www.gitlab.com' data-reference-type='issue' data-original='#{original_content}'>bar</a>"
dict1.txt:"<a href='https://www.gitlab.com' data-link-reference='true' class='gfm' data-reference-type='issue' data-reference-type='issue' data-original='Marge'>Marge</a>"
dict1.txt:"<a href='https://www.gitlab.com' data-link-reference='true' class='gfm' data-reference-type='issue' data-reference-type='issue' data-original='Homer'>Marge</a>"
dict1.txt:"<a class='gfm' href='https://www.gitlab.com' data-reference-type='issue' data-issue='#{issue.id}'>foo</a>"
dict1.txt:"<a class='gfm' href='https://www.gitlab.com' data-reference-type='issue' data-external-issue='#{issue.id}' data-project='#{project.id}'>foo</a>"
dict1.txt:"ignores valid links contained inside '#{xpath}' element"
dict1.txt:"#{'#' * level} #{text}\n"
dict1.txt:"[toc]\n\n#{header(1, 'Header 1')}#{header(2, 'Header 2')}"
dict1.txt:" onerror=alert(1) onload=alert(1) '><code data-canonical-lang="
dict1.txt:" onerror=alert(1) onload=alert(1) '><code data-canonical-lang="
dict1.txt:"strips at most one trailing newline from the diagram's source"
dict1.txt:"', "
dict1.txt:"(#{link}(a'b[c'd]))'"
dict1.txt:"#{link}(a'b[c'd]))"
dict1.txt:"ignores valid links contained inside '#{elem}' element"
dict1.txt:"http://#{'&' * 1_000_000}x"
dict1.txt:"#{'h' * 1_000_000}://example.com"
dict1.txt:"#{'h' * 1_000_000}://"
dict1.txt:"#{'#' * level} #{text}\n"
dict1.txt:"[toc]\n\n#{header(1, 'Header 1')}#{header(2, 'Header 2')}"
dict1.txt:"''"
dict1.txt:"''"
dict1.txt:"':see_no_evil::hear_no_evil::speak_no_evil:'"
dict1.txt:"don't crash on broken urls"
dict1.txt:"don't%20crash%20on%20broken%20urls"
dict1.txt:"<pre class='code highlight js-syntax-highlight mermaid' data-canonical-lang='mermaid' v-pre='true'><code>graph TD;\n  A--&gt;B;\n</code></pre>"
dict1.txt:"ignores valid references contained inside '#{elem}' element"
dict1.txt:"ignores valid references contained inside '#{elem}' element"
dict1.txt:"ignores valid references contained inside '#{elem}' element"
dict1.txt:"ignores valid references contained inside '#{elem}' element"
dict1.txt:"A big list of SHAs #{oids.join(', ')}"
dict1.txt:"ignores valid references contained inside '#{elem}' element"
dict1.txt:"<a href='#{href}'></a>"
dict1.txt:"ignores valid references contained inside '#{elem}' element"
dict1.txt:"ignores valid references contained inside '#{elem}' element"
dict1.txt:"<a href='#{href}'></a>"
dict1.txt:"Fixed (#{issue_url + '/'}.)"
dict1.txt:"doesn't yield invalid references"
dict1.txt:"doesn't yield unsupported references"
dict1.txt:"ignores valid references contained inside '#{elem}' element"
dict1.txt:"ignores valid references contained inside '#{elem}' element"
dict1.txt:"ignores valid references contained inside '#{elem}' element"
dict1.txt:"mailto:#{'a-' * 499_000}@aaaaaaaa..aaaaaaaa.example.com"
dict1.txt:"ignores valid references contained inside '#{elem}' element"
dict1.txt:"ignores valid references contained inside '#{elem}' element"
dict1.txt:"##{CGI.escape('')}"
dict1.txt:"##{'a' * 255}"
dict1.txt:"http:\'%22injected=attribute&gt;&lt;img/src=%220%22onerror=%22alert(0)%22&gt;https://gitlab.com/gitlab-org/gitlab/-/issues/1"
dict1.txt:"]#{'[[a' * 200000}[]"
dict1.txt:"strips at most one trailing newline from the diagram's source"
dict1.txt:"captures all text and doesn't fail trying to replace a node with no parent"
dict1.txt:"START {+&lt;script&gt;alert('I steal cookies')&lt;/script&gt;+} END"
dict1.txt:">&lt;script&gt;alert('I steal cookies')&lt;/script&gt;</span> END"
dict1.txt:"doesn't rewrite absolute links"
dict1.txt:"<a href='http://example.com:8000/'>Link</a>"
dict1.txt:"doesn't rewrite links to project uploads"
dict1.txt:"<a href='/uploads/a.test'>Link</a>"
dict1.txt:"<a href='#{original_path}'><img src='#{original_path}'>example</img></a>"
dict1.txt:"<a href='/uploads/a.test'>Link</a>"
dict1.txt:"<a href='#{path}'>Link</a>"
dict1.txt:"<a href='#{path}'>Link</a>"
dict1.txt:"<a href='#{repository_upload_folder}/a.test'>Link</a>"
dict1.txt:"<a href='#{repository_upload_folder}/a.jpg'><img src='#{repository_upload_folder}/a.jpg'>example</img></a>"
dict1.txt:"<img src='#{repository_upload_folder}/a.jpg'>example</img>"
dict1.txt:"<video src='#{repository_upload_folder}/a.mp4'></video>"
dict1.txt:"<audio src='#{repository_upload_folder}/a.wav'></audio>"
dict1.txt:"doesn't rewrite invalid invalid_links like #{invalid_link}"
dict1.txt:"<a href='#{invalid_link}'>Link</a>"
dict1.txt:"#{wiki.wiki_base_path}/'%22%3E%3Csvg%3E%3Ci/class=gl-show-field-errors%3E%3Cinput/title=%22%3Cscript%3Ealert(0)%3C/script%3E%22/%3E%3C/svg%3Ehttps://gitlab.com/gitlab-org/gitlab/-/issues/1"
dict1.txt:"'%22%3E%3Csvg%3E%3Ci/class=gl-show-field-errors%3E%3Cinput/title=%22%3Cscript%3Ealert(0)%3C/script%3E%22/%3E%3C/svg%3Ehttps://gitlab.com/gitlab-org/gitlab/-/issues/1"
dict1.txt:"**Error including '[missing.md](missing.md)' : not found**\n"
dict1.txt:"**Error including '[http://example.com](http://example.com)' : not readable**\n"
dict1.txt:"**Error including '[http://example.com/foo bar](http://example.com/foo bar)' : not found**\n"
dict1.txt:"strong:contains('#{file_name}')"
dict1.txt:"strong:contains('#{file_name_1}')"
dict1.txt:"strong:contains('#{file_name}')"
dict1.txt:"a:contains('#{file_name_1}')"
dict1.txt:"```ruby\ndef test\n  'hello world'\nend\n```"
dict1.txt:"</code>#{'</pre>' if use_pre_tags}"
filter/spaced_link_filter_spec.rb:require 'spec_helper'
filter/spaced_link_filter_spec.rb:  let(:link)  { '[example](page slug)' }
filter/spaced_link_filter_spec.rb:  let(:image) { '![example](img test.jpg)' }
filter/spaced_link_filter_spec.rb:  context 'when a link is detected' do
filter/spaced_link_filter_spec.rb:    it 'converts slug with spaces to a link' do
filter/spaced_link_filter_spec.rb:      expect(doc.at_css('a').text).to eq 'example'
filter/spaced_link_filter_spec.rb:      expect(doc.at_css('a')['href']).to eq 'page%20slug'
filter/spaced_link_filter_spec.rb:      expect(doc.at_css('a')['title']).to be_nil
filter/spaced_link_filter_spec.rb:      expect(doc.at_css('p')).to be_nil
filter/spaced_link_filter_spec.rb:    it 'converts slug with spaces and a title to a link' do
filter/spaced_link_filter_spec.rb:      link = '[example](page slug "title")'
filter/spaced_link_filter_spec.rb:      expect(doc.at_css('a').text).to eq 'example'
filter/spaced_link_filter_spec.rb:      expect(doc.at_css('a')['href']).to eq 'page%20slug'
filter/spaced_link_filter_spec.rb:      expect(doc.at_css('a')['title']).to eq 'title'
filter/spaced_link_filter_spec.rb:      expect(doc.at_css('p')).to be_nil
filter/spaced_link_filter_spec.rb:    it 'does nothing with empty text' do
filter/spaced_link_filter_spec.rb:      link = '[](page slug)'
filter/spaced_link_filter_spec.rb:      expect(doc.at_css('a')).to be_nil
filter/spaced_link_filter_spec.rb:    it 'does nothing with an empty slug' do
filter/spaced_link_filter_spec.rb:      link = '[example]()'
filter/spaced_link_filter_spec.rb:      expect(doc.at_css('a')).to be_nil
filter/spaced_link_filter_spec.rb:  context 'when an image is detected' do
filter/spaced_link_filter_spec.rb:    it 'converts slug with spaces to an iamge' do
filter/spaced_link_filter_spec.rb:      expect(doc.at_css('img')['src']).to eq 'img%20test.jpg'
filter/spaced_link_filter_spec.rb:      expect(doc.at_css('img')['alt']).to eq 'example'
filter/spaced_link_filter_spec.rb:      expect(doc.at_css('p')).to be_nil
filter/spaced_link_filter_spec.rb:    it 'converts slug with spaces and a title to an image' do
filter/spaced_link_filter_spec.rb:      image = '![example](img test.jpg "title")'
filter/spaced_link_filter_spec.rb:      expect(doc.at_css('img')['src']).to eq 'img%20test.jpg'
filter/spaced_link_filter_spec.rb:      expect(doc.at_css('img')['alt']).to eq 'example'
filter/spaced_link_filter_spec.rb:      expect(doc.at_css('img')['title']).to eq 'title'
filter/spaced_link_filter_spec.rb:      expect(doc.at_css('p')).to be_nil
filter/spaced_link_filter_spec.rb:  it 'does not process malicious input' do
filter/spaced_link_filter_spec.rb:      doc = filter('[ (](' * 60_000)
filter/spaced_link_filter_spec.rb:      found_links = doc.css('a')
filter/spaced_link_filter_spec.rb:  it 'converts multiple URLs' do
filter/spaced_link_filter_spec.rb:    link1 = '[first](slug one)'
filter/spaced_link_filter_spec.rb:    link2 = '[second](http://example.com/slug two)'
filter/spaced_link_filter_spec.rb:    found_links = doc.css('a')
filter/spaced_link_filter_spec.rb:    expect(found_links[0].text).to eq 'first'
filter/spaced_link_filter_spec.rb:    expect(found_links[0]['href']).to eq 'slug%20one'
filter/spaced_link_filter_spec.rb:    expect(found_links[1].text).to eq 'second'
filter/spaced_link_filter_spec.rb:    expect(found_links[1]['href']).to eq 'http://example.com/slug%20two'
filter/spaced_link_filter_spec.rb:    found_images = doc.css('img')
filter/spaced_link_filter_spec.rb:    expect(found_images[0]['src']).to eq 'img%20test.jpg'
filter/spaced_link_filter_spec.rb:    expect(found_images[0]['alt']).to eq 'example'
filter/spaced_link_filter_spec.rb:    it "ignores valid links contained inside '#{xpath}' element" do
filter/spaced_link_filter_spec.rb:  it_behaves_like 'pipeline timing check'
filter/escaped_char_filter_spec.rb:require 'spec_helper'
filter/escaped_char_filter_spec.rb:  it 'ensure we handle all the GitLab reference characters', :eager_load do
filter/escaped_char_filter_spec.rb:  it 'leaves reference chars untouched' do
filter/escaped_char_filter_spec.rb:    markdown = Banzai::Filter::EscapedCharFilter::REFERENCE_CHARS.map { |char| "\\#{char}" }.join(' ')
filter/escaped_char_filter_spec.rb:      char = item == '&' ? '&amp;' : item
filter/escaped_char_filter_spec.rb:  it 'removes spans for non-reference punctuation' do
filter/escaped_char_filter_spec.rb:    markdown = %q(\"\'\*\+\,\-\.\/\:\;\<\=\>\?\[\]\`\|) + %q[\(\)\\\\]
filter/escaped_char_filter_spec.rb:    expect(doc.to_s).to include('<span data-escaped-char')
filter/escaped_char_filter_spec.rb:    expect(filter(doc).to_s).not_to include('<span data-escaped-char')
filter/escaped_char_filter_spec.rb:  it 'keeps html escaped text' do
filter/escaped_char_filter_spec.rb:    markdown = '[link](<foo\>)'
filter/escaped_char_filter_spec.rb:    expect(filter(doc).to_s).to eq '<p data-sourcepos="1:1-1:14">[link](&lt;foo&gt;)</p>'
filter/table_of_contents_tag_filter_spec.rb:require 'spec_helper'
filter/table_of_contents_tag_filter_spec.rb:  context 'table of contents' do
filter/table_of_contents_tag_filter_spec.rb:    shared_examples 'table of contents tag' do
filter/table_of_contents_tag_filter_spec.rb:      it 'replaces toc tag with ToC result' do
filter/table_of_contents_tag_filter_spec.rb:        expect(doc.to_html).to include('<ul class="section-nav">')
filter/table_of_contents_tag_filter_spec.rb:        expect(doc.to_html).to include('<li><a href="#foo">Foo</a></li>')
filter/table_of_contents_tag_filter_spec.rb:    shared_examples 'table of contents tag not recognized' do
filter/table_of_contents_tag_filter_spec.rb:      it 'ignores toc tag when part of a sentence' do
filter/table_of_contents_tag_filter_spec.rb:        expect(doc.to_html).to include('toc')
filter/table_of_contents_tag_filter_spec.rb:        expect(doc.to_html).to include('<h1')
filter/table_of_contents_tag_filter_spec.rb:      it 'ignores toc tag in inline code' do
filter/table_of_contents_tag_filter_spec.rb:        expect(doc.to_html).to include('<h1')
filter/table_of_contents_tag_filter_spec.rb:      it 'ignores toc tag when at end of paragraph' do
filter/table_of_contents_tag_filter_spec.rb:        expect(doc.to_html).to include('toc')
filter/table_of_contents_tag_filter_spec.rb:        expect(doc.to_html).to include('<h1')
filter/table_of_contents_tag_filter_spec.rb:      it 'ignores toc tag when at start of paragraph' do
filter/table_of_contents_tag_filter_spec.rb:        expect(doc.to_html).to include('toc')
filter/table_of_contents_tag_filter_spec.rb:        expect(doc.to_html).to include('<h1')
filter/table_of_contents_tag_filter_spec.rb:      it 'ignores toc tag when there is another node directly in front' do
filter/table_of_contents_tag_filter_spec.rb:        expect(doc.to_html).to include('toc')
filter/table_of_contents_tag_filter_spec.rb:        expect(doc.to_html).to include('<h1')
filter/table_of_contents_tag_filter_spec.rb:    context '[[_TOC_]] as tag' do
filter/table_of_contents_tag_filter_spec.rb:      it_behaves_like 'table of contents tag' do
filter/table_of_contents_tag_filter_spec.rb:      it_behaves_like 'table of contents tag' do
filter/table_of_contents_tag_filter_spec.rb:      it_behaves_like 'table of contents tag not recognized' do
filter/table_of_contents_tag_filter_spec.rb:        let(:toc_tag) { '[[_toc_]]' }
filter/table_of_contents_tag_filter_spec.rb:      it 'does not recognize the toc' do
filter/table_of_contents_tag_filter_spec.rb:        expect(doc.to_html).to include('this <a href="_toc_" data-wikilink="true">_toc_</a>')
filter/table_of_contents_tag_filter_spec.rb:        expect(doc.to_html).to include('Foo</h1>')
filter/table_of_contents_tag_filter_spec.rb:    context '[TOC] as tag' do
filter/table_of_contents_tag_filter_spec.rb:      it_behaves_like 'table of contents tag' do
filter/table_of_contents_tag_filter_spec.rb:      it_behaves_like 'table of contents tag' do
filter/table_of_contents_tag_filter_spec.rb:      it_behaves_like 'table of contents tag not recognized' do
filter/table_of_contents_tag_filter_spec.rb:        let(:toc_tag) { '[toc]' }
filter/table_of_contents_tag_filter_spec.rb:  describe 'structure of a toc' do
filter/table_of_contents_tag_filter_spec.rb:      "#{'#' * level} #{text}\n"
filter/table_of_contents_tag_filter_spec.rb:    let(:results) { result("[toc]\n\n#{header(1, 'Header 1')}#{header(2, 'Header 2')}") }
filter/table_of_contents_tag_filter_spec.rb:    it 'is contained within a `ul` element' do
filter/table_of_contents_tag_filter_spec.rb:      expect(doc.children.first.name).to eq 'ul'
filter/table_of_contents_tag_filter_spec.rb:      expect(doc.children.first.attr('class')).to eq 'section-nav'
filter/table_of_contents_tag_filter_spec.rb:    it 'contains an `li` element for each header' do
filter/table_of_contents_tag_filter_spec.rb:      expect(doc.css('li').length).to eq 2
filter/table_of_contents_tag_filter_spec.rb:      links = doc.css('li a')
filter/table_of_contents_tag_filter_spec.rb:      expect(links.first.attr('href')).to eq '#header-1'
filter/table_of_contents_tag_filter_spec.rb:      expect(links.first.text).to eq 'Header 1'
filter/table_of_contents_tag_filter_spec.rb:      expect(links.last.attr('href')).to eq '#header-2'
filter/table_of_contents_tag_filter_spec.rb:      expect(links.last.text).to eq 'Header 2'
filter/table_of_contents_tag_filter_spec.rb:    context 'table of contents nesting' do
filter/table_of_contents_tag_filter_spec.rb:            #{header(1, 'Header 1')}
filter/table_of_contents_tag_filter_spec.rb:            #{header(2, 'Header 1-1')}
filter/table_of_contents_tag_filter_spec.rb:            #{header(3, 'Header 1-1-1')}
filter/table_of_contents_tag_filter_spec.rb:            #{header(2, 'Header 1-2')}
filter/table_of_contents_tag_filter_spec.rb:            #{header(1, 'Header 2')}
filter/table_of_contents_tag_filter_spec.rb:            #{header(2, 'Header 2-1')}
filter/table_of_contents_tag_filter_spec.rb:            #{header(2, 'Header 2-1b')}
filter/table_of_contents_tag_filter_spec.rb:      it 'keeps list levels regarding header levels' do
filter/table_of_contents_tag_filter_spec.rb:        items = doc.css('li')
filter/table_of_contents_tag_filter_spec.rb:        expect(items[0].ancestors).to satisfy_none { |node| node.name == 'li' }
filter/table_of_contents_tag_filter_spec.rb:        expect(items[4].ancestors).to satisfy_none { |node| node.name == 'li' }
filter/table_of_contents_tag_filter_spec.rb:    context 'header text contains escaped content' do
filter/table_of_contents_tag_filter_spec.rb:      let(:content) { '&lt;img src="x" onerror="alert(42)"&gt;' }
filter/table_of_contents_tag_filter_spec.rb:      it 'outputs escaped content' do
filter/table_of_contents_tag_filter_spec.rb:  it_behaves_like 'pipeline timing check'
filter/markdown_filter_spec.rb:require 'spec_helper'
filter/markdown_filter_spec.rb:  describe 'markdown engine from context' do
filter/markdown_filter_spec.rb:    it 'finds the correct engine' do
filter/markdown_filter_spec.rb:      expect(described_class.new('foo', { markdown_engine: :cmark }).render_engine)
filter/markdown_filter_spec.rb:    it 'defaults to the GLFM_ENGINE' do
filter/markdown_filter_spec.rb:      expect(described_class.new('foo', {}).render_engine).to eq engine
filter/markdown_filter_spec.rb:    it 'raise error for unrecognized engines' do
filter/markdown_filter_spec.rb:      expect { described_class.new('foo', { markdown_engine: :foo_bar }).render_engine }.to raise_error(NameError)
filter/markdown_filter_spec.rb:  describe 'parse_sourcepos' do
filter/markdown_filter_spec.rb:      '1:1-1:4'     | { start: { row: 0, col: 0 }, end: { row: 0, col: 3 } }
filter/markdown_filter_spec.rb:      '12:22-1:456' | { start: { row: 11, col: 21 }, end: { row: 0, col: 455 } }
filter/markdown_filter_spec.rb:      '0:0-0:0'     | { start: { row: 0, col: 0 }, end: { row: 0, col: 0 } }
filter/markdown_filter_spec.rb:      '-1:2-3:-4'   | nil
filter/markdown_filter_spec.rb:      it 'correctly parses' do
filter/markdown_filter_spec.rb:  describe 'code block' do
filter/markdown_filter_spec.rb:    it 'adds language to lang attribute when specified' do
filter/markdown_filter_spec.rb:      expect(result).to start_with('<pre lang="html"><code>')
filter/markdown_filter_spec.rb:    it 'does not add language to lang attribute when not specified' do
filter/markdown_filter_spec.rb:      expect(result).to start_with('<pre><code>')
filter/markdown_filter_spec.rb:    it 'works with utf8 chars in language' do
filter/markdown_filter_spec.rb:      expect(result).to start_with('<pre lang=""><code>')
filter/markdown_filter_spec.rb:    it 'works with additional language parameters' do
filter/markdown_filter_spec.rb:      expect(result).to include('lang="ruby:red"')
filter/markdown_filter_spec.rb:      expect(result).to include('data-meta="gem foo"')
filter/markdown_filter_spec.rb:  describe 'source line position' do
filter/markdown_filter_spec.rb:    it 'defaults to add data-sourcepos' do
filter/markdown_filter_spec.rb:      result = filter('test')
filter/markdown_filter_spec.rb:      expect(result).to eq '<p data-sourcepos="1:1-1:4">test</p>'
filter/markdown_filter_spec.rb:    it 'disables data-sourcepos' do
filter/markdown_filter_spec.rb:      result = filter('test', no_sourcepos: true)
filter/markdown_filter_spec.rb:      expect(result).to eq '<p>test</p>'
filter/markdown_filter_spec.rb:  describe 'footnotes in tables' do
filter/markdown_filter_spec.rb:    it 'processes footnotes in table cells' do
filter/markdown_filter_spec.rb:      expect(result).to include('<td>foot <sup')
filter/markdown_filter_spec.rb:      expect(result).to include('<section class="footnotes" data-footnotes>')
filter/markdown_filter_spec.rb:  describe 'multiline blockquotes' do
filter/markdown_filter_spec.rb:    it 'works and has correct data-sourcepos references' do
filter/markdown_filter_spec.rb:  it 'properly handles mixture with HTML comments and raw markdown' do
filter/markdown_filter_spec.rb:  describe 'math support' do
filter/markdown_filter_spec.rb:    it 'recognizes math syntax' do
filter/markdown_filter_spec.rb:  describe 'autolink' do
filter/markdown_filter_spec.rb:    it 'does nothing when :autolink is false' do
filter/markdown_filter_spec.rb:      expect(filter('http://example.com', { autolink: false, no_sourcepos: true })).to eq expected
filter/markdown_filter_spec.rb:    it 'autolinks https' do
filter/markdown_filter_spec.rb:      expected = '<p><a href="https://example.com">https://example.com</a></p>'
filter/markdown_filter_spec.rb:      expect(filter('https://example.com', no_sourcepos: true)).to eq expected
filter/markdown_filter_spec.rb:    it 'autolinks any scheme' do
filter/markdown_filter_spec.rb:      expected = '<p><a href="smb:///Volumes/shared/foo.pdf">smb:///Volumes/shared/foo.pdf</a></p>'
filter/markdown_filter_spec.rb:      expect(filter('smb:///Volumes/shared/foo.pdf', no_sourcepos: true)).to eq expected
filter/sanitization_filter_spec.rb:require 'spec_helper'
filter/sanitization_filter_spec.rb:  it_behaves_like 'default allowlist'
filter/sanitization_filter_spec.rb:  describe 'custom allowlist' do
filter/sanitization_filter_spec.rb:    it 'customizes the allowlist only once' do
filter/sanitization_filter_spec.rb:      instance = described_class.new('Foo')
filter/sanitization_filter_spec.rb:    it 'customizes the allowlist only once for different instances' do
filter/sanitization_filter_spec.rb:      instance1 = described_class.new('Foo1')
filter/sanitization_filter_spec.rb:      instance2 = described_class.new('Foo2')
filter/sanitization_filter_spec.rb:    it 'sanitizes `class` attribute from all elements' do
filter/sanitization_filter_spec.rb:    it 'sanitizes `class` attribute from non-highlight spans' do
filter/sanitization_filter_spec.rb:    it 'allows `data-table-*` attributes on `table` elements' do
filter/sanitization_filter_spec.rb:      expect(doc.at_css('table')['data-table-fields']).to eq 'foo'
filter/sanitization_filter_spec.rb:      expect(doc.at_css('table')['data-table-filter']).to eq 'true'
filter/sanitization_filter_spec.rb:      expect(doc.at_css('table')['data-table-markdown']).to eq 'true'
filter/sanitization_filter_spec.rb:    it 'allows `text-align` property in `style` attribute on table elements' do
filter/sanitization_filter_spec.rb:      expect(doc.at_css('th')['style']).to eq 'text-align: center'
filter/sanitization_filter_spec.rb:      expect(doc.at_css('td')['style']).to eq 'text-align: right'
filter/sanitization_filter_spec.rb:    it 'disallows other properties in `style` attribute on table elements' do
filter/sanitization_filter_spec.rb:      expect(doc.at_css('th')['style']).to be_nil
filter/sanitization_filter_spec.rb:      expect(doc.at_css('td')['style']).to eq 'text-align: center'
filter/sanitization_filter_spec.rb:    it 'disallows `text-align` property in `style` attribute on other elements' do
filter/sanitization_filter_spec.rb:      expect(doc.at_css('div')['style']).to be_nil
filter/sanitization_filter_spec.rb:    it 'allows `span` elements' do
filter/sanitization_filter_spec.rb:    it 'allows `abbr` elements' do
filter/sanitization_filter_spec.rb:    it 'disallows the `name` attribute globally, allows on `a`' do
filter/sanitization_filter_spec.rb:      expect(doc.at_css('img')).not_to have_attribute('name')
filter/sanitization_filter_spec.rb:      expect(doc.at_css('span')).not_to have_attribute('name')
filter/sanitization_filter_spec.rb:      expect(doc.at_css('a')).to have_attribute('name')
filter/sanitization_filter_spec.rb:    it 'allows `summary` elements' do
filter/sanitization_filter_spec.rb:      exp = act = '<summary>summary line</summary>'
filter/sanitization_filter_spec.rb:    it 'allows `details` elements' do
filter/sanitization_filter_spec.rb:      exp = act = '<details>long text goes here</details>'
filter/sanitization_filter_spec.rb:    it 'allows `rel=license` in links' do
filter/sanitization_filter_spec.rb:      exp = act = '<a rel="license" href="http://example.com">rel-license</a>'
filter/sanitization_filter_spec.rb:    it 'allows `data-math-style` attribute on `span`, code` and `pre` elements' do
filter/sanitization_filter_spec.rb:    it 'allows the `data-sourcepos` attribute globally' do
filter/sanitization_filter_spec.rb:    describe 'footnotes' do
filter/sanitization_filter_spec.rb:      it 'allows the footnote attributes' do
filter/sanitization_filter_spec.rb:      it 'allows correct footnote id property on links' do
filter/sanitization_filter_spec.rb:      it 'allows correct footnote id property on li element' do
filter/sanitization_filter_spec.rb:      it 'removes invalid id for footnote links' do
filter/sanitization_filter_spec.rb:      it 'removes invalid id for footnote li' do
filter/sanitization_filter_spec.rb:    describe 'link anchors' do
filter/sanitization_filter_spec.rb:      it 'allows id property on anchor links' do
filter/sanitization_filter_spec.rb:      it 'removes id property for non-anchor links' do
filter/sanitization_filter_spec.rb:      it 'removes id property for non-user-content links' do
filter/sanitization_filter_spec.rb:    describe 'remove_unsafe_classes' do
filter/sanitization_filter_spec.rb:        it 'removes classes' do
filter/sanitization_filter_spec.rb:  it_behaves_like 'does not use pipeline timing check'
filter/sanitization_filter_spec.rb:  it_behaves_like 'a filter timeout' do
filter/sanitization_filter_spec.rb:    let(:text) { 'text' }
filter/color_filter_spec.rb:require 'spec_helper'
filter/color_filter_spec.rb:  let(:color) { '#F00' }
filter/color_filter_spec.rb:  let(:color_chip_selector) { 'code > span.gfm-color_chip > span' }
filter/color_filter_spec.rb:  ['#123', '#1234', '#123456', '#12345678',
filter/color_filter_spec.rb:   'rgb(0,0,0)', 'RGB(0, 0, 0)', 'rgba(0,0,0,1)', 'RGBA(0,0,0,0.7)',
filter/color_filter_spec.rb:   'hsl(270,30%,50%)', 'HSLA(270, 30%, 50%, .7)'].each do |color|
filter/color_filter_spec.rb:      expect(color_chip.parent[:class]).to eq 'gfm-color_chip'
filter/color_filter_spec.rb:  it 'ignores valid color code without backticks(code tags)' do
filter/color_filter_spec.rb:    expect(doc.css('span.gfm-color_chip').size).to be_zero
filter/color_filter_spec.rb:  it 'ignores valid color code with prepended space' do
filter/color_filter_spec.rb:    content = code_tag(' ' + color)
filter/color_filter_spec.rb:  it 'ignores valid color code with appended space' do
filter/color_filter_spec.rb:    content = code_tag(color + ' ')
filter/color_filter_spec.rb:  it 'ignores valid color code surrounded by spaces' do
filter/color_filter_spec.rb:    content = code_tag(' ' + color + ' ')
filter/color_filter_spec.rb:  it 'ignores invalid color code' do
filter/color_filter_spec.rb:    invalid_color = '#BAR'
filter/color_filter_spec.rb:  it_behaves_like 'pipeline timing check'
filter/video_link_filter_spec.rb:require 'spec_helper'
filter/video_link_filter_spec.rb:    return '<img/>' if path.nil?
filter/video_link_filter_spec.rb:  shared_examples 'a video element' do
filter/video_link_filter_spec.rb:    it 'replaces the image tag with a video tag' do
filter/video_link_filter_spec.rb:      expect(container.name).to eq 'span'
filter/video_link_filter_spec.rb:      expect(container['class']).to eq 'media-container video-container'
filter/video_link_filter_spec.rb:      expect(video.name).to eq 'video'
filter/video_link_filter_spec.rb:      expect(video['src']).to eq src
filter/video_link_filter_spec.rb:      expect(video['height']).to eq height if height
filter/video_link_filter_spec.rb:      expect(video['width']).to eq width if width
filter/video_link_filter_spec.rb:      expect(video['preload']).to eq 'metadata'
filter/video_link_filter_spec.rb:      expect(link.name).to eq 'a'
filter/video_link_filter_spec.rb:      expect(link['href']).to eq src
filter/video_link_filter_spec.rb:      expect(link['target']).to eq '_blank'
filter/video_link_filter_spec.rb:  shared_examples 'an unchanged element' do |ext|
filter/video_link_filter_spec.rb:    it 'leaves the document unchanged' do
filter/video_link_filter_spec.rb:      expect(element.name).to eq 'img'
filter/video_link_filter_spec.rb:      expect(element['src']).to eq src
filter/video_link_filter_spec.rb:  context 'when the element src has a video extension' do
filter/video_link_filter_spec.rb:      it_behaves_like 'a video element' do
filter/video_link_filter_spec.rb:      it_behaves_like 'a video element' do
filter/video_link_filter_spec.rb:  context 'when the element has height or width specified' do
filter/video_link_filter_spec.rb:    let(:src) { '/path/video.mp4' }
filter/video_link_filter_spec.rb:    it_behaves_like 'a video element' do
filter/video_link_filter_spec.rb:      let(:height) { '100%' }
filter/video_link_filter_spec.rb:      let(:width) { '50px' }
filter/video_link_filter_spec.rb:    it_behaves_like 'a video element' do
filter/video_link_filter_spec.rb:      let(:width) { '50px' }
filter/video_link_filter_spec.rb:    it_behaves_like 'a video element' do
filter/video_link_filter_spec.rb:      let(:height) { '50px' }
filter/video_link_filter_spec.rb:  context 'when the element has no src attribute' do
filter/video_link_filter_spec.rb:    it_behaves_like 'an unchanged element'
filter/video_link_filter_spec.rb:  context 'when the element src is an image' do
filter/video_link_filter_spec.rb:    let(:src) { '/path/my_image.jpg' }
filter/video_link_filter_spec.rb:    it_behaves_like 'an unchanged element'
filter/video_link_filter_spec.rb:  context 'when the element src has an invalid file extension' do
filter/video_link_filter_spec.rb:    let(:src) { '/path/my_video.somemp4' }
filter/video_link_filter_spec.rb:    it_behaves_like 'an unchanged element'
filter/video_link_filter_spec.rb:  context 'when data-canonical-src is empty' do
filter/video_link_filter_spec.rb:    context 'and src is a video' do
filter/video_link_filter_spec.rb:      let(:src) { '/path/video.mp4' }
filter/video_link_filter_spec.rb:      it_behaves_like 'a video element'
filter/video_link_filter_spec.rb:    context 'and src is an image' do
filter/video_link_filter_spec.rb:      let(:src) { '/path/my_image.jpg' }
filter/video_link_filter_spec.rb:      it_behaves_like 'an unchanged element'
filter/video_link_filter_spec.rb:  context 'when data-canonical-src is set' do
filter/video_link_filter_spec.rb:    it 'uses the correct src' do
filter/video_link_filter_spec.rb:      proxy_src = 'https://assets.example.com/6d8b63'
filter/video_link_filter_spec.rb:      canonical_src = 'http://example.com/test.mp4'
filter/video_link_filter_spec.rb:      expect(container['class']).to eq 'media-container video-container'
filter/video_link_filter_spec.rb:      expect(video['src']).to eq proxy_src
filter/video_link_filter_spec.rb:      expect(video['data-canonical-src']).to eq canonical_src
filter/video_link_filter_spec.rb:      expect(link['href']).to eq proxy_src
filter/video_link_filter_spec.rb:  it_behaves_like 'pipeline timing check'
filter/kroki_filter_spec.rb:require 'spec_helper'
filter/kroki_filter_spec.rb:  it 'replaces nomnoml pre tag with img tag if kroki is enabled' do
filter/kroki_filter_spec.rb:    expect(doc.to_s).to eq '<img src="http://localhost:8000/nomnoml/svg/eNqLDsgsSixJrUmtTHXOL80rsVLwzCupKUrMTNHQtC7IzMlJTE_V0KzhUlCITkpNLEqJ1dWNLkgsKsoviUUSs7KLTssvzVHIzS8tyYjligUAMhEd0g==" class="js-render-kroki" data-diagram="nomnoml" data-diagram-src="data:text/plain;base64,W1BpcmF0ZXxleWVDb3VudDogSW50fHJhaWQoKTtwaWxsYWdlKCl8CiAgW2JlYXJkXS0tW3BhcnJvdF0KICBbYmVhcmRdLTo+W2ZvdWwgbW91dGhdCl0=">'
filter/kroki_filter_spec.rb:  it 'replaces nomnoml pre tag with img tag if both kroki and plantuml are enabled' do
filter/kroki_filter_spec.rb:    expect(doc.to_s).to eq '<img src="http://localhost:8000/nomnoml/svg/eNqLDsgsSixJrUmtTHXOL80rsVLwzCupKUrMTNHQtC7IzMlJTE_V0KzhUlCITkpNLEqJ1dWNLkgsKsoviUUSs7KLTssvzVHIzS8tyYjligUAMhEd0g==" class="js-render-kroki" data-diagram="nomnoml" data-diagram-src="data:text/plain;base64,W1BpcmF0ZXxleWVDb3VudDogSW50fHJhaWQoKTtwaWxsYWdlKCl8CiAgW2JlYXJkXS0tW3BhcnJvdF0KICBbYmVhcmRdLTo+W2ZvdWwgbW91dGhdCl0=">'
filter/kroki_filter_spec.rb:  it 'does not replace nomnoml pre tag with img tag if kroki is disabled' do
filter/kroki_filter_spec.rb:  it 'does not replace plantuml pre tag with img tag if both kroki and plantuml are enabled' do
filter/kroki_filter_spec.rb:  it 'adds hidden attribute when content size is large' do
filter/kroki_filter_spec.rb:    expect(doc.to_s).to start_with '<img src="http://localhost:8000/nomnoml/svg/eNrtzCEOgDAMAEC_V0wysQ9AgkHh8M1EyQosGYw0nSDZ47EInlB74mBJjEKNHppKvaS38yWNMcXODXfKGXfqXDPWwkrIMXgPNzIXCR_rR9hKzfYsVY5gggFttdVWW2211Vbb__YFciTqeA==" hidden="" class="js-render-kroki" data-diagram="nomnoml" data-diagram-src="data:text/plain;base64,W1BpcmF0ZXxleWVDb3VudDog'
filter/kroki_filter_spec.rb:  it 'allows the lang attribute on the code tag to support RST files processed by gitlab-markup gem' do
filter/kroki_filter_spec.rb:    expect(doc.to_s).to eq '<img src="http://localhost:8000/nomnoml/svg/eNqLDsgsSixJrUmtTHXOL80rsVLwzCupKUrMTNHQtC7IzMlJTE_V0KzhUlCITkpNLEqJ1dWNLkgsKsoviUUSs7KLTssvzVHIzS8tyYjligUAMhEd0g==" class="js-render-kroki" data-diagram="nomnoml" data-diagram-src="data:text/plain;base64,W1BpcmF0ZXxleWVDb3VudDogSW50fHJhaWQoKTtwaWxsYWdlKCl8CiAgW2JlYXJkXS0tW3BhcnJvdF0KICBbYmVhcmRdLTo+W2ZvdWwgbW91dGhdCl0=">'
filter/kroki_filter_spec.rb:  it 'verifies diagram type to avoid possible XSS' do
filter/kroki_filter_spec.rb:    doc = filter(%(<a><pre data-canonical-lang='f/" onerror=alert(1) onload=alert(1) '><code data-canonical-lang="wavedrom">xss</code></pre></a>))
filter/kroki_filter_spec.rb:    expect(doc.to_s).to eq %(<a><pre data-canonical-lang='f/" onerror=alert(1) onload=alert(1) '><code data-canonical-lang="wavedrom">xss</code></pre></a>)
filter/kroki_filter_spec.rb:  it "strips at most one trailing newline from the diagram's source" do
filter/kroki_filter_spec.rb:    output = '<img src="http://localhost:8000/graphviz/svg/eNpLyUwvSizIUKhWSFTQtVNIUqjl0tdX8EutKFHIycxLVchJTStRyMwrSc0ryczPS8zJqVRIyknMy9bjAgArOBNq" class="js-render-kroki" data-diagram="graphviz" data-diagram-src="data:text/plain;base64,ZGlncmFwaCB7IGEgLT4gYiB9Ci8vIE5leHQgbGluZSBsZWZ0IGludGVudGlvbmFsbHkgYmxhbmsuCg==">'
filter/kroki_filter_spec.rb:  it_behaves_like 'pipeline timing check'
filter/autolink_filter_spec.rb:require 'spec_helper'
filter/autolink_filter_spec.rb:  let(:link) { 'http://about.gitlab.com/' }
filter/autolink_filter_spec.rb:  let(:quotes) { ['"', "'"] }
filter/autolink_filter_spec.rb:  context 'when using default markdown engine' do
filter/autolink_filter_spec.rb:    it 'does nothing' do
filter/autolink_filter_spec.rb:    it 'autolinks when using single_line pipeline' do
filter/autolink_filter_spec.rb:      expect(doc.at_css('a').text).to eq link
filter/autolink_filter_spec.rb:    it 'autolinks when using commit_description pipeline' do
filter/autolink_filter_spec.rb:      expect(doc.at_css('a').text).to eq link
filter/autolink_filter_spec.rb:  it 'does nothing when :autolink is false' do
filter/autolink_filter_spec.rb:  it 'does nothing with non-link text' do
filter/autolink_filter_spec.rb:    exp = act = 'This text contains no links to autolink'
filter/autolink_filter_spec.rb:  context 'when using various schemes' do
filter/autolink_filter_spec.rb:    it 'autolinks http' do
filter/autolink_filter_spec.rb:      expect(doc.at_css('a').text).to eq link
filter/autolink_filter_spec.rb:      expect(doc.at_css('a')['href']).to eq link
filter/autolink_filter_spec.rb:    it 'autolinks https' do
filter/autolink_filter_spec.rb:      link = 'https://google.com/'
filter/autolink_filter_spec.rb:      expect(doc.at_css('a').text).to eq link
filter/autolink_filter_spec.rb:      expect(doc.at_css('a')['href']).to eq link
filter/autolink_filter_spec.rb:    it 'autolinks ftp' do
filter/autolink_filter_spec.rb:      link = 'ftp://ftp.us.debian.org/debian/'
filter/autolink_filter_spec.rb:      expect(doc.at_css('a').text).to eq link
filter/autolink_filter_spec.rb:      expect(doc.at_css('a')['href']).to eq link
filter/autolink_filter_spec.rb:    it 'autolinks short URLs' do
filter/autolink_filter_spec.rb:      link = 'http://localhost:3000/'
filter/autolink_filter_spec.rb:      expect(doc.at_css('a').text).to eq link
filter/autolink_filter_spec.rb:      expect(doc.at_css('a')['href']).to eq link
filter/autolink_filter_spec.rb:    it 'autolinks multiple URLs' do
filter/autolink_filter_spec.rb:      link1 = 'http://localhost:3000/'
filter/autolink_filter_spec.rb:      link2 = 'http://google.com/'
filter/autolink_filter_spec.rb:      found_links = doc.css('a')
filter/autolink_filter_spec.rb:      expect(found_links[0]['href']).to eq(link1)
filter/autolink_filter_spec.rb:      expect(found_links[1]['href']).to eq(link2)
filter/autolink_filter_spec.rb:    it 'accepts link_attr options' do
filter/autolink_filter_spec.rb:      doc = filter("See #{link}", context.merge(link_attr: { class: 'custom' }))
filter/autolink_filter_spec.rb:      expect(doc.at_css('a')['class']).to eq 'custom'
filter/autolink_filter_spec.rb:    it 'autolinks smb' do
filter/autolink_filter_spec.rb:      link = 'smb:///Volumes/shared/foo.pdf'
filter/autolink_filter_spec.rb:      expect(doc.at_css('a').text).to eq link
filter/autolink_filter_spec.rb:      expect(doc.at_css('a')['href']).to eq link
filter/autolink_filter_spec.rb:    it 'autolinks multiple occurrences of smb' do
filter/autolink_filter_spec.rb:      link1 = 'smb:///Volumes/shared/foo.pdf'
filter/autolink_filter_spec.rb:      link2 = 'smb:///Volumes/shared/bar.pdf'
filter/autolink_filter_spec.rb:      found_links = doc.css('a')
filter/autolink_filter_spec.rb:      expect(found_links[0]['href']).to eq(link1)
filter/autolink_filter_spec.rb:      expect(found_links[1]['href']).to eq(link2)
filter/autolink_filter_spec.rb:    it 'autolinks irc' do
filter/autolink_filter_spec.rb:      link = 'irc://irc.freenode.net/git'
filter/autolink_filter_spec.rb:      expect(doc.at_css('a').text).to eq link
filter/autolink_filter_spec.rb:      expect(doc.at_css('a')['href']).to eq link
filter/autolink_filter_spec.rb:    it 'autolinks rdar' do
filter/autolink_filter_spec.rb:      link = 'rdar://localhost.com/blah'
filter/autolink_filter_spec.rb:      expect(doc.at_css('a').text).to eq link
filter/autolink_filter_spec.rb:      expect(doc.at_css('a')['href']).to eq link
filter/autolink_filter_spec.rb:    it 'does not autolink javascript' do
filter/autolink_filter_spec.rb:      link = 'javascript://alert(document.cookie);'
filter/autolink_filter_spec.rb:      expect(doc.at_css('a')).to be_nil
filter/autolink_filter_spec.rb:    it 'does not autolink bad URLs' do
filter/autolink_filter_spec.rb:      link = 'foo://23423:::asdf'
filter/autolink_filter_spec.rb:    it 'does not autolink bad URLs after we remove trailing punctuation' do
filter/autolink_filter_spec.rb:      link = 'http://]'
filter/autolink_filter_spec.rb:    it 'does not include trailing punctuation' do
filter/autolink_filter_spec.rb:      ['.', ', ok?', '...', '?', '!', ': is that ok?'].each do |trailing_punctuation|
filter/autolink_filter_spec.rb:        expect(doc.at_css('a').text).to eq link
filter/autolink_filter_spec.rb:    it 'includes trailing punctuation when part of a balanced pair' do
filter/autolink_filter_spec.rb:        expect(balanced_actual.at_css('a').text).to eq(balanced_link)
filter/autolink_filter_spec.rb:        expect(unbalanced_actual.at_css('a').text).to eq(link)
filter/autolink_filter_spec.rb:    it 'removes trailing quotes' do
filter/autolink_filter_spec.rb:        expect(balanced_actual.at_css('a').text).to eq(balanced_link[0...-1])
filter/autolink_filter_spec.rb:        expect(unbalanced_actual.at_css('a').text).to eq(link)
filter/autolink_filter_spec.rb:    it 'removes one closing punctuation mark when the punctuation in the link is unbalanced' do
filter/autolink_filter_spec.rb:      complicated_link = "(#{link}(a'b[c'd]))'"
filter/autolink_filter_spec.rb:      expected_complicated_link = %{(<a href="#{link}(a'b[c'd]))">#{link}(a'b[c'd]))</a>'}
filter/autolink_filter_spec.rb:    it 'does not double-encode HTML entities' do
filter/autolink_filter_spec.rb:    it 'does not include trailing HTML entities' do
filter/autolink_filter_spec.rb:      expect(doc.at_css('a')['href']).to eq link
filter/autolink_filter_spec.rb:    it 'escapes RTLO and other characters' do
filter/autolink_filter_spec.rb:      expect(doc.at_css('a')['href']).to eq "http://about.gitlab.com/evil%E2%80%AE3pm.exe"
filter/autolink_filter_spec.rb:    it 'encodes international domains' do
filter/autolink_filter_spec.rb:      expect(doc.at_css('a')['href']).to eq expected
filter/autolink_filter_spec.rb:      it "ignores valid links contained inside '#{elem}' element" do
filter/autolink_filter_spec.rb:  context 'when the link is inside a tag' do
filter/autolink_filter_spec.rb:        expect(doc.children.last.text).to include('<another>')
filter/autolink_filter_spec.rb:  it 'protects against malicious backtracking', quarantine: 'https://gitlab.com/gitlab-org/gitlab/-/issues/447553' do
filter/autolink_filter_spec.rb:    doc = "http://#{'&' * 1_000_000}x"
filter/autolink_filter_spec.rb:  it 'does not timeout with excessively long scheme' do
filter/autolink_filter_spec.rb:    doc = "#{'h' * 1_000_000}://example.com"
filter/autolink_filter_spec.rb:  it 'does not timeout with excessively long scheme and no link' do
filter/autolink_filter_spec.rb:    doc = "#{'h' * 1_000_000}://"
filter/autolink_filter_spec.rb:  # does. We don't care about that difference for these specs, though.
filter/attributes_filter_spec.rb:require 'spec_helper'
filter/attributes_filter_spec.rb:  describe 'attribute syntax' do
filter/attributes_filter_spec.rb:    context 'when attribute syntax is valid' do
filter/attributes_filter_spec.rb:        "#{image}{width=100}"           | '<img src="example.jpg" width="100">'
filter/attributes_filter_spec.rb:        "#{image}{  width=100 }"        | '<img src="example.jpg" width="100">'
filter/attributes_filter_spec.rb:        "#{image}{width=\"100\"}"       | '<img src="example.jpg" width="100">'
filter/attributes_filter_spec.rb:        "#{image}{width=100 width=200}" | '<img src="example.jpg" width="200">'
filter/attributes_filter_spec.rb:        "#{image}{.test_class width=100 style=\"width:400\"}"   | '<img src="example.jpg" width="100">'
filter/attributes_filter_spec.rb:        "<img src=\"example.jpg\" class=\"lazy\" />{width=100}" | '<img src="example.jpg" class="lazy" width="100">'
filter/attributes_filter_spec.rb:        it 'adds them to the img' do
filter/attributes_filter_spec.rb:    context 'when attribute syntax is invalid' do
filter/attributes_filter_spec.rb:        "#{image} {width=100}"             | '<img src="example.jpg"> {width=100}'
filter/attributes_filter_spec.rb:        '<h1>header</h1>{width=100}'       | '<h1>header</h1>{width=100}'
filter/attributes_filter_spec.rb:        it 'does not recognize as attributes' do
filter/attributes_filter_spec.rb:  describe 'height and width' do
filter/attributes_filter_spec.rb:    context 'when size attributes are valid' do
filter/attributes_filter_spec.rb:        "#{image}{width=100 height=200px}" | '<img src="example.jpg" width="100" height="200px">'
filter/attributes_filter_spec.rb:        "#{image}{width=100}"              | '<img src="example.jpg" width="100">'
filter/attributes_filter_spec.rb:        "#{image}{width=100px}"            | '<img src="example.jpg" width="100px">'
filter/attributes_filter_spec.rb:        "#{image}{height=100%}"            | '<img src="example.jpg" height="100%">'
filter/attributes_filter_spec.rb:        "#{image}{width=\"100%\"}"         | '<img src="example.jpg" width="100%">'
filter/attributes_filter_spec.rb:        it 'adds them to the img' do
filter/attributes_filter_spec.rb:    context 'when size attributes are invalid' do
filter/attributes_filter_spec.rb:        "#{image}{width=100cs}"           | '<img src="example.jpg">'
filter/attributes_filter_spec.rb:        "#{image}{width=auto height=200}" | '<img src="example.jpg" height="200">'
filter/attributes_filter_spec.rb:        "#{image}{width=10000}"           | '<img src="example.jpg">'
filter/attributes_filter_spec.rb:        "#{image}{width=-200}"            | '<img src="example.jpg">'
filter/attributes_filter_spec.rb:        it 'ignores them' do
filter/attributes_filter_spec.rb:  it_behaves_like 'pipeline timing check'
filter/html_entity_filter_spec.rb:require 'spec_helper'
filter/html_entity_filter_spec.rb:  let(:unescaped) { 'foo <strike attr="foo">&&amp;&</strike>' }
filter/html_entity_filter_spec.rb:  let(:escaped) { 'foo &lt;strike attr=&quot;foo&quot;&gt;&amp;&amp;amp;&amp;&lt;/strike&gt;' }
filter/html_entity_filter_spec.rb:  it 'converts common entities to their HTML-escaped equivalents' do
filter/absolute_link_filter_spec.rb:require 'spec_helper'
filter/absolute_link_filter_spec.rb:  context 'with html links' do
filter/absolute_link_filter_spec.rb:    context 'if only_path is false' do
filter/absolute_link_filter_spec.rb:      let(:fake_url) { 'http://www.example.com' }
filter/absolute_link_filter_spec.rb:      context 'has the .gfm class' do
filter/absolute_link_filter_spec.rb:        it 'converts a relative url into absolute' do
filter/absolute_link_filter_spec.rb:          doc = filter(link('/foo', 'gfm'), only_path_context)
filter/absolute_link_filter_spec.rb:          expect(doc.at_css('a')['href']).to eq "#{fake_url}/foo"
filter/absolute_link_filter_spec.rb:        it 'does not change the url if it already absolute' do
filter/absolute_link_filter_spec.rb:          doc = filter(link("#{fake_url}/foo", 'gfm'), only_path_context)
filter/absolute_link_filter_spec.rb:          expect(doc.at_css('a')['href']).to eq "#{fake_url}/foo"
filter/absolute_link_filter_spec.rb:        context 'if relative_url_root is set' do
filter/absolute_link_filter_spec.rb:          it 'joins the url without doubling the path' do
filter/absolute_link_filter_spec.rb:            doc = filter(link("/gitlab/foo", 'gfm'), only_path_context)
filter/absolute_link_filter_spec.rb:            expect(doc.at_css('a')['href']).to eq "#{fake_url}/gitlab/foo"
filter/absolute_link_filter_spec.rb:      context 'has not the .gfm class' do
filter/absolute_link_filter_spec.rb:        it 'does not convert a relative url into absolute' do
filter/absolute_link_filter_spec.rb:          doc = filter(link('/foo'), only_path_context)
filter/absolute_link_filter_spec.rb:          expect(doc.at_css('a')['href']).to eq '/foo'
filter/absolute_link_filter_spec.rb:    context 'if only_path is not false' do
filter/absolute_link_filter_spec.rb:      it 'does not convert a relative url into absolute' do
filter/absolute_link_filter_spec.rb:        expect(filter(link('/foo', 'gfm')).at_css('a')['href']).to eq '/foo'
filter/absolute_link_filter_spec.rb:        expect(filter(link('/foo')).at_css('a')['href']).to eq '/foo'
filter/absolute_link_filter_spec.rb:  it_behaves_like 'pipeline timing check'
filter/absolute_link_filter_spec.rb:  def link(path, css_class = '')
filter/table_of_contents_tag_legacy_filter_spec.rb:require 'spec_helper'
filter/table_of_contents_tag_legacy_filter_spec.rb:  context 'table of contents' do
filter/table_of_contents_tag_legacy_filter_spec.rb:    shared_examples 'table of contents tag' do
filter/table_of_contents_tag_legacy_filter_spec.rb:      it 'replaces toc tag with ToC result' do
filter/table_of_contents_tag_legacy_filter_spec.rb:      it 'handles an empty ToC result' do
filter/table_of_contents_tag_legacy_filter_spec.rb:        expect(doc.to_html).to eq ''
filter/table_of_contents_tag_legacy_filter_spec.rb:    context '[[_TOC_]] as tag' do
filter/table_of_contents_tag_legacy_filter_spec.rb:      it_behaves_like 'table of contents tag' do
filter/table_of_contents_tag_legacy_filter_spec.rb:        let(:html) { '<p>[[<em>TOC</em>]]</p>' }
filter/table_of_contents_tag_legacy_filter_spec.rb:    context '[[_toc_]] as tag' do
filter/table_of_contents_tag_legacy_filter_spec.rb:      it_behaves_like 'table of contents tag' do
filter/table_of_contents_tag_legacy_filter_spec.rb:        let(:html) { '<p>[[<em>toc</em>]]</p>' }
filter/table_of_contents_tag_legacy_filter_spec.rb:    context '[TOC] as tag' do
filter/table_of_contents_tag_legacy_filter_spec.rb:      it_behaves_like 'table of contents tag' do
filter/table_of_contents_tag_legacy_filter_spec.rb:        let(:html) { '<p>[TOC]</p>' }
filter/table_of_contents_tag_legacy_filter_spec.rb:    context '[toc] as tag' do
filter/table_of_contents_tag_legacy_filter_spec.rb:      it_behaves_like 'table of contents tag' do
filter/table_of_contents_tag_legacy_filter_spec.rb:        let(:html) { '<p>[toc]</p>' }
filter/table_of_contents_tag_legacy_filter_spec.rb:  describe 'structure of a toc' do
filter/table_of_contents_tag_legacy_filter_spec.rb:      "#{'#' * level} #{text}\n"
filter/table_of_contents_tag_legacy_filter_spec.rb:    let(:results) { result("[toc]\n\n#{header(1, 'Header 1')}#{header(2, 'Header 2')}") }
filter/table_of_contents_tag_legacy_filter_spec.rb:    it 'is contained within a `ul` element' do
filter/table_of_contents_tag_legacy_filter_spec.rb:      expect(doc.children.first.name).to eq 'ul'
filter/table_of_contents_tag_legacy_filter_spec.rb:      expect(doc.children.first.attr('class')).to eq 'section-nav'
filter/table_of_contents_tag_legacy_filter_spec.rb:    it 'contains an `li` element for each header' do
filter/table_of_contents_tag_legacy_filter_spec.rb:      expect(doc.css('li').length).to eq 2
filter/table_of_contents_tag_legacy_filter_spec.rb:      links = doc.css('li a')
filter/table_of_contents_tag_legacy_filter_spec.rb:      expect(links.first.attr('href')).to eq '#header-1'
filter/table_of_contents_tag_legacy_filter_spec.rb:      expect(links.first.text).to eq 'Header 1'
filter/table_of_contents_tag_legacy_filter_spec.rb:      expect(links.last.attr('href')).to eq '#header-2'
filter/table_of_contents_tag_legacy_filter_spec.rb:      expect(links.last.text).to eq 'Header 2'
filter/table_of_contents_tag_legacy_filter_spec.rb:    context 'table of contents nesting' do
filter/table_of_contents_tag_legacy_filter_spec.rb:            #{header(1, 'Header 1')}
filter/table_of_contents_tag_legacy_filter_spec.rb:            #{header(2, 'Header 1-1')}
filter/table_of_contents_tag_legacy_filter_spec.rb:            #{header(3, 'Header 1-1-1')}
filter/table_of_contents_tag_legacy_filter_spec.rb:            #{header(2, 'Header 1-2')}
filter/table_of_contents_tag_legacy_filter_spec.rb:            #{header(1, 'Header 2')}
filter/table_of_contents_tag_legacy_filter_spec.rb:            #{header(2, 'Header 2-1')}
filter/table_of_contents_tag_legacy_filter_spec.rb:            #{header(2, 'Header 2-1b')}
filter/table_of_contents_tag_legacy_filter_spec.rb:      it 'keeps list levels regarding header levels' do
filter/table_of_contents_tag_legacy_filter_spec.rb:        items = doc.css('li')
filter/table_of_contents_tag_legacy_filter_spec.rb:        expect(items[0].ancestors).to satisfy_none { |node| node.name == 'li' }
filter/table_of_contents_tag_legacy_filter_spec.rb:        expect(items[4].ancestors).to satisfy_none { |node| node.name == 'li' }
filter/table_of_contents_tag_legacy_filter_spec.rb:    context 'header text contains escaped content' do
filter/table_of_contents_tag_legacy_filter_spec.rb:      let(:content) { '&lt;img src="x" onerror="alert(42)"&gt;' }
filter/table_of_contents_tag_legacy_filter_spec.rb:      it 'outputs escaped content' do
filter/emoji_filter_spec.rb:require 'spec_helper'
filter/emoji_filter_spec.rb:  it_behaves_like 'emoji filter' do
filter/emoji_filter_spec.rb:    let(:emoji_name) { ':+1:' }
filter/emoji_filter_spec.rb:  it 'replaces supported name emoji' do
filter/emoji_filter_spec.rb:    doc = filter('<p>:heart:</p>')
filter/emoji_filter_spec.rb:    expect(doc.css('gl-emoji').first.text).to eq ''
filter/emoji_filter_spec.rb:  it 'replaces supported unicode emoji' do
filter/emoji_filter_spec.rb:    doc = filter('<p></p>')
filter/emoji_filter_spec.rb:    expect(doc.css('gl-emoji').first.text).to eq ''
filter/emoji_filter_spec.rb:  it 'ignores unicode versions of trademark, copyright, and registered trademark' do
filter/emoji_filter_spec.rb:    exp = act = '<p>  </p>'
filter/emoji_filter_spec.rb:  it 'replaces name versions of trademark, copyright, and registered trademark' do
filter/emoji_filter_spec.rb:    doc = filter('<p>:tm: :copyright: :registered:</p>')
filter/emoji_filter_spec.rb:    expect(doc.css('gl-emoji')[0].text).to eq ''
filter/emoji_filter_spec.rb:    expect(doc.css('gl-emoji')[1].text).to eq ''
filter/emoji_filter_spec.rb:    expect(doc.css('gl-emoji')[2].text).to eq ''
filter/emoji_filter_spec.rb:  it 'correctly encodes the URL' do
filter/emoji_filter_spec.rb:    doc = filter('<p>:+1:</p>')
filter/emoji_filter_spec.rb:    expect(doc.css('gl-emoji').first.text).to eq ''
filter/emoji_filter_spec.rb:  it 'correctly encodes unicode to the URL' do
filter/emoji_filter_spec.rb:    doc = filter('<p></p>')
filter/emoji_filter_spec.rb:    expect(doc.css('gl-emoji').first.text).to eq ''
filter/emoji_filter_spec.rb:  it 'matches at the start of a string' do
filter/emoji_filter_spec.rb:    doc = filter(':+1:')
filter/emoji_filter_spec.rb:    expect(doc.css('gl-emoji').size).to eq 1
filter/emoji_filter_spec.rb:  it 'unicode matches at the start of a string' do
filter/emoji_filter_spec.rb:    doc = filter("''")
filter/emoji_filter_spec.rb:    expect(doc.css('gl-emoji').size).to eq 1
filter/emoji_filter_spec.rb:  it 'matches at the end of a string' do
filter/emoji_filter_spec.rb:    doc = filter('This gets a :-1:')
filter/emoji_filter_spec.rb:    expect(doc.css('gl-emoji').size).to eq 1
filter/emoji_filter_spec.rb:  it 'unicode matches at the end of a string' do
filter/emoji_filter_spec.rb:    doc = filter('This gets a ')
filter/emoji_filter_spec.rb:    expect(doc.css('gl-emoji').size).to eq 1
filter/emoji_filter_spec.rb:  it 'unicode matches with adjacent text' do
filter/emoji_filter_spec.rb:    doc = filter('+1 ()')
filter/emoji_filter_spec.rb:    expect(doc.css('gl-emoji').size).to eq 1
filter/emoji_filter_spec.rb:  it 'does not match multiple emoji in a row' do
filter/emoji_filter_spec.rb:    doc = filter(':see_no_evil::hear_no_evil::speak_no_evil:')
filter/emoji_filter_spec.rb:    expect(doc.css('gl-emoji').size).to eq 0
filter/emoji_filter_spec.rb:  it 'unicode matches multiple emoji in a row' do
filter/emoji_filter_spec.rb:    doc = filter("''")
filter/emoji_filter_spec.rb:    expect(doc.css('gl-emoji').size).to eq 3
filter/emoji_filter_spec.rb:  it 'mixed matches multiple emoji in a row' do
filter/emoji_filter_spec.rb:    doc = filter("':see_no_evil::hear_no_evil::speak_no_evil:'")
filter/emoji_filter_spec.rb:    expect(doc.css('gl-emoji').size).to eq 6
filter/emoji_filter_spec.rb:  it 'has a data-name attribute' do
filter/emoji_filter_spec.rb:    doc = filter(':-1:')
filter/emoji_filter_spec.rb:    expect(doc.css('gl-emoji').first.attr('data-name')).to eq AwardEmoji::THUMBS_DOWN
filter/emoji_filter_spec.rb:  it 'has a data-unicode-version attribute' do
filter/emoji_filter_spec.rb:    doc = filter(':-1:')
filter/emoji_filter_spec.rb:    expect(doc.css('gl-emoji').first.attr('data-unicode-version')).to eq '6.0'
filter/emoji_filter_spec.rb:  it 'unicode keeps whitespace intact' do
filter/emoji_filter_spec.rb:    doc = filter('This deserves a , big time.')
filter/emoji_filter_spec.rb:  context 'when TanukiEmoji can not find the emoji' do
filter/emoji_filter_spec.rb:    it 'alpha code is not replaced with tag' do
filter/emoji_filter_spec.rb:      doc = filter(':smile:')
filter/emoji_filter_spec.rb:      expect(doc.css('gl-emoji').size).to eq 0
filter/emoji_filter_spec.rb:    it 'unicode emoji is not replaced with tag' do
filter/emoji_filter_spec.rb:      doc = filter('')
filter/emoji_filter_spec.rb:      expect(doc.css('gl-emoji').size).to eq 0
filter/emoji_filter_spec.rb:  it 'ignores backref emoji in footnote references' do
filter/emoji_filter_spec.rb:    expect(doc.to_html).to start_with('<p><gl-emoji')
filter/emoji_filter_spec.rb:    expect(doc.to_html).to include('></a>')
filter/emoji_filter_spec.rb:  context 'when unicode emojis' do
filter/emoji_filter_spec.rb:    it_behaves_like 'limits the number of filtered items' do
filter/emoji_filter_spec.rb:      let(:text) { '' * 3 }
filter/emoji_filter_spec.rb:      let(:ends_with) { '</gl-emoji>' }
filter/emoji_filter_spec.rb:  context 'when named emojis' do
filter/emoji_filter_spec.rb:    it_behaves_like 'limits the number of filtered items' do
filter/emoji_filter_spec.rb:      let(:text) { ':play_pause: ' * 3 }
filter/emoji_filter_spec.rb:      let(:ends_with) { '</gl-emoji> :play_pause: ' }
filter/emoji_filter_spec.rb:  context 'when mixed emojis' do
filter/emoji_filter_spec.rb:    it_behaves_like 'limits the number of filtered items' do
filter/emoji_filter_spec.rb:      let(:text) { ' :play_pause:  :play_pause:  :play_pause:' }
filter/emoji_filter_spec.rb:      let(:ends_with) { '</gl-emoji>  :play_pause:' }
filter/emoji_filter_spec.rb:  context 'when using TanukiEmoji' do
filter/emoji_filter_spec.rb:    # the regex doesn't find emoji components, and they are not really meant to be used
filter/emoji_filter_spec.rb:    it 'finds all unicode emoji codepoints with regex' do
filter/emoji_filter_spec.rb:  context 'and protects against pathological number of emojis' do
filter/emoji_filter_spec.rb:    it 'limit keeps it from timing out' do
filter/emoji_filter_spec.rb:        Timeout.timeout(BANZAI_FILTER_TIMEOUT_MAX) { filter(' :play_pause: ' * 500000) }
filter/emoji_filter_spec.rb:        Timeout.timeout(BANZAI_FILTER_TIMEOUT_MAX) { filter('*' * 10000000) }
filter/emoji_filter_spec.rb:  it_behaves_like 'pipeline timing check'
filter/emoji_filter_spec.rb:  it_behaves_like 'a filter timeout' do
filter/emoji_filter_spec.rb:    let(:text) { 'text' }
filter/issuable_reference_expansion_filter_spec.rb:require 'spec_helper'
filter/issuable_reference_expansion_filter_spec.rb:    ActionController::Base.helpers.link_to(text, '', class: 'gfm has-tooltip', data: data)
filter/issuable_reference_expansion_filter_spec.rb:  it 'ignores non-GFM links' do
filter/issuable_reference_expansion_filter_spec.rb:    expect(doc.css('a').last.text).to eq('Google')
filter/issuable_reference_expansion_filter_spec.rb:  it 'ignores non-issuable links' do
filter/issuable_reference_expansion_filter_spec.rb:    link = create_link('text', project: project.id, reference_type: 'issue')
filter/issuable_reference_expansion_filter_spec.rb:    expect(doc.css('a').last.text).to eq('text')
filter/issuable_reference_expansion_filter_spec.rb:  it 'ignores issuable links with empty content' do
filter/issuable_reference_expansion_filter_spec.rb:    link = create_link('', issue: closed_issue.id, reference_type: 'issue')
filter/issuable_reference_expansion_filter_spec.rb:    expect(doc.css('a').last.text).to eq('')
filter/issuable_reference_expansion_filter_spec.rb:  it 'ignores issuable links with custom anchor' do
filter/issuable_reference_expansion_filter_spec.rb:    link = create_link('something', issue: closed_issue.id, reference_type: 'issue')
filter/issuable_reference_expansion_filter_spec.rb:    expect(doc.css('a').last.text).to eq('something')
filter/issuable_reference_expansion_filter_spec.rb:  it 'ignores issuable links to specific comments' do
filter/issuable_reference_expansion_filter_spec.rb:    link = create_link("#{closed_issue.to_reference} (comment 1)", issue: closed_issue.id, reference_type: 'issue')
filter/issuable_reference_expansion_filter_spec.rb:    expect(doc.css('a').last.text).to eq("#{closed_issue.to_reference} (comment 1)")
filter/issuable_reference_expansion_filter_spec.rb:  it 'ignores merge request links to diffs tab' do
filter/issuable_reference_expansion_filter_spec.rb:      reference_type: 'merge_request'
filter/issuable_reference_expansion_filter_spec.rb:    expect(doc.css('a').last.text).to eq("#{merge_request.to_reference} (diffs)")
filter/issuable_reference_expansion_filter_spec.rb:  it 'handles cross project references' do
filter/issuable_reference_expansion_filter_spec.rb:    link = create_link(closed_issue.to_reference(other_project), issue: closed_issue.id, reference_type: 'issue')
filter/issuable_reference_expansion_filter_spec.rb:    expect(doc.css('a').last.text).to eq("#{closed_issue.to_reference(other_project)} (closed)")
filter/issuable_reference_expansion_filter_spec.rb:  it 'handles references from group scopes' do
filter/issuable_reference_expansion_filter_spec.rb:    link = create_link(closed_issue.to_reference(other_project), issue: closed_issue.id, reference_type: 'issue')
filter/issuable_reference_expansion_filter_spec.rb:    expect(doc.css('a').last.text).to eq("#{closed_issue.to_reference(other_project)} (closed)")
filter/issuable_reference_expansion_filter_spec.rb:  it 'skips cross project references if the user cannot read cross project' do
filter/issuable_reference_expansion_filter_spec.rb:    link = create_link(closed_issue.to_reference(other_project), issue: closed_issue.id, reference_type: 'issue')
filter/issuable_reference_expansion_filter_spec.rb:    expect(doc.css('a').last.text).to eq(closed_issue.to_reference(other_project).to_s)
filter/issuable_reference_expansion_filter_spec.rb:  it 'does not append state when filter is not enabled' do
filter/issuable_reference_expansion_filter_spec.rb:    link = create_link('text', issue: closed_issue.id, reference_type: 'issue')
filter/issuable_reference_expansion_filter_spec.rb:    expect(doc.css('a').last.text).to eq('text')
filter/issuable_reference_expansion_filter_spec.rb:  context 'when project is in pending delete' do
filter/issuable_reference_expansion_filter_spec.rb:    it 'does not append issue state' do
filter/issuable_reference_expansion_filter_spec.rb:      link = create_link('text', issue: closed_issue.id, reference_type: 'issue')
filter/issuable_reference_expansion_filter_spec.rb:      expect(doc.css('a').last.text).to eq('text')
filter/issuable_reference_expansion_filter_spec.rb:  shared_examples 'issue / work item references' do
filter/issuable_reference_expansion_filter_spec.rb:    it 'ignores open references' do
filter/issuable_reference_expansion_filter_spec.rb:      expect(doc.css('a').last.text).to eq(issuable.to_reference)
filter/issuable_reference_expansion_filter_spec.rb:    it 'appends state to moved references' do
filter/issuable_reference_expansion_filter_spec.rb:      expect(doc.css('a').last.text).to eq("#{moved_issuable.to_reference} (moved)")
filter/issuable_reference_expansion_filter_spec.rb:    it 'appends state to closed references' do
filter/issuable_reference_expansion_filter_spec.rb:      expect(doc.css('a').last.text).to eq("#{issuable.to_reference} (closed)")
filter/issuable_reference_expansion_filter_spec.rb:    it 'shows title for references with +' do
filter/issuable_reference_expansion_filter_spec.rb:      issuable = create_item(issuable_type, :opened, title: 'Some issue')
filter/issuable_reference_expansion_filter_spec.rb:        reference_format: '+')
filter/issuable_reference_expansion_filter_spec.rb:      expect(doc.css('a').last.text).to eq("#{issuable.title} (#{issuable.to_reference})")
filter/issuable_reference_expansion_filter_spec.rb:    it 'truncates long title for references with +' do
filter/issuable_reference_expansion_filter_spec.rb:      issuable = create_item(issuable_type, :opened, title: 'Some issue ' * 10)
filter/issuable_reference_expansion_filter_spec.rb:        reference_format: '+')
filter/issuable_reference_expansion_filter_spec.rb:      expect(doc.css('a').last.text).to eq("#{issuable.title.truncate(50)} (#{issuable.to_reference})")
filter/issuable_reference_expansion_filter_spec.rb:    it 'shows both title and state for closed references with +' do
filter/issuable_reference_expansion_filter_spec.rb:      issuable = create_item(issuable_type, :closed, title: 'Some issue')
filter/issuable_reference_expansion_filter_spec.rb:        reference_format: '+')
filter/issuable_reference_expansion_filter_spec.rb:      expect(doc.css('a').last.text).to eq("#{issuable.title} (#{issuable.to_reference} - closed)")
filter/issuable_reference_expansion_filter_spec.rb:    context 'for references with fenced emoji' do
filter/issuable_reference_expansion_filter_spec.rb:          reference_format: '+'
filter/issuable_reference_expansion_filter_spec.rb:      it 'expands emoji for references with +' do
filter/issuable_reference_expansion_filter_spec.rb:        issuable = create_item(issuable_type, :opened, title: 'Some issue :eagle:')
filter/issuable_reference_expansion_filter_spec.rb:        expect(/\p{Emoji_Presentation}/ =~ doc.css('a').last.text).not_to be_nil
filter/issuable_reference_expansion_filter_spec.rb:        expect(doc.css('a').last.text.scan(/\p{Emoji_Presentation}/)).to eq([""])
filter/issuable_reference_expansion_filter_spec.rb:      it 'expands when emoji is embedded at the beginning of a string' do
filter/issuable_reference_expansion_filter_spec.rb:        issuable = create_item(issuable_type, :opened, title: ':eagle: Some issue')
filter/issuable_reference_expansion_filter_spec.rb:        expect(/\p{Emoji_Presentation}/ =~ doc.css('a').last.text).not_to be_nil
filter/issuable_reference_expansion_filter_spec.rb:        expect(doc.css('a').last.text.scan(/\p{Emoji_Presentation}/)).to eq([""])
filter/issuable_reference_expansion_filter_spec.rb:      it 'expands when emoji appears multiple times' do
filter/issuable_reference_expansion_filter_spec.rb:        issuable = create_item(issuable_type, :opened, title: ':eagle: Some issue :dog:')
filter/issuable_reference_expansion_filter_spec.rb:        expect(/\p{Emoji_Presentation}/ =~ doc.css('a').last.text).not_to be_nil
filter/issuable_reference_expansion_filter_spec.rb:        expect(doc.css('a').last.text.scan(/\p{Emoji_Presentation}/)).to eq(["", ""])
filter/issuable_reference_expansion_filter_spec.rb:      it 'does not expand when emoji is embedded mid-string' do
filter/issuable_reference_expansion_filter_spec.rb:        issuable = create_item(issuable_type, :opened, title: 'Some:eagle:issue')
filter/issuable_reference_expansion_filter_spec.rb:        expect(/\p{Emoji_Presentation}/ =~ doc.css('a').last.text).to be_nil
filter/issuable_reference_expansion_filter_spec.rb:    it 'shows title for references with +s' do
filter/issuable_reference_expansion_filter_spec.rb:      issuable = create_item(issuable_type, :opened, title: 'Some issue')
filter/issuable_reference_expansion_filter_spec.rb:        reference_format: '+s')
filter/issuable_reference_expansion_filter_spec.rb:      expect(doc.css('a').last.text).to eq("#{issuable.title} (#{issuable.to_reference})  Unassigned")
filter/issuable_reference_expansion_filter_spec.rb:    context 'when extended summary props are present' do
filter/issuable_reference_expansion_filter_spec.rb:        create_item(issuable_type, :opened, title: 'Some issue', milestone: milestone,
filter/issuable_reference_expansion_filter_spec.rb:          reference_format: '+s')
filter/issuable_reference_expansion_filter_spec.rb:      it 'shows extended summary for references with +s' do
filter/issuable_reference_expansion_filter_spec.rb:        expect(doc.css('a').last.text).to eq(
filter/issuable_reference_expansion_filter_spec.rb:      describe 'checking N+1' do
filter/issuable_reference_expansion_filter_spec.rb:        it 'does not have N+1 for extended summary', :use_sql_query_cache do
filter/issuable_reference_expansion_filter_spec.rb:          issuable2 = create_item(issuable_type, :opened, title: 'Another issue',
filter/issuable_reference_expansion_filter_spec.rb:            reference_type: issuable_type, reference_format: '+s')
filter/issuable_reference_expansion_filter_spec.rb:  context 'for work item references' do
filter/issuable_reference_expansion_filter_spec.rb:    it_behaves_like 'issue / work item references'
filter/issuable_reference_expansion_filter_spec.rb:  context 'for issue references' do
filter/issuable_reference_expansion_filter_spec.rb:    it_behaves_like 'issue / work item references'
filter/issuable_reference_expansion_filter_spec.rb:  context 'for merge request references' do
filter/issuable_reference_expansion_filter_spec.rb:    it 'ignores open merge request references' do
filter/issuable_reference_expansion_filter_spec.rb:        reference_type: 'merge_request'
filter/issuable_reference_expansion_filter_spec.rb:      expect(doc.css('a').last.text).to eq(merge_request.to_reference)
filter/issuable_reference_expansion_filter_spec.rb:    it 'ignores locked merge request references' do
filter/issuable_reference_expansion_filter_spec.rb:        reference_type: 'merge_request'
filter/issuable_reference_expansion_filter_spec.rb:      expect(doc.css('a').last.text).to eq(merge_request.to_reference)
filter/issuable_reference_expansion_filter_spec.rb:    it 'appends state to closed merge request references' do
filter/issuable_reference_expansion_filter_spec.rb:        reference_type: 'merge_request'
filter/issuable_reference_expansion_filter_spec.rb:      expect(doc.css('a').last.text).to eq("#{merge_request.to_reference} (closed)")
filter/issuable_reference_expansion_filter_spec.rb:    it 'appends state to merged merge request references' do
filter/issuable_reference_expansion_filter_spec.rb:        reference_type: 'merge_request'
filter/issuable_reference_expansion_filter_spec.rb:      expect(doc.css('a').last.text).to eq("#{merge_request.to_reference} (merged)")
filter/issuable_reference_expansion_filter_spec.rb:    it 'shows title for references with +' do
filter/issuable_reference_expansion_filter_spec.rb:      merge_request = create_merge_request(:opened, title: 'Some merge request')
filter/issuable_reference_expansion_filter_spec.rb:        reference_type: 'merge_request',
filter/issuable_reference_expansion_filter_spec.rb:        reference_format: '+'
filter/issuable_reference_expansion_filter_spec.rb:      expect(doc.css('a').last.text).to eq("#{merge_request.title} (#{merge_request.to_reference})")
filter/issuable_reference_expansion_filter_spec.rb:    it 'shows title for references with +s' do
filter/issuable_reference_expansion_filter_spec.rb:      merge_request = create_merge_request(:opened, title: 'Some merge request')
filter/issuable_reference_expansion_filter_spec.rb:        reference_type: 'merge_request',
filter/issuable_reference_expansion_filter_spec.rb:        reference_format: '+s'
filter/issuable_reference_expansion_filter_spec.rb:      expect(doc.css('a').last.text).to eq("#{merge_request.title} (#{merge_request.to_reference})  Unassigned")
filter/issuable_reference_expansion_filter_spec.rb:    context 'when extended summary props are present' do
filter/issuable_reference_expansion_filter_spec.rb:        create_merge_request(:opened, title: 'Some merge request', milestone: milestone, assignees: assignees)
filter/issuable_reference_expansion_filter_spec.rb:          reference_type: 'merge_request',
filter/issuable_reference_expansion_filter_spec.rb:          reference_format: '+s'
filter/issuable_reference_expansion_filter_spec.rb:      it 'shows extended summary for references with +s' do
filter/issuable_reference_expansion_filter_spec.rb:        expect(doc.css('a').last.text).to eq(
filter/issuable_reference_expansion_filter_spec.rb:      describe 'checking N+1' do
filter/issuable_reference_expansion_filter_spec.rb:        it 'does not have N+1 for extended summary', :use_sql_query_cache do
filter/issuable_reference_expansion_filter_spec.rb:            title: 'Some merge request',
filter/issuable_reference_expansion_filter_spec.rb:            reference_type: 'merge_request',
filter/issuable_reference_expansion_filter_spec.rb:            reference_format: '+s'
filter/issuable_reference_expansion_filter_spec.rb:  it_behaves_like 'pipeline timing check'
filter/concerns/timeout_filter_handler_spec.rb:require 'spec_helper'
filter/concerns/timeout_filter_handler_spec.rb:  context 'when subclassed from HTML filter' do
filter/concerns/timeout_filter_handler_spec.rb:      stub_const 'TimeoutTest', Class.new(HTML::Pipeline::Filter)
filter/concerns/timeout_filter_handler_spec.rb:    it_behaves_like 'a filter timeout' do
filter/concerns/timeout_filter_handler_spec.rb:      let(:text) { '<p>some text</p>' }
filter/concerns/timeout_filter_handler_spec.rb:    it 'raises NotImplementedError' do
filter/concerns/timeout_filter_handler_spec.rb:      expect { filter('test') }.to raise_error NotImplementedError
filter/concerns/timeout_filter_handler_spec.rb:  context 'when subclassed from Text filter' do
filter/concerns/timeout_filter_handler_spec.rb:      stub_const 'TimeoutTest', Class.new(HTML::Pipeline::TextFilter)
filter/concerns/timeout_filter_handler_spec.rb:    it_behaves_like 'a filter timeout' do
filter/concerns/timeout_filter_handler_spec.rb:      let(:text) { '<p>some text</p>' }
filter/concerns/timeout_filter_handler_spec.rb:    it 'raises NotImplementedError' do
filter/concerns/timeout_filter_handler_spec.rb:      expect { filter('test') }.to raise_error NotImplementedError
filter/concerns/timeout_filter_handler_spec.rb:  context 'when GITLAB_DISABLE_MARKDOWN_TIMEOUT set' do
filter/concerns/timeout_filter_handler_spec.rb:      stub_env('GITLAB_DISABLE_MARKDOWN_TIMEOUT' => '1')
filter/concerns/timeout_filter_handler_spec.rb:      stub_const 'TimeoutTest', Class.new(HTML::Pipeline::Filter)
filter/concerns/timeout_filter_handler_spec.rb:    it_behaves_like 'not a filter timeout' do
filter/concerns/timeout_filter_handler_spec.rb:      let(:text) { '<p>some text</p>' }
filter/concerns/output_safety_spec.rb:require 'fast_spec_helper'
filter/concerns/output_safety_spec.rb:  let(:content) { '<pre><code>foo</code></pre>' }
filter/concerns/output_safety_spec.rb:  context 'when given HTML is safe' do
filter/concerns/output_safety_spec.rb:    it 'returns safe HTML' do
filter/concerns/output_safety_spec.rb:  context 'when given HTML is not safe' do
filter/concerns/output_safety_spec.rb:    it 'returns escaped HTML' do
filter/concerns/pipeline_timing_check_spec.rb:require 'spec_helper'
filter/concerns/pipeline_timing_check_spec.rb:  context 'when pipeline_timing' do
filter/concerns/pipeline_timing_check_spec.rb:      stub_const('Banzai::Filter::Concerns::PipelineTimingCheck::MAX_PIPELINE_SECONDS', 1)
filter/concerns/pipeline_timing_check_spec.rb:      stub_const('PipelineTest', Class.new(HTML::Pipeline::Filter))
filter/concerns/pipeline_timing_check_spec.rb:    it 'returns true if MAX_PIPELINE_SECONDS exceeded' do
filter/concerns/pipeline_timing_check_spec.rb:      expect(described_class.new('text').exceeded_pipeline_max?).to be_truthy
filter/concerns/pipeline_timing_check_spec.rb:    it 'returns false if MAX_PIPELINE_SECONDS not exceeded' do
filter/concerns/pipeline_timing_check_spec.rb:      expect(described_class.new('text').exceeded_pipeline_max?).to be_falsey
filter/concerns/pipeline_timing_check_spec.rb:    context 'when GITLAB_DISABLE_MARKDOWN_TIMEOUT set' do
filter/concerns/pipeline_timing_check_spec.rb:      it 'ignores MAX_PIPELINE_SECONDS' do
filter/concerns/pipeline_timing_check_spec.rb:        stub_env('GITLAB_DISABLE_MARKDOWN_TIMEOUT' => '1')
filter/concerns/pipeline_timing_check_spec.rb:        expect(described_class.new('text').exceeded_pipeline_max?).to be_falsey
filter/external_link_filter_spec.rb:require 'spec_helper'
filter/external_link_filter_spec.rb:  shared_examples 'an external link with rel attribute' do
filter/external_link_filter_spec.rb:    it 'adds rel="nofollow" to external links' do
filter/external_link_filter_spec.rb:      expect(doc.at_css('a')).to have_attribute('rel')
filter/external_link_filter_spec.rb:      expect(doc.at_css('a')['rel']).to include 'nofollow'
filter/external_link_filter_spec.rb:    it 'adds rel="noreferrer" to external links' do
filter/external_link_filter_spec.rb:      expect(doc.at_css('a')).to have_attribute('rel')
filter/external_link_filter_spec.rb:      expect(doc.at_css('a')['rel']).to include 'noreferrer'
filter/external_link_filter_spec.rb:    it 'adds rel="noopener" to external links' do
filter/external_link_filter_spec.rb:      expect(doc.at_css('a')).to have_attribute('rel')
filter/external_link_filter_spec.rb:      expect(doc.at_css('a')['rel']).to include 'noopener'
filter/external_link_filter_spec.rb:  it 'ignores elements without an href attribute' do
filter/external_link_filter_spec.rb:  it 'ignores non-HTTP(S) links' do
filter/external_link_filter_spec.rb:  it 'skips internal links' do
filter/external_link_filter_spec.rb:  context 'for root links on document' do
filter/external_link_filter_spec.rb:    it_behaves_like 'an external link with rel attribute'
filter/external_link_filter_spec.rb:  context 'for nested links on document' do
filter/external_link_filter_spec.rb:    it_behaves_like 'an external link with rel attribute'
filter/external_link_filter_spec.rb:  context 'for invalid urls' do
filter/external_link_filter_spec.rb:    it 'adds rel and target attributes to broken hrefs' do
filter/external_link_filter_spec.rb:      doc = filter %q(<p><a href="don't crash on broken urls">Google</a></p>)
filter/external_link_filter_spec.rb:      expected = %q(<p><a href="don't%20crash%20on%20broken%20urls" rel="nofollow noreferrer noopener" target="_blank">Google</a></p>)
filter/external_link_filter_spec.rb:    it 'adds rel and target to improperly formatted mailtos' do
filter/external_link_filter_spec.rb:    it 'adds rel and target to improperly formatted autolinks' do
filter/external_link_filter_spec.rb:    it 'adds rel and target attributes to improperly formatted protocols' do
filter/external_link_filter_spec.rb:  context 'for links with a username' do
filter/external_link_filter_spec.rb:    context 'with a valid username' do
filter/external_link_filter_spec.rb:      it_behaves_like 'an external link with rel attribute'
filter/external_link_filter_spec.rb:    context 'with an impersonated username' do
filter/external_link_filter_spec.rb:      it_behaves_like 'an external link with rel attribute'
filter/external_link_filter_spec.rb:  context 'for non-lowercase scheme links' do
filter/external_link_filter_spec.rb:    context 'with http' do
filter/external_link_filter_spec.rb:      it_behaves_like 'an external link with rel attribute'
filter/external_link_filter_spec.rb:    context 'with https' do
filter/external_link_filter_spec.rb:      it_behaves_like 'an external link with rel attribute'
filter/external_link_filter_spec.rb:    it 'skips internal links' do
filter/external_link_filter_spec.rb:      url = internal_link.gsub(/\Ahttp/, 'HtTp')
filter/external_link_filter_spec.rb:    it 'skips relative links' do
filter/external_link_filter_spec.rb:  context 'for protocol-relative links' do
filter/external_link_filter_spec.rb:    it_behaves_like 'an external link with rel attribute'
filter/external_link_filter_spec.rb:  context 'links with RTLO character' do
filter/external_link_filter_spec.rb:    it_behaves_like 'an external link with rel attribute'
filter/external_link_filter_spec.rb:    it 'escapes RTLO in link text' do
filter/external_link_filter_spec.rb:    it 'does not mangle the link text' do
filter/external_link_filter_spec.rb:      expect(doc.to_html).to include('One<span>and</span>%E2%80%AEexe.mp3</a>')
filter/external_link_filter_spec.rb:  context 'for generated autolinks' do
filter/external_link_filter_spec.rb:    context 'with an IDN character' do
filter/external_link_filter_spec.rb:      it_behaves_like 'an external link with rel attribute'
filter/external_link_filter_spec.rb:      it 'does not change the link text' do
filter/external_link_filter_spec.rb:        expect(doc.to_html).to include('http://example.com</a>')
filter/external_link_filter_spec.rb:      it 'uses punycode for emails' do
filter/external_link_filter_spec.rb:        expect(doc_email.to_html).to include('http://xn--example-6p25f.com/</a>')
filter/external_link_filter_spec.rb:    context 'autolinked image' do
filter/external_link_filter_spec.rb:      it_behaves_like 'an external link with rel attribute'
filter/external_link_filter_spec.rb:      it 'adds a toolip with punycode' do
filter/external_link_filter_spec.rb:        expect(doc.to_html).to include('class="has-tooltip"')
filter/external_link_filter_spec.rb:        expect(doc.to_html).to include('title="http://xn--example-6p25f.com/test.png"')
filter/external_link_filter_spec.rb:  context 'for links that look malicious' do
filter/external_link_filter_spec.rb:    context 'with an IDN character' do
filter/external_link_filter_spec.rb:      it 'adds a toolip with punycode' do
filter/external_link_filter_spec.rb:        expect(doc.to_html).to include('http://example.com</a>')
filter/external_link_filter_spec.rb:        expect(doc.to_html).to include('class="has-tooltip"')
filter/external_link_filter_spec.rb:        expect(doc.to_html).to include('title="http://xn--example-6p25f.com/"')
filter/external_link_filter_spec.rb:    context 'with RTLO character' do
filter/external_link_filter_spec.rb:      it 'adds a toolip with punycode' do
filter/external_link_filter_spec.rb:        expect(doc.to_html).to include('Evil Test</a>')
filter/external_link_filter_spec.rb:        expect(doc.to_html).to include('class="has-tooltip"')
filter/external_link_filter_spec.rb:        expect(doc.to_html).to include('title="http://example.com/evil%E2%80%AE3pm.exe"')
filter/external_link_filter_spec.rb:  context 'for links that have `rel=license`' do
filter/external_link_filter_spec.rb:    it_behaves_like 'an external link with rel attribute'
filter/external_link_filter_spec.rb:    it 'maintains rel license' do
filter/external_link_filter_spec.rb:      expect(doc.at_css('a')).to have_attribute('rel')
filter/external_link_filter_spec.rb:      expect(doc.at_css('a')['rel']).to include 'license'
filter/external_link_filter_spec.rb:  it_behaves_like 'does not use pipeline timing check'
filter/external_link_filter_spec.rb:  it_behaves_like 'a filter timeout' do
filter/external_link_filter_spec.rb:    let(:text) { 'text' }
filter/reference_redactor_filter_spec.rb:require 'spec_helper'
filter/reference_redactor_filter_spec.rb:  it 'ignores non-GFM links' do
filter/reference_redactor_filter_spec.rb:    expect(doc.css('a').length).to eq 1
filter/reference_redactor_filter_spec.rb:    ActionController::Base.helpers.link_to('text', '', class: 'gfm', data: data)
filter/reference_redactor_filter_spec.rb:  it 'skips when the skip_redaction flag is set' do
filter/reference_redactor_filter_spec.rb:    link = reference_link(project: project.id, reference_type: 'test')
filter/reference_redactor_filter_spec.rb:    expect(doc.css('a').length).to eq 1
filter/reference_redactor_filter_spec.rb:  context 'with data-project' do
filter/reference_redactor_filter_spec.rb:        .with('test')
filter/reference_redactor_filter_spec.rb:    context 'valid projects' do
filter/reference_redactor_filter_spec.rb:      it 'allows permitted Project references' do
filter/reference_redactor_filter_spec.rb:        link = reference_link(project: project.id, reference_type: 'test')
filter/reference_redactor_filter_spec.rb:        expect(doc.css('a').length).to eq 1
filter/reference_redactor_filter_spec.rb:    context 'invalid projects' do
filter/reference_redactor_filter_spec.rb:      it 'removes unpermitted references' do
filter/reference_redactor_filter_spec.rb:        link = reference_link(project: project.id, reference_type: 'test')
filter/reference_redactor_filter_spec.rb:        expect(doc.css('a').length).to eq 0
filter/reference_redactor_filter_spec.rb:      it 'handles invalid references' do
filter/reference_redactor_filter_spec.rb:        link = reference_link(project: non_existing_record_id, reference_type: 'test')
filter/reference_redactor_filter_spec.rb:  context 'with data-issue' do
filter/reference_redactor_filter_spec.rb:    context 'for confidential issues' do
filter/reference_redactor_filter_spec.rb:      it 'removes references for non project members' do
filter/reference_redactor_filter_spec.rb:        link = reference_link(project: project.id, issue: issue.id, reference_type: 'issue')
filter/reference_redactor_filter_spec.rb:        expect(doc.css('a').length).to eq 0
filter/reference_redactor_filter_spec.rb:      it 'removes references for project members with guest role' do
filter/reference_redactor_filter_spec.rb:        link = reference_link(project: project.id, issue: issue.id, reference_type: 'issue')
filter/reference_redactor_filter_spec.rb:        expect(doc.css('a').length).to eq 0
filter/reference_redactor_filter_spec.rb:      it 'allows references for author' do
filter/reference_redactor_filter_spec.rb:        link = reference_link(project: project.id, issue: issue.id, reference_type: 'issue')
filter/reference_redactor_filter_spec.rb:        expect(doc.css('a').length).to eq 1
filter/reference_redactor_filter_spec.rb:      it 'allows references for assignee' do
filter/reference_redactor_filter_spec.rb:        link = reference_link(project: project.id, issue: issue.id, reference_type: 'issue')
filter/reference_redactor_filter_spec.rb:        expect(doc.css('a').length).to eq 1
filter/reference_redactor_filter_spec.rb:      it 'allows references for project members' do
filter/reference_redactor_filter_spec.rb:        link = reference_link(project: project.id, issue: issue.id, reference_type: 'issue')
filter/reference_redactor_filter_spec.rb:        expect(doc.css('a').length).to eq 1
filter/reference_redactor_filter_spec.rb:      context 'for admin' do
filter/reference_redactor_filter_spec.rb:        context 'when admin mode is enabled', :enable_admin_mode do
filter/reference_redactor_filter_spec.rb:          it 'allows references' do
filter/reference_redactor_filter_spec.rb:            link = reference_link(project: project.id, issue: issue.id, reference_type: 'issue')
filter/reference_redactor_filter_spec.rb:            expect(doc.css('a').length).to eq 1
filter/reference_redactor_filter_spec.rb:        context 'when admin mode is disabled' do
filter/reference_redactor_filter_spec.rb:          it 'removes references' do
filter/reference_redactor_filter_spec.rb:            link = reference_link(project: project.id, issue: issue.id, reference_type: 'issue')
filter/reference_redactor_filter_spec.rb:            expect(doc.css('a').length).to eq 0
filter/reference_redactor_filter_spec.rb:        it 'removes references for author' do
filter/reference_redactor_filter_spec.rb:          link = reference_link(project: private_project.id, issue: issue.id, reference_type: 'issue')
filter/reference_redactor_filter_spec.rb:          expect(doc.css('a').length).to eq 0
filter/reference_redactor_filter_spec.rb:        it 'removes references for assignee' do
filter/reference_redactor_filter_spec.rb:          link = reference_link(project: private_project.id, issue: issue.id, reference_type: 'issue')
filter/reference_redactor_filter_spec.rb:          expect(doc.css('a').length).to eq 0
filter/reference_redactor_filter_spec.rb:        it 'allows references for project members' do
filter/reference_redactor_filter_spec.rb:          link = reference_link(project: project_2.id, issue: issue.id, reference_type: 'issue')
filter/reference_redactor_filter_spec.rb:          expect(doc.css('a').length).to eq 1
filter/reference_redactor_filter_spec.rb:    it 'allows references for non confidential issues' do
filter/reference_redactor_filter_spec.rb:      link = reference_link(project: project.id, issue: issue.id, reference_type: 'issue')
filter/reference_redactor_filter_spec.rb:      expect(doc.css('a').length).to eq 1
filter/reference_redactor_filter_spec.rb:    context 'with data-group' do
filter/reference_redactor_filter_spec.rb:      it 'removes unpermitted Group references' do
filter/reference_redactor_filter_spec.rb:        link = reference_link(group: group.id, reference_type: 'user')
filter/reference_redactor_filter_spec.rb:        expect(doc.css('a').length).to eq 0
filter/reference_redactor_filter_spec.rb:      it 'allows permitted Group references' do
filter/reference_redactor_filter_spec.rb:        link = reference_link(group: group.id, reference_type: 'user')
filter/reference_redactor_filter_spec.rb:        expect(doc.css('a').length).to eq 1
filter/reference_redactor_filter_spec.rb:      it 'handles invalid Group references' do
filter/reference_redactor_filter_spec.rb:        link = reference_link(group: 12345, reference_type: 'user')
filter/reference_redactor_filter_spec.rb:    context 'with data-user' do
filter/reference_redactor_filter_spec.rb:      it 'allows any User reference' do
filter/reference_redactor_filter_spec.rb:        link = reference_link(user: user.id, reference_type: 'user')
filter/reference_redactor_filter_spec.rb:        expect(doc.css('a').length).to eq 1
filter/mermaid_filter_spec.rb:require 'spec_helper'
filter/mermaid_filter_spec.rb:  it 'adds `js-render-mermaid` class to the `code` tag' do
filter/mermaid_filter_spec.rb:    doc = filter("<pre class='code highlight js-syntax-highlight mermaid' data-canonical-lang='mermaid' v-pre='true'><code>graph TD;\n  A--&gt;B;\n</code></pre>")
filter/mermaid_filter_spec.rb:    result = doc.css('code').first
filter/mermaid_filter_spec.rb:    expect(result[:class]).to include('js-render-mermaid')
filter/mermaid_filter_spec.rb:  it_behaves_like 'pipeline timing check'
filter/code_language_filter_spec.rb:require 'spec_helper'
filter/code_language_filter_spec.rb:  shared_examples 'XSS prevention' do |lang|
filter/code_language_filter_spec.rb:    it 'escapes HTML tags' do
filter/code_language_filter_spec.rb:  context 'when no language is specified' do
filter/code_language_filter_spec.rb:    it 'does nothing' do
filter/code_language_filter_spec.rb:      result = filter('<pre><code>def fun end</code></pre>')
filter/code_language_filter_spec.rb:      expect(result.to_html.delete("\n")).to eq('<pre><code>def fun end</code></pre>')
filter/code_language_filter_spec.rb:  context 'when lang is specified on `pre`' do
filter/code_language_filter_spec.rb:    it 'adds data-canonical-lang and removes lang attribute' do
filter/code_language_filter_spec.rb:      result = filter('<pre lang="ruby"><code>def fun end</code></pre>')
filter/code_language_filter_spec.rb:        .to eq('<pre data-canonical-lang="ruby"><code>def fun end</code></pre>')
filter/code_language_filter_spec.rb:  context 'when lang is specified on `code`' do
filter/code_language_filter_spec.rb:    it 'adds data-canonical-lang to `pre` and removes lang attribute' do
filter/code_language_filter_spec.rb:      result = filter('<pre><code lang="ruby">def fun end</code></pre>')
filter/code_language_filter_spec.rb:        .to eq('<pre data-canonical-lang="ruby"><code>def fun end</code></pre>')
filter/code_language_filter_spec.rb:  context 'when lang has extra params' do
filter/code_language_filter_spec.rb:    let_it_be(:lang_params) { 'foo-bar-kux' }
filter/code_language_filter_spec.rb:    context 'when lang is specified on `pre`' do
filter/code_language_filter_spec.rb:      it 'includes data-lang-params tag with extra information and removes data-meta' do
filter/code_language_filter_spec.rb:    context 'when lang is specified on `code`' do
filter/code_language_filter_spec.rb:      it 'includes data-lang-params tag with extra information and removes data-meta' do
filter/code_language_filter_spec.rb:    include_examples 'XSS prevention', 'ruby'
filter/code_language_filter_spec.rb:    include_examples 'XSS prevention',
filter/code_language_filter_spec.rb:    include_examples 'XSS prevention',
filter/code_language_filter_spec.rb:  context 'when multiple param delimiters are used' do
filter/code_language_filter_spec.rb:    let(:lang) { 'suggestion' }
filter/code_language_filter_spec.rb:    let(:lang_params) { '-1+10' }
filter/code_language_filter_spec.rb:    context 'when delimiter is colon' do
filter/code_language_filter_spec.rb:      it 'delimits on the first appearance' do
filter/code_language_filter_spec.rb:  it_behaves_like 'pipeline timing check'
filter/references/alert_reference_filter_spec.rb:require 'spec_helper'
filter/references/alert_reference_filter_spec.rb:  it 'requires project context' do
filter/references/alert_reference_filter_spec.rb:    expect { described_class.call('') }.to raise_error(ArgumentError, /:project/)
filter/references/alert_reference_filter_spec.rb:    it "ignores valid references contained inside '#{elem}' element" do
filter/references/alert_reference_filter_spec.rb:  context 'internal reference' do
filter/references/alert_reference_filter_spec.rb:    it 'links to a valid reference' do
filter/references/alert_reference_filter_spec.rb:      expect(doc.css('a').first.attr('href')).to eq alert.details_url
filter/references/alert_reference_filter_spec.rb:    it 'links with adjacent text' do
filter/references/alert_reference_filter_spec.rb:    it 'ignores invalid alert IDs' do
filter/references/alert_reference_filter_spec.rb:    it 'includes a title attribute' do
filter/references/alert_reference_filter_spec.rb:      expect(doc.css('a').first.attr('title')).to eq alert.title
filter/references/alert_reference_filter_spec.rb:    it 'escapes the title attribute' do
filter/references/alert_reference_filter_spec.rb:    it 'includes default classes' do
filter/references/alert_reference_filter_spec.rb:      expect(doc.css('a').first.attr('class')).to eq 'gfm gfm-alert has-tooltip'
filter/references/alert_reference_filter_spec.rb:    it 'includes a data-project attribute' do
filter/references/alert_reference_filter_spec.rb:      link = doc.css('a').first
filter/references/alert_reference_filter_spec.rb:      expect(link).to have_attribute('data-project')
filter/references/alert_reference_filter_spec.rb:      expect(link.attr('data-project')).to eq project.id.to_s
filter/references/alert_reference_filter_spec.rb:    it 'includes a data-alert attribute' do
filter/references/alert_reference_filter_spec.rb:      link = doc.css('a').first
filter/references/alert_reference_filter_spec.rb:      expect(link).to have_attribute('data-alert')
filter/references/alert_reference_filter_spec.rb:      expect(link.attr('data-alert')).to eq alert.id.to_s
filter/references/alert_reference_filter_spec.rb:    it 'supports an :only_path context' do
filter/references/alert_reference_filter_spec.rb:      link = doc.css('a').first.attr('href')
filter/references/alert_reference_filter_spec.rb:  context 'cross-project / cross-namespace complete reference' do
filter/references/alert_reference_filter_spec.rb:    it 'links to a valid reference' do
filter/references/alert_reference_filter_spec.rb:      expect(doc.css('a').first.attr('href')).to eq alert.details_url
filter/references/alert_reference_filter_spec.rb:    it 'link has valid text' do
filter/references/alert_reference_filter_spec.rb:      expect(doc.css('a').first.text).to eql(reference)
filter/references/alert_reference_filter_spec.rb:    it 'has valid text' do
filter/references/alert_reference_filter_spec.rb:    it 'ignores invalid alert IDs on the referenced project' do
filter/references/alert_reference_filter_spec.rb:  context 'cross-project / same-namespace complete reference' do
filter/references/alert_reference_filter_spec.rb:    it 'links to a valid reference' do
filter/references/alert_reference_filter_spec.rb:      expect(doc.css('a').first.attr('href')).to eq alert.details_url
filter/references/alert_reference_filter_spec.rb:    it 'link has valid text' do
filter/references/alert_reference_filter_spec.rb:      expect(doc.css('a').first.text).to eql("#{project2.path}^alert##{alert.iid}")
filter/references/alert_reference_filter_spec.rb:    it 'has valid text' do
filter/references/alert_reference_filter_spec.rb:    it 'ignores invalid alert IDs on the referenced project' do
filter/references/alert_reference_filter_spec.rb:  context 'cross-project shorthand reference' do
filter/references/alert_reference_filter_spec.rb:    it 'links to a valid reference' do
filter/references/alert_reference_filter_spec.rb:      expect(doc.css('a').first.attr('href')).to eq alert.details_url
filter/references/alert_reference_filter_spec.rb:    it 'link has valid text' do
filter/references/alert_reference_filter_spec.rb:      expect(doc.css('a').first.text).to eql("#{project2.path}^alert##{alert.iid}")
filter/references/alert_reference_filter_spec.rb:    it 'has valid text' do
filter/references/alert_reference_filter_spec.rb:    it 'ignores invalid alert IDs on the referenced project' do
filter/references/alert_reference_filter_spec.rb:  context 'cross-project URL reference' do
filter/references/alert_reference_filter_spec.rb:    let_it_be(:namespace) { create(:namespace, name: 'cross-reference') }
filter/references/alert_reference_filter_spec.rb:    it 'links to a valid reference' do
filter/references/alert_reference_filter_spec.rb:      expect(doc.css('a').first.attr('href')).to eq alert.details_url
filter/references/alert_reference_filter_spec.rb:    it 'links with adjacent text' do
filter/references/alert_reference_filter_spec.rb:    it 'ignores invalid alert IDs on the referenced project' do
filter/references/alert_reference_filter_spec.rb:  context 'group context' do
filter/references/alert_reference_filter_spec.rb:    it 'links to a valid reference' do
filter/references/alert_reference_filter_spec.rb:      expect(result.css('a').first.attr('href')).to eq(alert.details_url)
filter/references/alert_reference_filter_spec.rb:    it 'ignores internal references' do
filter/references/alert_reference_filter_spec.rb:  context 'checking N+1' do
filter/references/alert_reference_filter_spec.rb:    it 'does not have N+1 per multiple references per project', :use_sql_query_cache do
filter/references/alert_reference_filter_spec.rb:      # Since we're not batching alert queries across projects,
filter/references/milestone_reference_filter_spec.rb:require 'spec_helper'
filter/references/milestone_reference_filter_spec.rb:  it 'requires project context' do
filter/references/milestone_reference_filter_spec.rb:    expect { described_class.call('') }.to raise_error(ArgumentError, /:project/)
filter/references/milestone_reference_filter_spec.rb:  shared_examples 'reference parsing' do
filter/references/milestone_reference_filter_spec.rb:      it "ignores valid references contained inside '#{elem}' element" do
filter/references/milestone_reference_filter_spec.rb:    it 'includes default classes' do
filter/references/milestone_reference_filter_spec.rb:      expect(doc.css('a').first.attr('class')).to eq 'gfm gfm-milestone has-tooltip'
filter/references/milestone_reference_filter_spec.rb:    it 'includes a data-project attribute' do
filter/references/milestone_reference_filter_spec.rb:      link = doc.css('a').first
filter/references/milestone_reference_filter_spec.rb:        expect(link).to have_attribute('data-project')
filter/references/milestone_reference_filter_spec.rb:        expect(link.attr('data-project')).to eq project.id.to_s
filter/references/milestone_reference_filter_spec.rb:        expect(link).to have_attribute('data-group')
filter/references/milestone_reference_filter_spec.rb:        expect(link.attr('data-group')).to eq milestone.group.id.to_s
filter/references/milestone_reference_filter_spec.rb:    it 'includes a data-milestone attribute' do
filter/references/milestone_reference_filter_spec.rb:      link = doc.css('a').first
filter/references/milestone_reference_filter_spec.rb:      expect(link).to have_attribute('data-milestone')
filter/references/milestone_reference_filter_spec.rb:      expect(link.attr('data-milestone')).to eq milestone.id.to_s
filter/references/milestone_reference_filter_spec.rb:    it 'supports an :only_path context' do
filter/references/milestone_reference_filter_spec.rb:      link = doc.css('a').first.attr('href')
filter/references/milestone_reference_filter_spec.rb:  shared_examples 'Integer-based references' do
filter/references/milestone_reference_filter_spec.rb:    it 'links to a valid reference' do
filter/references/milestone_reference_filter_spec.rb:      expect(doc.css('a').first.attr('href')).to eq urls.milestone_url(milestone)
filter/references/milestone_reference_filter_spec.rb:    it 'links with adjacent text' do
filter/references/milestone_reference_filter_spec.rb:    it 'ignores invalid milestone IIDs' do
filter/references/milestone_reference_filter_spec.rb:  shared_examples 'String-based single-word references' do
filter/references/milestone_reference_filter_spec.rb:      milestone.update!(name: 'gfm')
filter/references/milestone_reference_filter_spec.rb:    it 'links to a valid reference' do
filter/references/milestone_reference_filter_spec.rb:      expect(doc.css('a').first.attr('href')).to eq urls.milestone_url(milestone)
filter/references/milestone_reference_filter_spec.rb:    it 'links with adjacent text' do
filter/references/milestone_reference_filter_spec.rb:    it 'links with adjacent html tags' do
filter/references/milestone_reference_filter_spec.rb:    it 'ignores invalid milestone names' do
filter/references/milestone_reference_filter_spec.rb:  shared_examples 'String-based multi-word references in quotes' do
filter/references/milestone_reference_filter_spec.rb:      milestone.update!(name: 'gfm references')
filter/references/milestone_reference_filter_spec.rb:    it 'links to a valid reference' do
filter/references/milestone_reference_filter_spec.rb:      expect(doc.css('a').first.attr('href')).to eq urls.milestone_url(milestone)
filter/references/milestone_reference_filter_spec.rb:    it 'links with adjacent text' do
filter/references/milestone_reference_filter_spec.rb:    it 'ignores invalid milestone names' do
filter/references/milestone_reference_filter_spec.rb:  shared_examples 'referencing a milestone in a link href' do
filter/references/milestone_reference_filter_spec.rb:      milestone.update!(name: 'gfm')
filter/references/milestone_reference_filter_spec.rb:    it 'links to a valid reference' do
filter/references/milestone_reference_filter_spec.rb:      expect(doc.css('a').first.attr('href')).to eq urls.milestone_url(milestone)
filter/references/milestone_reference_filter_spec.rb:    it 'links with adjacent text' do
filter/references/milestone_reference_filter_spec.rb:    it 'includes a data-project attribute' do
filter/references/milestone_reference_filter_spec.rb:      link = doc.css('a').first
filter/references/milestone_reference_filter_spec.rb:        expect(link).to have_attribute('data-project')
filter/references/milestone_reference_filter_spec.rb:        expect(link.attr('data-project')).to eq project.id.to_s
filter/references/milestone_reference_filter_spec.rb:        expect(link).to have_attribute('data-group')
filter/references/milestone_reference_filter_spec.rb:        expect(link.attr('data-group')).to eq milestone.group.id.to_s
filter/references/milestone_reference_filter_spec.rb:    it 'includes a data-milestone attribute' do
filter/references/milestone_reference_filter_spec.rb:      link = doc.css('a').first
filter/references/milestone_reference_filter_spec.rb:      expect(link).to have_attribute('data-milestone')
filter/references/milestone_reference_filter_spec.rb:      expect(link.attr('data-milestone')).to eq milestone.id.to_s
filter/references/milestone_reference_filter_spec.rb:  shared_examples 'linking to a milestone as the entire link' do
filter/references/milestone_reference_filter_spec.rb:    it 'replaces the link text with the milestone reference' do
filter/references/milestone_reference_filter_spec.rb:      expect(doc.css('a').first.text).to eq(unquoted_reference)
filter/references/milestone_reference_filter_spec.rb:    it 'includes a data-project attribute' do
filter/references/milestone_reference_filter_spec.rb:      link = doc.css('a').first
filter/references/milestone_reference_filter_spec.rb:      expect(link).to have_attribute('data-project')
filter/references/milestone_reference_filter_spec.rb:      expect(link.attr('data-project')).to eq project.id.to_s
filter/references/milestone_reference_filter_spec.rb:    it 'includes a data-milestone attribute' do
filter/references/milestone_reference_filter_spec.rb:      link = doc.css('a').first
filter/references/milestone_reference_filter_spec.rb:      expect(link).to have_attribute('data-milestone')
filter/references/milestone_reference_filter_spec.rb:      expect(link.attr('data-milestone')).to eq milestone.id.to_s
filter/references/milestone_reference_filter_spec.rb:  shared_examples 'cross-project / cross-namespace complete reference' do
filter/references/milestone_reference_filter_spec.rb:    it 'points to referenced project milestone page' do
filter/references/milestone_reference_filter_spec.rb:      expect(result.css('a').first.attr('href')).to eq urls
filter/references/milestone_reference_filter_spec.rb:    it 'link has valid text' do
filter/references/milestone_reference_filter_spec.rb:      expect(doc.css('a').first.text)
filter/references/milestone_reference_filter_spec.rb:    it 'has valid text' do
filter/references/milestone_reference_filter_spec.rb:    it 'escapes the name attribute' do
filter/references/milestone_reference_filter_spec.rb:      expect(doc.css('a').first.text)
filter/references/milestone_reference_filter_spec.rb:  shared_examples 'cross-project / same-namespace complete reference' do
filter/references/milestone_reference_filter_spec.rb:    it 'points to referenced project milestone page' do
filter/references/milestone_reference_filter_spec.rb:      expect(result.css('a').first.attr('href')).to eq urls
filter/references/milestone_reference_filter_spec.rb:    it 'link has valid text' do
filter/references/milestone_reference_filter_spec.rb:      expect(doc.css('a').first.text)
filter/references/milestone_reference_filter_spec.rb:    it 'has valid text' do
filter/references/milestone_reference_filter_spec.rb:    it 'escapes the name attribute' do
filter/references/milestone_reference_filter_spec.rb:      expect(doc.css('a').first.text)
filter/references/milestone_reference_filter_spec.rb:  shared_examples 'cross project shorthand reference' do
filter/references/milestone_reference_filter_spec.rb:    it 'points to referenced project milestone page' do
filter/references/milestone_reference_filter_spec.rb:      expect(result.css('a').first.attr('href')).to eq urls
filter/references/milestone_reference_filter_spec.rb:    it 'link has valid text' do
filter/references/milestone_reference_filter_spec.rb:      expect(doc.css('a').first.text)
filter/references/milestone_reference_filter_spec.rb:    it 'has valid text' do
filter/references/milestone_reference_filter_spec.rb:    it 'escapes the name attribute' do
filter/references/milestone_reference_filter_spec.rb:      expect(doc.css('a').first.text)
filter/references/milestone_reference_filter_spec.rb:  shared_examples 'references with HTML entities' do
filter/references/milestone_reference_filter_spec.rb:      milestone.update!(title: '&lt;html&gt;')
filter/references/milestone_reference_filter_spec.rb:    it 'links to a valid reference' do
filter/references/milestone_reference_filter_spec.rb:      doc = reference_filter('See %"&lt;html&gt;"')
filter/references/milestone_reference_filter_spec.rb:      expect(doc.css('a').first.attr('href')).to eq urls.milestone_url(milestone)
filter/references/milestone_reference_filter_spec.rb:      expect(doc.text).to eq 'See %<html>'
filter/references/milestone_reference_filter_spec.rb:    it 'ignores invalid milestone names and escapes entities' do
filter/references/milestone_reference_filter_spec.rb:  shared_examples 'absolute references' do
filter/references/milestone_reference_filter_spec.rb:    it 'supports absolute reference' do
filter/references/milestone_reference_filter_spec.rb:      expect(result.css('a').first.attr('href')).to eq(urls.milestone_url(milestone))
filter/references/milestone_reference_filter_spec.rb:      expect(result.css('a').first.attr('data-original')).to eq absolute_reference
filter/references/milestone_reference_filter_spec.rb:  shared_context 'project milestones' do
filter/references/milestone_reference_filter_spec.rb:    include_examples 'reference parsing'
filter/references/milestone_reference_filter_spec.rb:    it_behaves_like 'Integer-based references'
filter/references/milestone_reference_filter_spec.rb:    it_behaves_like 'String-based single-word references'
filter/references/milestone_reference_filter_spec.rb:    it_behaves_like 'String-based multi-word references in quotes'
filter/references/milestone_reference_filter_spec.rb:    it_behaves_like 'referencing a milestone in a link href'
filter/references/milestone_reference_filter_spec.rb:    it_behaves_like 'linking to a milestone as the entire link'
filter/references/milestone_reference_filter_spec.rb:    it_behaves_like 'cross-project / cross-namespace complete reference'
filter/references/milestone_reference_filter_spec.rb:    it_behaves_like 'cross-project / same-namespace complete reference'
filter/references/milestone_reference_filter_spec.rb:    it_behaves_like 'cross project shorthand reference'
filter/references/milestone_reference_filter_spec.rb:    it_behaves_like 'references with HTML entities'
filter/references/milestone_reference_filter_spec.rb:    it_behaves_like 'HTML text with references' do
filter/references/milestone_reference_filter_spec.rb:    it_behaves_like 'absolute references' do
filter/references/milestone_reference_filter_spec.rb:  shared_context 'group milestones' do
filter/references/milestone_reference_filter_spec.rb:    include_examples 'reference parsing'
filter/references/milestone_reference_filter_spec.rb:    it_behaves_like 'String-based single-word references'
filter/references/milestone_reference_filter_spec.rb:    it_behaves_like 'String-based multi-word references in quotes'
filter/references/milestone_reference_filter_spec.rb:    it_behaves_like 'referencing a milestone in a link href'
filter/references/milestone_reference_filter_spec.rb:    it_behaves_like 'references with HTML entities'
filter/references/milestone_reference_filter_spec.rb:    it_behaves_like 'HTML text with references' do
filter/references/milestone_reference_filter_spec.rb:    it_behaves_like 'absolute references' do
filter/references/milestone_reference_filter_spec.rb:    it 'does not support references by IID' do
filter/references/milestone_reference_filter_spec.rb:      expect(doc.css('a')).to be_empty
filter/references/milestone_reference_filter_spec.rb:    it 'does not support references by link' do
filter/references/milestone_reference_filter_spec.rb:      expect(doc.css('a').first.text).to eq(urls.milestone_url(milestone))
filter/references/milestone_reference_filter_spec.rb:    it 'does not support cross-project references', :aggregate_failures do
filter/references/milestone_reference_filter_spec.rb:      expect(doc.css('a')).to be_empty
filter/references/milestone_reference_filter_spec.rb:    it 'supports parent group references' do
filter/references/milestone_reference_filter_spec.rb:      expect(doc.css('a').first.text).to eq(milestone.reference_link_text)
filter/references/milestone_reference_filter_spec.rb:  context 'group context' do
filter/references/milestone_reference_filter_spec.rb:    context 'when project milestone' do
filter/references/milestone_reference_filter_spec.rb:      it 'links to a valid reference' do
filter/references/milestone_reference_filter_spec.rb:        expect(result.css('a').first.attr('href')).to eq(urls.milestone_url(milestone))
filter/references/milestone_reference_filter_spec.rb:      it 'ignores internal references' do
filter/references/milestone_reference_filter_spec.rb:      it_behaves_like 'absolute references' do
filter/references/milestone_reference_filter_spec.rb:    context 'when group milestone' do
filter/references/milestone_reference_filter_spec.rb:      let(:group_milestone) { create(:milestone, title: 'group_milestone', group: group) }
filter/references/milestone_reference_filter_spec.rb:      context 'for subgroups' do
filter/references/milestone_reference_filter_spec.rb:        let(:sub_group_milestone) { create(:milestone, title: 'sub_group_milestone', group: sub_group) }
filter/references/milestone_reference_filter_spec.rb:        it 'links to valid references of subgroup and group milestones' do
filter/references/milestone_reference_filter_spec.rb:            expect(result.css('a').first.attr('href')).to eq(urls.milestone_url(milestone))
filter/references/milestone_reference_filter_spec.rb:        it 'links to valid absolute references of subgroup and group milestones' do
filter/references/milestone_reference_filter_spec.rb:            expect(result.css('a').first.attr('href')).to eq(urls.milestone_url(milestone))
filter/references/milestone_reference_filter_spec.rb:            expect(result.css('a').first.attr('data-original')).to eq reference
filter/references/milestone_reference_filter_spec.rb:      it 'ignores internal references' do
filter/references/milestone_reference_filter_spec.rb:    context 'when referencing both project and group milestones' do
filter/references/milestone_reference_filter_spec.rb:      let(:group_milestone) { create(:milestone, title: 'group_milestone', group: group) }
filter/references/milestone_reference_filter_spec.rb:      it 'links to valid references' do
filter/references/milestone_reference_filter_spec.rb:        links = reference_filter("See #{milestone.to_reference(full: true)} and #{group_milestone.to_reference}", context).css('a')
filter/references/milestone_reference_filter_spec.rb:        expect(links[0].attr('href')).to eq(urls.milestone_url(milestone))
filter/references/milestone_reference_filter_spec.rb:        expect(links[1].attr('href')).to eq(urls.milestone_url(group_milestone))
filter/references/milestone_reference_filter_spec.rb:    context 'when referencing both project and group milestones using absolute references' do
filter/references/milestone_reference_filter_spec.rb:      let(:group_milestone) { create(:milestone, title: 'group_milestone', group: project.group) }
filter/references/milestone_reference_filter_spec.rb:      it 'links to valid references' do
filter/references/milestone_reference_filter_spec.rb:        links = doc.css('a')
filter/references/milestone_reference_filter_spec.rb:        expect(links[0].attr('href')).to eq(urls.milestone_url(milestone))
filter/references/milestone_reference_filter_spec.rb:        expect(links[1].attr('href')).to eq(urls.milestone_url(group_milestone))
filter/references/milestone_reference_filter_spec.rb:    context 'when referencing both group and subgroup milestones using absolute references' do
filter/references/milestone_reference_filter_spec.rb:      let(:group_milestone) { create(:milestone, title: 'group_milestone', group: group) }
filter/references/milestone_reference_filter_spec.rb:      let(:subgroup_milestone) { create(:milestone, title: 'subgroup_milestone', group: subgroup) }
filter/references/milestone_reference_filter_spec.rb:      it 'links to valid references' do
filter/references/milestone_reference_filter_spec.rb:        links = doc.css('a')
filter/references/milestone_reference_filter_spec.rb:        expect(links[0].attr('href')).to eq(urls.milestone_url(group_milestone))
filter/references/milestone_reference_filter_spec.rb:        expect(links[1].attr('href')).to eq(urls.milestone_url(subgroup_milestone))
filter/references/milestone_reference_filter_spec.rb:  context 'when milestone is open' do
filter/references/milestone_reference_filter_spec.rb:    context 'project milestones' do
filter/references/milestone_reference_filter_spec.rb:      include_context 'project milestones'
filter/references/milestone_reference_filter_spec.rb:    context 'group milestones' do
filter/references/milestone_reference_filter_spec.rb:      include_context 'group milestones'
filter/references/milestone_reference_filter_spec.rb:  context 'when milestone is closed' do
filter/references/milestone_reference_filter_spec.rb:    context 'project milestones' do
filter/references/milestone_reference_filter_spec.rb:      include_context 'project milestones'
filter/references/milestone_reference_filter_spec.rb:    context 'group milestones' do
filter/references/milestone_reference_filter_spec.rb:      include_context 'group milestones'
filter/references/milestone_reference_filter_spec.rb:  context 'checking N+1' do
filter/references/milestone_reference_filter_spec.rb:    it 'does not have N+1 per multiple references per project', :use_sql_query_cache do
filter/references/milestone_reference_filter_spec.rb:    it 'has N+1 for multiple unique project/group references', :use_sql_query_cache do
filter/references/milestone_reference_filter_spec.rb:      # Since we're not batching milestone queries across projects/groups,
filter/references/label_reference_filter_spec.rb:require 'spec_helper'
filter/references/label_reference_filter_spec.rb:require 'html/pipeline'
filter/references/label_reference_filter_spec.rb:  let(:project)   { create(:project, :public, name: 'sample-project') }
filter/references/label_reference_filter_spec.rb:  it_behaves_like 'HTML text with references' do
filter/references/label_reference_filter_spec.rb:  it 'requires project context' do
filter/references/label_reference_filter_spec.rb:    expect { described_class.call('') }.to raise_error(ArgumentError, /:project/)
filter/references/label_reference_filter_spec.rb:    it "ignores valid references contained inside '#{elem}' element" do
filter/references/label_reference_filter_spec.rb:  it 'includes default classes' do
filter/references/label_reference_filter_spec.rb:    expect(doc.css('a').first.attr('class')).to eq 'gfm gfm-label has-tooltip gl-link gl-label-link'
filter/references/label_reference_filter_spec.rb:  it 'avoids N+1 cached queries', :use_sql_query_cache, :request_store do
filter/references/label_reference_filter_spec.rb:    labels_markdown = Array.new(10, "Label #{reference}").join('\n')
filter/references/label_reference_filter_spec.rb:  it 'includes a data-project attribute' do
filter/references/label_reference_filter_spec.rb:    link = doc.css('a').first
filter/references/label_reference_filter_spec.rb:    expect(link).to have_attribute('data-project')
filter/references/label_reference_filter_spec.rb:    expect(link.attr('data-project')).to eq project.id.to_s
filter/references/label_reference_filter_spec.rb:  it 'includes a data-label attribute' do
filter/references/label_reference_filter_spec.rb:    link = doc.css('a').first
filter/references/label_reference_filter_spec.rb:    expect(link).to have_attribute('data-label')
filter/references/label_reference_filter_spec.rb:    expect(link.attr('data-label')).to eq label.id.to_s
filter/references/label_reference_filter_spec.rb:  it 'includes protocol when :only_path not present' do
filter/references/label_reference_filter_spec.rb:    link = doc.css('a').first.attr('href')
filter/references/label_reference_filter_spec.rb:  it 'does not include protocol when :only_path true' do
filter/references/label_reference_filter_spec.rb:    link = doc.css('a').first.attr('href')
filter/references/label_reference_filter_spec.rb:  it 'links to issue list when :label_url_method is not present' do
filter/references/label_reference_filter_spec.rb:    link = doc.css('a').first.attr('href')
filter/references/label_reference_filter_spec.rb:  it 'links to merge request list when `label_url_method: :project_merge_requests_url`' do
filter/references/label_reference_filter_spec.rb:    link = doc.css('a').first.attr('href')
filter/references/label_reference_filter_spec.rb:  context 'project that does not exist referenced' do
filter/references/label_reference_filter_spec.rb:    let(:result) { reference_filter('See aaa/bbb~ccc') }
filter/references/label_reference_filter_spec.rb:    it 'does not link reference' do
filter/references/label_reference_filter_spec.rb:      expect(result.to_html).to include 'See aaa/bbb~ccc'
filter/references/label_reference_filter_spec.rb:  describe 'label span element' do
filter/references/label_reference_filter_spec.rb:    it 'includes default classes' do
filter/references/label_reference_filter_spec.rb:      expect(doc.css('a span').first.attr('class')).to include 'gl-label-text'
filter/references/label_reference_filter_spec.rb:    it 'includes a style attribute' do
filter/references/label_reference_filter_spec.rb:      expect(doc.css('a span').first.attr('style')).to match(/\Abackground-color: #\h{6}\z/)
filter/references/label_reference_filter_spec.rb:  context 'Integer-based references' do
filter/references/label_reference_filter_spec.rb:    it 'links to a valid reference' do
filter/references/label_reference_filter_spec.rb:      expect(doc.css('a').first.attr('href')).to eq urls
filter/references/label_reference_filter_spec.rb:    it 'links with adjacent text' do
filter/references/label_reference_filter_spec.rb:    it 'ignores invalid label IDs' do
filter/references/label_reference_filter_spec.rb:  context 'String-based single-word references' do
filter/references/label_reference_filter_spec.rb:    let(:label)     { create(:label, name: 'gfm', project: project) }
filter/references/label_reference_filter_spec.rb:    it 'links to a valid reference' do
filter/references/label_reference_filter_spec.rb:      expect(doc.css('a').first.attr('href')).to eq urls
filter/references/label_reference_filter_spec.rb:      expect(doc.text).to eq 'See gfm'
filter/references/label_reference_filter_spec.rb:    it 'links with adjacent text' do
filter/references/label_reference_filter_spec.rb:    it 'ignores invalid label names' do
filter/references/label_reference_filter_spec.rb:  context 'String-based single-word references that begin with a digit' do
filter/references/label_reference_filter_spec.rb:    let(:label)     { create(:label, name: '2fa', project: project) }
filter/references/label_reference_filter_spec.rb:    it 'links to a valid reference' do
filter/references/label_reference_filter_spec.rb:      expect(doc.css('a').first.attr('href')).to eq urls
filter/references/label_reference_filter_spec.rb:      expect(doc.text).to eq 'See 2fa'
filter/references/label_reference_filter_spec.rb:    it 'links with adjacent text' do
filter/references/label_reference_filter_spec.rb:    it 'ignores invalid label names' do
filter/references/label_reference_filter_spec.rb:  context 'String-based single-word references with special characters' do
filter/references/label_reference_filter_spec.rb:    let(:label)     { create(:label, name: '?g.fm&', project: project) }
filter/references/label_reference_filter_spec.rb:    it 'links to a valid reference' do
filter/references/label_reference_filter_spec.rb:      expect(doc.css('a').first.attr('href')).to eq urls
filter/references/label_reference_filter_spec.rb:      expect(doc.text).to eq 'See ?g.fm&'
filter/references/label_reference_filter_spec.rb:    it 'does not include trailing punctuation', :aggregate_failures do
filter/references/label_reference_filter_spec.rb:      ['.', ', ok?', '...', '?', '!', ': is that ok?'].each do |trailing_punctuation|
filter/references/label_reference_filter_spec.rb:    it 'ignores invalid label names' do
filter/references/label_reference_filter_spec.rb:  context 'String-based multi-word references in quotes' do
filter/references/label_reference_filter_spec.rb:    let(:label)     { create(:label, name: 'gfm references', project: project) }
filter/references/label_reference_filter_spec.rb:    it 'links to a valid reference' do
filter/references/label_reference_filter_spec.rb:      expect(doc.css('a').first.attr('href')).to eq urls
filter/references/label_reference_filter_spec.rb:      expect(doc.text).to eq 'See gfm references'
filter/references/label_reference_filter_spec.rb:    it 'links with adjacent text' do
filter/references/label_reference_filter_spec.rb:    it 'ignores invalid label names' do
filter/references/label_reference_filter_spec.rb:  context 'String-based multi-word references that begin with a digit' do
filter/references/label_reference_filter_spec.rb:    let(:label)     { create(:label, name: '2 factor authentication', project: project) }
filter/references/label_reference_filter_spec.rb:    it 'links to a valid reference' do
filter/references/label_reference_filter_spec.rb:      expect(doc.css('a').first.attr('href')).to eq urls
filter/references/label_reference_filter_spec.rb:      expect(doc.text).to eq 'See 2 factor authentication'
filter/references/label_reference_filter_spec.rb:    it 'links with adjacent text' do
filter/references/label_reference_filter_spec.rb:    it 'ignores invalid label names' do
filter/references/label_reference_filter_spec.rb:  context 'String-based multi-word references with special characters in quotes' do
filter/references/label_reference_filter_spec.rb:    let(:label)     { create(:label, name: 'g.fm & references?', project: project) }
filter/references/label_reference_filter_spec.rb:    it 'links to a valid reference' do
filter/references/label_reference_filter_spec.rb:      expect(doc.css('a').first.attr('href')).to eq urls
filter/references/label_reference_filter_spec.rb:      expect(doc.text).to eq 'See g.fm & references?'
filter/references/label_reference_filter_spec.rb:    it 'links with adjacent text' do
filter/references/label_reference_filter_spec.rb:    it 'ignores invalid label names' do
filter/references/label_reference_filter_spec.rb:  context 'References with html entities' do
filter/references/label_reference_filter_spec.rb:    let!(:label) { create(:label, title: '&lt;html&gt;', project: project) }
filter/references/label_reference_filter_spec.rb:    it 'links to a valid reference' do
filter/references/label_reference_filter_spec.rb:      doc = reference_filter('See ~"&lt;html&gt;"')
filter/references/label_reference_filter_spec.rb:      expect(doc.css('a').first.attr('href')).to eq urls
filter/references/label_reference_filter_spec.rb:      expect(doc.text).to eq 'See <html>'
filter/references/label_reference_filter_spec.rb:    it 'ignores invalid label names and escapes entities' do
filter/references/label_reference_filter_spec.rb:  describe 'consecutive references' do
filter/references/label_reference_filter_spec.rb:    let(:bug) { create(:label, name: 'bug', project: project) }
filter/references/label_reference_filter_spec.rb:    let(:feature_proposal) { create(:label, name: 'feature proposal', project: project) }
filter/references/label_reference_filter_spec.rb:    let(:technical_debt) { create(:label, name: 'technical debt', project: project) }
filter/references/label_reference_filter_spec.rb:    context 'separated with a comma' do
filter/references/label_reference_filter_spec.rb:      it 'links to valid references' do
filter/references/label_reference_filter_spec.rb:        expect(doc.css('a').map { |a| a.attr('href') }).to match_array(
filter/references/label_reference_filter_spec.rb:        expect(doc.text).to eq 'See bug, feature proposal, technical debt'
filter/references/label_reference_filter_spec.rb:    context 'separated with a space' do
filter/references/label_reference_filter_spec.rb:      it 'links to valid references' do
filter/references/label_reference_filter_spec.rb:        expect(doc.css('a').map { |a| a.attr('href') }).to match_array(
filter/references/label_reference_filter_spec.rb:        expect(doc.text).to eq 'See bug feature proposal technical debt'
filter/references/label_reference_filter_spec.rb:  describe 'edge cases' do
filter/references/label_reference_filter_spec.rb:    it 'gracefully handles non-references matching the pattern' do
filter/references/label_reference_filter_spec.rb:      act = '(format nil "~0f" 3.0) ; 3.0'
filter/references/label_reference_filter_spec.rb:  describe 'referencing a label in a link href' do
filter/references/label_reference_filter_spec.rb:    it 'links to a valid reference' do
filter/references/label_reference_filter_spec.rb:      expect(doc.css('a').first.attr('href')).to eq urls
filter/references/label_reference_filter_spec.rb:    it 'links with adjacent text' do
filter/references/label_reference_filter_spec.rb:    it 'includes a data-project attribute' do
filter/references/label_reference_filter_spec.rb:      link = doc.css('a').first
filter/references/label_reference_filter_spec.rb:      expect(link).to have_attribute('data-project')
filter/references/label_reference_filter_spec.rb:      expect(link.attr('data-project')).to eq project.id.to_s
filter/references/label_reference_filter_spec.rb:    it 'includes a data-label attribute' do
filter/references/label_reference_filter_spec.rb:      link = doc.css('a').first
filter/references/label_reference_filter_spec.rb:      expect(link).to have_attribute('data-label')
filter/references/label_reference_filter_spec.rb:      expect(link.attr('data-label')).to eq label.id.to_s
filter/references/label_reference_filter_spec.rb:  describe 'group label references' do
filter/references/label_reference_filter_spec.rb:    let(:group_label) { create(:group_label, name: 'gfm references', group: group) }
filter/references/label_reference_filter_spec.rb:    context 'without project reference' do
filter/references/label_reference_filter_spec.rb:      it 'links to a valid reference' do
filter/references/label_reference_filter_spec.rb:        expect(doc.css('a').first.attr('href')).to eq urls
filter/references/label_reference_filter_spec.rb:        expect(doc.text).to eq 'See gfm references'
filter/references/label_reference_filter_spec.rb:      it 'links with adjacent text' do
filter/references/label_reference_filter_spec.rb:      it 'ignores invalid label names' do
filter/references/label_reference_filter_spec.rb:    context 'with project reference' do
filter/references/label_reference_filter_spec.rb:      it 'links to a valid reference' do
filter/references/label_reference_filter_spec.rb:        expect(doc.css('a').first.attr('href')).to eq urls
filter/references/label_reference_filter_spec.rb:      it 'links with adjacent text' do
filter/references/label_reference_filter_spec.rb:      it 'ignores invalid label names' do
filter/references/label_reference_filter_spec.rb:  describe 'cross-project / cross-namespace complete reference' do
filter/references/label_reference_filter_spec.rb:    let(:label)     { create(:label, project: project2, color: '#00ff00') }
filter/references/label_reference_filter_spec.rb:    it 'links to a valid reference' do
filter/references/label_reference_filter_spec.rb:      expect(result.css('a').first.attr('href'))
filter/references/label_reference_filter_spec.rb:    it 'has valid color' do
filter/references/label_reference_filter_spec.rb:      expect(result.css('a span').first.attr('style')).to match(/background-color: #00ff00/)
filter/references/label_reference_filter_spec.rb:    it 'has valid link text' do
filter/references/label_reference_filter_spec.rb:      expect(result.css('a').first.text).to eq "#{label.name} in #{project2.full_name}"
filter/references/label_reference_filter_spec.rb:    it 'has valid text' do
filter/references/label_reference_filter_spec.rb:    it 'ignores invalid IDs on the referenced label' do
filter/references/label_reference_filter_spec.rb:  describe 'cross-project / same-namespace complete reference' do
filter/references/label_reference_filter_spec.rb:    let(:label)     { create(:label, project: project2, color: '#00ff00') }
filter/references/label_reference_filter_spec.rb:    it 'links to a valid reference' do
filter/references/label_reference_filter_spec.rb:      expect(result.css('a').first.attr('href'))
filter/references/label_reference_filter_spec.rb:    it 'has valid color' do
filter/references/label_reference_filter_spec.rb:      expect(result.css('a span').first.attr('style')).to match(/background-color: #00ff00/)
filter/references/label_reference_filter_spec.rb:    it 'has valid link text' do
filter/references/label_reference_filter_spec.rb:      expect(result.css('a').first.text).to eq "#{label.name} in #{project2.name}"
filter/references/label_reference_filter_spec.rb:    it 'has valid text' do
filter/references/label_reference_filter_spec.rb:    it 'ignores invalid IDs on the referenced label' do
filter/references/label_reference_filter_spec.rb:  describe 'cross-project shorthand reference' do
filter/references/label_reference_filter_spec.rb:    let(:label)     { create(:label, project: project2, color: '#00ff00') }
filter/references/label_reference_filter_spec.rb:    it 'links to a valid reference' do
filter/references/label_reference_filter_spec.rb:      expect(result.css('a').first.attr('href'))
filter/references/label_reference_filter_spec.rb:    it 'has valid color' do
filter/references/label_reference_filter_spec.rb:      expect(result.css('a span').first.attr('style'))
filter/references/label_reference_filter_spec.rb:    it 'has valid link text' do
filter/references/label_reference_filter_spec.rb:      expect(result.css('a').first.text).to eq "#{label.name} in #{project2.name}"
filter/references/label_reference_filter_spec.rb:    it 'has valid text' do
filter/references/label_reference_filter_spec.rb:    it 'ignores invalid IDs on the referenced label' do
filter/references/label_reference_filter_spec.rb:  describe 'cross group label references' do
filter/references/label_reference_filter_spec.rb:    let(:group_label)      { create(:group_label, group: another_group, color: '#00ff00') }
filter/references/label_reference_filter_spec.rb:    it 'points to referenced project issues page' do
filter/references/label_reference_filter_spec.rb:      expect(result.css('a').first.attr('href'))
filter/references/label_reference_filter_spec.rb:    it 'has valid color' do
filter/references/label_reference_filter_spec.rb:      expect(result.css('a span').first.attr('style'))
filter/references/label_reference_filter_spec.rb:    it 'has valid link text' do
filter/references/label_reference_filter_spec.rb:      expect(result.css('a').first.text)
filter/references/label_reference_filter_spec.rb:    it 'has valid text' do
filter/references/label_reference_filter_spec.rb:    it 'ignores invalid IDs on the referenced label' do
filter/references/label_reference_filter_spec.rb:    context 'when group name has HTML entities' do
filter/references/label_reference_filter_spec.rb:      let(:another_group) { create(:group, name: 'random', path: 'another_group') }
filter/references/label_reference_filter_spec.rb:      it 'escapes the HTML entities' do
filter/references/label_reference_filter_spec.rb:  describe 'cross-project / same-group_label complete reference' do
filter/references/label_reference_filter_spec.rb:    let(:group_label)      { create(:group_label, group: group, color: '#00ff00') }
filter/references/label_reference_filter_spec.rb:    it 'points to referenced project issues page' do
filter/references/label_reference_filter_spec.rb:      expect(result.css('a').first.attr('href'))
filter/references/label_reference_filter_spec.rb:    it 'has valid color' do
filter/references/label_reference_filter_spec.rb:      expect(result.css('a span').first.attr('style'))
filter/references/label_reference_filter_spec.rb:    it 'has valid link text' do
filter/references/label_reference_filter_spec.rb:      expect(result.css('a').first.text)
filter/references/label_reference_filter_spec.rb:    it 'has valid text' do
filter/references/label_reference_filter_spec.rb:    it 'ignores invalid IDs on the referenced label' do
filter/references/label_reference_filter_spec.rb:  describe 'same project / same group_label complete reference' do
filter/references/label_reference_filter_spec.rb:    let(:group_label) { create(:group_label, group: group, color: '#00ff00') }
filter/references/label_reference_filter_spec.rb:    it 'points to referenced project issues page' do
filter/references/label_reference_filter_spec.rb:      expect(result.css('a').first.attr('href'))
filter/references/label_reference_filter_spec.rb:    it 'has valid color' do
filter/references/label_reference_filter_spec.rb:      expect(result.css('a span').first.attr('style'))
filter/references/label_reference_filter_spec.rb:    it 'has valid link text' do
filter/references/label_reference_filter_spec.rb:      expect(result.css('a').first.text).to eq group_label.name
filter/references/label_reference_filter_spec.rb:    it 'has valid text' do
filter/references/label_reference_filter_spec.rb:    it 'ignores invalid IDs on the referenced label' do
filter/references/label_reference_filter_spec.rb:  describe 'same project / same group_label shorthand reference' do
filter/references/label_reference_filter_spec.rb:    let(:group_label) { create(:group_label, group: group, color: '#00ff00') }
filter/references/label_reference_filter_spec.rb:    it 'points to referenced project issues page' do
filter/references/label_reference_filter_spec.rb:      expect(result.css('a').first.attr('href'))
filter/references/label_reference_filter_spec.rb:    it 'has valid color' do
filter/references/label_reference_filter_spec.rb:      expect(result.css('a span').first.attr('style'))
filter/references/label_reference_filter_spec.rb:    it 'has valid link text' do
filter/references/label_reference_filter_spec.rb:      expect(result.css('a').first.text).to eq group_label.name
filter/references/label_reference_filter_spec.rb:    it 'has valid text' do
filter/references/label_reference_filter_spec.rb:    it 'ignores invalid IDs on the referenced label' do
filter/references/label_reference_filter_spec.rb:  describe 'group context' do
filter/references/label_reference_filter_spec.rb:    it 'points to the page defined in label_url_method' do
filter/references/label_reference_filter_spec.rb:      expect(result.css('a').first.attr('href')).to eq(urls.group_url(group, label_name: label.name))
filter/references/label_reference_filter_spec.rb:    it 'finds labels also in ancestor groups' do
filter/references/label_reference_filter_spec.rb:      expect(result.css('a').first.attr('href')).to eq(urls.group_url(subgroup, label_name: label.name))
filter/references/label_reference_filter_spec.rb:    it 'points to referenced project issues page' do
filter/references/label_reference_filter_spec.rb:      expect(result.css('a').first.attr('href')).to eq(urls.project_issues_url(project, label_name: label.name))
filter/references/label_reference_filter_spec.rb:      expect(result.css('a').first.text).to eq "#{label.name} in #{project.full_name}"
filter/references/label_reference_filter_spec.rb:  shared_examples 'absolute group reference' do
filter/references/label_reference_filter_spec.rb:    it 'supports absolute reference' do
filter/references/label_reference_filter_spec.rb:        expect(result.css('a').first.attr('href')).to eq(urls.group_url(group, label_name: group_label.name))
filter/references/label_reference_filter_spec.rb:        expect(result.css('a').first.attr('href')).to eq(urls.issues_group_url(group, label_name: group_label.name))
filter/references/label_reference_filter_spec.rb:      expect(result.css('a').first.attr('data-original')).to eq absolute_reference
filter/references/label_reference_filter_spec.rb:  shared_examples 'absolute project reference' do
filter/references/label_reference_filter_spec.rb:    it 'supports absolute reference' do
filter/references/label_reference_filter_spec.rb:        expect(result.css('a').first.attr('href')).to eq(urls.project_merge_requests_url(project, label_name: project_label.name))
filter/references/label_reference_filter_spec.rb:        expect(result.css('a').first.attr('href')).to eq(urls.project_issues_url(project, label_name: project_label.name))
filter/references/label_reference_filter_spec.rb:      expect(result.css('a').first.attr('data-original')).to eq absolute_reference
filter/references/label_reference_filter_spec.rb:  describe 'absolute label references' do
filter/references/label_reference_filter_spec.rb:    context 'with a project label' do
filter/references/label_reference_filter_spec.rb:      it_behaves_like 'absolute project reference' do
filter/references/label_reference_filter_spec.rb:      it_behaves_like 'absolute project reference' do
filter/references/label_reference_filter_spec.rb:    context 'with a group label' do
filter/references/label_reference_filter_spec.rb:      it_behaves_like 'absolute group reference' do
filter/references/label_reference_filter_spec.rb:      it_behaves_like 'absolute group reference' do
filter/references/label_reference_filter_spec.rb:    describe 'cross-project absolute reference' do
filter/references/label_reference_filter_spec.rb:      it_behaves_like 'absolute project reference' do
filter/references/label_reference_filter_spec.rb:      it 'does not find label in ancestors' do
filter/references/label_reference_filter_spec.rb:    describe 'cross-group absolute reference' do
filter/references/label_reference_filter_spec.rb:      it 'can not find the label' do
filter/references/label_reference_filter_spec.rb:      it 'finds the label with relative reference' do
filter/references/label_reference_filter_spec.rb:          expect(result.css('a').first.attr('href')).to eq(urls.group_url(group, label_name: label_name))
filter/references/label_reference_filter_spec.rb:          expect(result.css('a').first.attr('href')).to eq(urls.issues_group_url(group, label_name: label_name))
filter/references/label_reference_filter_spec.rb:      it 'finds label in ancestors' do
filter/references/label_reference_filter_spec.rb:          expect(result.css('a').first.attr('href')).to eq(urls.group_url(group, label_name: label_name))
filter/references/label_reference_filter_spec.rb:          expect(result.css('a').first.attr('href')).to eq(urls.issues_group_url(group, label_name: label_name))
filter/references/label_reference_filter_spec.rb:      it 'does not find label in ancestors' do
filter/references/label_reference_filter_spec.rb:      it_behaves_like 'absolute group reference' do
filter/references/label_reference_filter_spec.rb:  context 'checking N+1' do
filter/references/label_reference_filter_spec.rb:    let_it_be(:group2_label)       { create(:group_label, group: group2, color: '#00ff00') }
filter/references/label_reference_filter_spec.rb:    it 'does not have N+1 per multiple references per project', :use_sql_query_cache do
filter/references/label_reference_filter_spec.rb:    it 'has N+1 for multiple unique project/group references', :use_sql_query_cache do
filter/references/label_reference_filter_spec.rb:      # Since we're not batching label queries across projects/groups,
filter/references/reference_filter_spec.rb:require 'spec_helper'
filter/references/reference_filter_spec.rb:  describe '#each_node' do
filter/references/reference_filter_spec.rb:    it 'iterates over the nodes in a document' do
filter/references/reference_filter_spec.rb:      document = Nokogiri::HTML.fragment('<a href="foo">foo</a>')
filter/references/reference_filter_spec.rb:    it 'returns an Enumerator when no block is given' do
filter/references/reference_filter_spec.rb:      document = Nokogiri::HTML.fragment('<a href="foo">foo</a>')
filter/references/reference_filter_spec.rb:    it 'skips links with a "gfm" class' do
filter/references/reference_filter_spec.rb:      document = Nokogiri::HTML.fragment('<a href="foo" class="gfm">foo</a>')
filter/references/reference_filter_spec.rb:    it 'skips text nodes in pre elements' do
filter/references/reference_filter_spec.rb:      document = Nokogiri::HTML.fragment('<pre>foo</pre>')
filter/references/reference_filter_spec.rb:    it 'skips text nodes in inline diff elements' do
filter/references/reference_filter_spec.rb:      document = Nokogiri::HTML.fragment('<span class="idiff">foo</span>')
filter/references/reference_filter_spec.rb:  describe '#nodes' do
filter/references/reference_filter_spec.rb:    it 'returns an Array of the HTML nodes' do
filter/references/reference_filter_spec.rb:      document = Nokogiri::HTML.fragment('<a href="foo">foo</a>')
filter/references/reference_filter_spec.rb:  RSpec.shared_context 'document nodes' do
filter/references/reference_filter_spec.rb:    let(:document) { Nokogiri::HTML.fragment('<p data-sourcepos="1:1-1:18"></p>') }
filter/references/reference_filter_spec.rb:  RSpec.shared_context 'new nodes' do
filter/references/reference_filter_spec.rb:  RSpec.shared_examples 'replaces text' do |method_name, index|
filter/references/reference_filter_spec.rb:    context 'when content didnt change' do
filter/references/reference_filter_spec.rb:      it 'does not replace link node with html' do
filter/references/reference_filter_spec.rb:    context 'when link node has changed' do
filter/references/reference_filter_spec.rb:      it 'replaces reference node' do
filter/references/reference_filter_spec.rb:        expect(document.css('a').length).to eq 1
filter/references/reference_filter_spec.rb:      it 'calls replace_and_update_new_nodes' do
filter/references/reference_filter_spec.rb:      it 'stores filtered new nodes' do
filter/references/reference_filter_spec.rb:  RSpec.shared_examples 'replaces document node' do |method_name|
filter/references/reference_filter_spec.rb:    context 'when parent has only one node' do
filter/references/reference_filter_spec.rb:      it_behaves_like 'replaces text', method_name, 0
filter/references/reference_filter_spec.rb:    context 'when parent has multiple nodes' do
filter/references/reference_filter_spec.rb:      let(:node1) { Nokogiri::HTML.fragment('<span>span text</span>') }
filter/references/reference_filter_spec.rb:      let(:node2) { Nokogiri::HTML.fragment('<span>text</span>') }
filter/references/reference_filter_spec.rb:      context 'when pattern matches in the first node' do
filter/references/reference_filter_spec.rb:        it_behaves_like 'replaces text', method_name, 0
filter/references/reference_filter_spec.rb:      context 'when pattern matches in the middle node' do
filter/references/reference_filter_spec.rb:        it_behaves_like 'replaces text', method_name, 1
filter/references/reference_filter_spec.rb:      context 'when pattern matches in the last node' do
filter/references/reference_filter_spec.rb:        it_behaves_like 'replaces text', method_name, 2
filter/references/reference_filter_spec.rb:  describe '#replace_text_when_pattern_matches' do
filter/references/reference_filter_spec.rb:    include_context 'document nodes'
filter/references/reference_filter_spec.rb:    let(:node) { Nokogiri::HTML.fragment('text @reference') }
filter/references/reference_filter_spec.rb:    context 'when node has no reference pattern' do
filter/references/reference_filter_spec.rb:      let(:node) { Nokogiri::HTML.fragment('random text') }
filter/references/reference_filter_spec.rb:      it 'skips node' do
filter/references/reference_filter_spec.rb:    it_behaves_like 'replaces document node', :replace_text_when_pattern_matches do
filter/references/reference_filter_spec.rb:  describe '#replace_link_node_with_text' do
filter/references/reference_filter_spec.rb:    include_context 'document nodes'
filter/references/reference_filter_spec.rb:    let(:node) { Nokogiri::HTML.fragment('<a>end text</a>') }
filter/references/reference_filter_spec.rb:    it_behaves_like 'replaces document node', :replace_link_node_with_text do
filter/references/reference_filter_spec.rb:  describe '#replace_link_node_with_href' do
filter/references/reference_filter_spec.rb:    include_context 'document nodes'
filter/references/reference_filter_spec.rb:    let(:node) { Nokogiri::HTML.fragment('<a href="link">end text</a>') }
filter/references/reference_filter_spec.rb:    let(:href_link) { CGI.unescape(node.attr('href').to_s) }
filter/references/reference_filter_spec.rb:    it_behaves_like 'replaces document node', :replace_link_node_with_href do
filter/references/reference_filter_spec.rb:  describe '#call_and_update_nodes' do
filter/references/reference_filter_spec.rb:    include_context 'new nodes'
filter/references/reference_filter_spec.rb:    let(:document) { Nokogiri::HTML.fragment('<a href="foo">foo</a>') }
filter/references/reference_filter_spec.rb:    it 'updates all new nodes', :aggregate_failures do
filter/references/reference_filter_spec.rb:  describe '.call' do
filter/references/reference_filter_spec.rb:    include_context 'new nodes'
filter/references/reference_filter_spec.rb:    let(:document) { Nokogiri::HTML.fragment('<a href="foo">foo</a>') }
filter/references/reference_filter_spec.rb:    it 'updates all nodes', :aggregate_failures do
filter/references/reference_filter_spec.rb:  describe '.nodes?' do
filter/references/reference_filter_spec.rb:    let_it_be(:document) { Nokogiri::HTML.fragment('<a href="foo">foo</a>') }
filter/references/reference_filter_spec.rb:    it 'returns false when nodes are not loaded' do
filter/references/reference_filter_spec.rb:    it 'returns true when nodes are loaded' do
filter/references/reference_filter_spec.rb:  context 'abstract methods' do
filter/references/reference_filter_spec.rb:    let(:document) { Nokogiri::HTML.fragment('<a href="foo">foo</a>') }
filter/references/reference_filter_spec.rb:    describe '#references_in' do
filter/references/reference_filter_spec.rb:      it 'raises NotImplementedError' do
filter/references/reference_filter_spec.rb:        expect { filter.references_in('foo', %r{(?<!\w)}) }.to raise_error(NotImplementedError)
filter/references/reference_filter_spec.rb:    describe '#object_link_filter' do
filter/references/reference_filter_spec.rb:      it 'raises NotImplementedError' do
filter/references/reference_filter_spec.rb:        expect { filter.send(:object_link_filter, 'foo', %r{(?<!\w)}) }.to raise_error(NotImplementedError)
filter/references/reference_filter_spec.rb:  it_behaves_like 'pipeline timing check', context: { project: nil }
filter/references/design_reference_filter_spec.rb:require 'spec_helper'
filter/references/design_reference_filter_spec.rb:  shared_examples 'a no-op filter' do
filter/references/design_reference_filter_spec.rb:    it 'does nothing' do
filter/references/design_reference_filter_spec.rb:  shared_examples 'a good link reference' do
filter/references/design_reference_filter_spec.rb:    let(:link) { doc.css('a').first }
filter/references/design_reference_filter_spec.rb:    it 'produces a good link', :aggregate_failures do
filter/references/design_reference_filter_spec.rb:      expect(link.attr('href')).to eq(href)
filter/references/design_reference_filter_spec.rb:      expect(link.attr('title')).to eq(title)
filter/references/design_reference_filter_spec.rb:      expect(link.attr('class')).to eq('gfm gfm-design has-tooltip')
filter/references/design_reference_filter_spec.rb:      expect(link.attr('data-project')).to eq(design.project.id.to_s)
filter/references/design_reference_filter_spec.rb:      expect(link.attr('data-issue')).to eq(design.issue.id.to_s)
filter/references/design_reference_filter_spec.rb:      expect(link.attr('data-original')).to eq(href)
filter/references/design_reference_filter_spec.rb:      expect(link.attr('data-reference-type')).to eq('design')
filter/references/design_reference_filter_spec.rb:  describe '.call' do
filter/references/design_reference_filter_spec.rb:    it 'requires project context' do
filter/references/design_reference_filter_spec.rb:      expect { described_class.call('') }.to raise_error(ArgumentError, /:project/)
filter/references/design_reference_filter_spec.rb:  it 'does not error when we add redaction to the pipeline' do
filter/references/design_reference_filter_spec.rb:    expect(res.css('a').first).to be_present
filter/references/design_reference_filter_spec.rb:  describe '#call' do
filter/references/design_reference_filter_spec.rb:    describe 'feature flags' do
filter/references/design_reference_filter_spec.rb:      context 'design management is not enabled' do
filter/references/design_reference_filter_spec.rb:        it_behaves_like 'a no-op filter'
filter/references/design_reference_filter_spec.rb:      it_behaves_like 'a no-op filter'
filter/references/design_reference_filter_spec.rb:  it_behaves_like 'a no-op filter' do
filter/references/design_reference_filter_spec.rb:  describe '.identifier' do
filter/references/design_reference_filter_spec.rb:        ['simple.png'],
filter/references/design_reference_filter_spec.rb:        ['SIMPLE.PNG'],
filter/references/design_reference_filter_spec.rb:        ['has-hyphen.jpg'],
filter/references/design_reference_filter_spec.rb:        ['snake_case.svg']
filter/references/design_reference_filter_spec.rb:        described_class.new('', project: nil).identifier(m) if m
filter/references/design_reference_filter_spec.rb:      it 'can parse the reference' do
filter/references/design_reference_filter_spec.rb:  describe 'static properties' do
filter/references/design_reference_filter_spec.rb:      expect(described_class.new('', project: nil).object_sym).to eq :design
filter/references/design_reference_filter_spec.rb:  describe '#data_attributes_for' do
filter/references/design_reference_filter_spec.rb:    it 'includes expected attributes' do
filter/references/design_reference_filter_spec.rb:  context 'internal reference' do
filter/references/design_reference_filter_spec.rb:    it_behaves_like 'a reference containing an element node'
filter/references/design_reference_filter_spec.rb:    it_behaves_like 'a good link reference'
filter/references/design_reference_filter_spec.rb:    context 'the filename contains invalid characters' do
filter/references/design_reference_filter_spec.rb:          ['with some spaces.png'],
filter/references/design_reference_filter_spec.rb:          ['with <script>console.log("pwded")<%2Fscript>.png'],
filter/references/design_reference_filter_spec.rb:          ['foo"bar.png'],
filter/references/design_reference_filter_spec.rb:          ['A "very" good file.png']
filter/references/design_reference_filter_spec.rb:        it_behaves_like 'a no-op filter'
filter/references/design_reference_filter_spec.rb:    context 'the reference is to a non-existant design' do
filter/references/design_reference_filter_spec.rb:      it_behaves_like 'a no-op filter'
filter/references/design_reference_filter_spec.rb:    context 'design management is disabled for the referenced project' do
filter/references/design_reference_filter_spec.rb:      it_behaves_like 'a no-op filter'
filter/references/design_reference_filter_spec.rb:  describe 'link pattern' do
filter/references/design_reference_filter_spec.rb:    it 'matches' do
filter/references/design_reference_filter_spec.rb:  context 'cross-project / cross-namespace complete reference' do
filter/references/design_reference_filter_spec.rb:    it_behaves_like 'a reference containing an element node'
filter/references/design_reference_filter_spec.rb:    it_behaves_like 'a good link reference'
filter/references/design_reference_filter_spec.rb:    it 'links to a valid reference' do
filter/references/design_reference_filter_spec.rb:      expect(doc.css('a').first.attr('href')).to eq(design_url)
filter/references/design_reference_filter_spec.rb:    context 'design management is disabled for that project' do
filter/references/design_reference_filter_spec.rb:      it_behaves_like 'a no-op filter'
filter/references/design_reference_filter_spec.rb:    it 'link has valid text' do
filter/references/design_reference_filter_spec.rb:      expect(doc.css('a').first.text).to eql(ref)
filter/references/design_reference_filter_spec.rb:    it 'includes default classes' do
filter/references/design_reference_filter_spec.rb:      expect(doc.css('a').first.attr('class')).to eq 'gfm gfm-design has-tooltip'
filter/references/design_reference_filter_spec.rb:    context 'the reference is invalid' do
filter/references/design_reference_filter_spec.rb:      let(:design_url) { url_for_design(design).gsub(/jpg/, 'gif') }
filter/references/design_reference_filter_spec.rb:      it_behaves_like 'a no-op filter'
filter/references/design_reference_filter_spec.rb:  describe 'performance' do
filter/references/design_reference_filter_spec.rb:    it 'is linear in the number of projects with design management enabled each design refers to' do
filter/references/design_reference_filter_spec.rb:      #      :in `parent_records'*/
filter/references/design_reference_filter_spec.rb:      #      :in `parent_records'*/
filter/references/commit_reference_filter_spec.rb:require 'spec_helper'
filter/references/commit_reference_filter_spec.rb:  it 'requires project context' do
filter/references/commit_reference_filter_spec.rb:    expect { described_class.call('') }.to raise_error(ArgumentError, /:project/)
filter/references/commit_reference_filter_spec.rb:    it "ignores valid references contained inside '#{elem}' element" do
filter/references/commit_reference_filter_spec.rb:  context 'internal reference' do
filter/references/commit_reference_filter_spec.rb:    # Let's test a variety of commit SHA sizes just to be paranoid
filter/references/commit_reference_filter_spec.rb:        expect(doc.css('a').first.text).to eq commit.short_id
filter/references/commit_reference_filter_spec.rb:        expect(doc.css('a').first.attr('href'))
filter/references/commit_reference_filter_spec.rb:      expect(doc.css('a')).to be_empty
filter/references/commit_reference_filter_spec.rb:      expect(doc.css('a')).to be_empty
filter/references/commit_reference_filter_spec.rb:    it 'always uses the short ID as the link text' do
filter/references/commit_reference_filter_spec.rb:    it 'links with adjacent text' do
filter/references/commit_reference_filter_spec.rb:    it 'ignores invalid commit IDs' do
filter/references/commit_reference_filter_spec.rb:    it 'includes a title attribute' do
filter/references/commit_reference_filter_spec.rb:      expect(doc.css('a').first.attr('title')).to eq commit.title
filter/references/commit_reference_filter_spec.rb:    it 'escapes the title attribute' do
filter/references/commit_reference_filter_spec.rb:    it 'includes default classes' do
filter/references/commit_reference_filter_spec.rb:      expect(doc.css('a').first.attr('class')).to eq 'gfm gfm-commit has-tooltip'
filter/references/commit_reference_filter_spec.rb:    it 'includes a data-project attribute' do
filter/references/commit_reference_filter_spec.rb:      link = doc.css('a').first
filter/references/commit_reference_filter_spec.rb:      expect(link).to have_attribute('data-project')
filter/references/commit_reference_filter_spec.rb:      expect(link.attr('data-project')).to eq project.id.to_s
filter/references/commit_reference_filter_spec.rb:    it 'includes a data-commit attribute' do
filter/references/commit_reference_filter_spec.rb:      link = doc.css('a').first
filter/references/commit_reference_filter_spec.rb:      expect(link).to have_attribute('data-commit')
filter/references/commit_reference_filter_spec.rb:      expect(link.attr('data-commit')).to eq commit.id
filter/references/commit_reference_filter_spec.rb:    it 'supports an :only_path context' do
filter/references/commit_reference_filter_spec.rb:      link = doc.css('a').first.attr('href')
filter/references/commit_reference_filter_spec.rb:      it 'handles merge request contextual commit references' do
filter/references/commit_reference_filter_spec.rb:        expect(doc.css('a').first[:href]).to eq(url)
filter/references/commit_reference_filter_spec.rb:        it 'makes only a single request to Gitaly' do
filter/references/commit_reference_filter_spec.rb:          reference_filter("A big list of SHAs #{oids.join(', ')}", noteable: noteable)
filter/references/commit_reference_filter_spec.rb:  context 'cross-project / cross-namespace complete reference' do
filter/references/commit_reference_filter_spec.rb:    it 'link has valid text' do
filter/references/commit_reference_filter_spec.rb:      expect(doc.css('a').first.text).to eql("#{project2.full_path}@#{commit.short_id}")
filter/references/commit_reference_filter_spec.rb:    it 'has valid text' do
filter/references/commit_reference_filter_spec.rb:    context 'when absolute path namespace is provided instead of project' do
filter/references/commit_reference_filter_spec.rb:      it 'does not replace this reference with a link' do
filter/references/commit_reference_filter_spec.rb:        expect(doc.css('a')).to be_empty
filter/references/commit_reference_filter_spec.rb:    it 'ignores invalid commit IDs on the referenced project' do
filter/references/commit_reference_filter_spec.rb:  context 'cross-project / same-namespace complete reference' do
filter/references/commit_reference_filter_spec.rb:    it 'link has valid text' do
filter/references/commit_reference_filter_spec.rb:      expect(doc.css('a').first.text).to eql("#{project2.path}@#{commit.short_id}")
filter/references/commit_reference_filter_spec.rb:    it 'has valid text' do
filter/references/commit_reference_filter_spec.rb:    it 'ignores invalid commit IDs on the referenced project' do
filter/references/commit_reference_filter_spec.rb:  context 'cross-project shorthand reference' do
filter/references/commit_reference_filter_spec.rb:    it 'link has valid text' do
filter/references/commit_reference_filter_spec.rb:      expect(doc.css('a').first.text).to eql("#{project2.path}@#{commit.short_id}")
filter/references/commit_reference_filter_spec.rb:    it 'has valid text' do
filter/references/commit_reference_filter_spec.rb:    it 'ignores invalid commit IDs on the referenced project' do
filter/references/commit_reference_filter_spec.rb:  context 'cross-project URL reference' do
filter/references/commit_reference_filter_spec.rb:    it 'links to a valid reference' do
filter/references/commit_reference_filter_spec.rb:      expect(doc.css('a').first.attr('href'))
filter/references/commit_reference_filter_spec.rb:    it 'links with adjacent text' do
filter/references/commit_reference_filter_spec.rb:    it 'ignores invalid commit IDs on the referenced project' do
filter/references/commit_reference_filter_spec.rb:  context 'URL reference for a commit patch' do
filter/references/commit_reference_filter_spec.rb:    let(:extension) { '.patch' }
filter/references/commit_reference_filter_spec.rb:    it 'links to a valid reference' do
filter/references/commit_reference_filter_spec.rb:      expect(doc.css('a').first.attr('href'))
filter/references/commit_reference_filter_spec.rb:    it 'has valid text' do
filter/references/commit_reference_filter_spec.rb:    it 'does not link to patch when extension match is after the path' do
filter/references/commit_reference_filter_spec.rb:      expect(doc.css('a').first.attr('href')).to eq "#{link}/builds"
filter/references/commit_reference_filter_spec.rb:  context 'group context' do
filter/references/commit_reference_filter_spec.rb:    it 'ignores internal references' do
filter/references/commit_reference_filter_spec.rb:    it 'links to a valid reference' do
filter/references/commit_reference_filter_spec.rb:      expect(reference_filter(act, context).css('a').first.text).to eql("#{project.full_path}@#{commit.short_id}")
filter/references/commit_reference_filter_spec.rb:  context 'when Commit.reference_pattern causes a long scanning period' do
filter/references/commit_reference_filter_spec.rb:    it 'timesout and rescues in filter' do
filter/references/commit_reference_filter_spec.rb:      markdown = 'a-' * 55000
filter/references/commit_reference_filter_spec.rb:  context 'checking N+1' do
filter/references/commit_reference_filter_spec.rb:    it 'does not have N+1 per multiple references per project', :use_sql_query_cache do
filter/references/commit_reference_filter_spec.rb:  it_behaves_like 'limits the number of filtered items' do
filter/references/external_issue_reference_filter_spec.rb:require 'spec_helper'
filter/references/external_issue_reference_filter_spec.rb:    it_behaves_like 'a reference containing an element node'
filter/references/external_issue_reference_filter_spec.rb:    it 'requires project context' do
filter/references/external_issue_reference_filter_spec.rb:      expect { described_class.call('') }.to raise_error(ArgumentError, /:project/)
filter/references/external_issue_reference_filter_spec.rb:      it "ignores valid references contained inside '#{elem}' element" do
filter/references/external_issue_reference_filter_spec.rb:    it 'ignores valid references when using default tracker' do
filter/references/external_issue_reference_filter_spec.rb:    it 'links to a valid reference' do
filter/references/external_issue_reference_filter_spec.rb:      issue_id = doc.css('a').first.attr("data-external-issue")
filter/references/external_issue_reference_filter_spec.rb:      expect(doc.css('a').first.attr('href'))
filter/references/external_issue_reference_filter_spec.rb:    it 'links to the external tracker' do
filter/references/external_issue_reference_filter_spec.rb:      link = doc.css('a').first.attr('href')
filter/references/external_issue_reference_filter_spec.rb:      issue_id = doc.css('a').first.attr("data-external-issue")
filter/references/external_issue_reference_filter_spec.rb:    it 'links with adjacent text' do
filter/references/external_issue_reference_filter_spec.rb:    it 'includes a title attribute' do
filter/references/external_issue_reference_filter_spec.rb:      expect(doc.css('a').first.attr('title')).to include("Issue in #{project.external_issue_tracker.title}")
filter/references/external_issue_reference_filter_spec.rb:    it 'escapes the title attribute' do
filter/references/external_issue_reference_filter_spec.rb:    it 'includes default classes' do
filter/references/external_issue_reference_filter_spec.rb:      expect(doc.css('a').first.attr('class')).to eq 'gfm gfm-issue has-tooltip'
filter/references/external_issue_reference_filter_spec.rb:    it 'supports an :only_path context' do
filter/references/external_issue_reference_filter_spec.rb:      link = doc.css('a').first.attr('href')
filter/references/external_issue_reference_filter_spec.rb:      issue_id = doc.css('a').first["data-external-issue"]
filter/references/external_issue_reference_filter_spec.rb:    it 'has an empty link if issue_url is invalid' do
filter/references/external_issue_reference_filter_spec.rb:      expect_any_instance_of(project.external_issue_tracker.class).to receive(:issue_url) { 'javascript:alert("foo");' }
filter/references/external_issue_reference_filter_spec.rb:      link = doc.css('a').first.attr('href')
filter/references/external_issue_reference_filter_spec.rb:      expect(link).to eq ''
filter/references/external_issue_reference_filter_spec.rb:    it 'has an empty link if issue_path is invalid' do
filter/references/external_issue_reference_filter_spec.rb:      expect_any_instance_of(project.external_issue_tracker.class).to receive(:issue_path) { 'javascript:alert("foo");' }
filter/references/external_issue_reference_filter_spec.rb:      link = doc.css('a').first.attr('href')
filter/references/external_issue_reference_filter_spec.rb:      expect(link).to eq ''
filter/references/external_issue_reference_filter_spec.rb:    context 'with RequestStore enabled', :request_store do
filter/references/external_issue_reference_filter_spec.rb:      it 'queries the collection on the first call' do
filter/references/external_issue_reference_filter_spec.rb:        expect(cached[:output].css('a').first[:href]).to eq(not_cached[:output].css('a').first[:href])
filter/references/external_issue_reference_filter_spec.rb:    it_behaves_like 'limits the number of filtered items' do
filter/references/external_issue_reference_filter_spec.rb:    context 'with a custom regex' do
filter/references/external_issue_reference_filter_spec.rb:        service.jira_tracker_data.update!(jira_issue_regex: '[JIRA]{2,}-\\d+')
filter/references/external_issue_reference_filter_spec.rb:  context 'checking N+1' do
filter/references/external_issue_reference_filter_spec.rb:    it 'does not have N+1 per multiple references per project', :use_sql_query_cache do
filter/references/work_item_reference_filter_spec.rb:require 'spec_helper'
filter/references/work_item_reference_filter_spec.rb:  let_it_be(:namespace)       { create(:namespace, name: 'main-namespace') }
filter/references/work_item_reference_filter_spec.rb:  let_it_be(:project)         { create(:project, :public, namespace: namespace, path: 'main-project') }
filter/references/work_item_reference_filter_spec.rb:  let_it_be(:cross_namespace) { create(:namespace, name: 'cross-namespace') }
filter/references/work_item_reference_filter_spec.rb:  let_it_be(:cross_project)   { create(:project, :public, namespace: cross_namespace, path: 'cross-project') }
filter/references/work_item_reference_filter_spec.rb:  it 'subclasses from IssueReferenceFilter' do
filter/references/work_item_reference_filter_spec.rb:  shared_examples 'a reference with work item type information' do
filter/references/work_item_reference_filter_spec.rb:    it 'contains work-item-type as a data attribute' do
filter/references/work_item_reference_filter_spec.rb:      expect(doc.css('a').first.attr('data-work-item-type')).to eq('issue')
filter/references/work_item_reference_filter_spec.rb:  shared_examples 'a work item reference' do
filter/references/work_item_reference_filter_spec.rb:    it_behaves_like 'a reference containing an element node'
filter/references/work_item_reference_filter_spec.rb:    it_behaves_like 'a reference with work item type information'
filter/references/work_item_reference_filter_spec.rb:    it 'links to a valid reference' do
filter/references/work_item_reference_filter_spec.rb:      expect(doc.css('a').first.attr('href')).to eq work_item_url
filter/references/work_item_reference_filter_spec.rb:    it 'links with adjacent text' do
filter/references/work_item_reference_filter_spec.rb:    it 'includes a title attribute' do
filter/references/work_item_reference_filter_spec.rb:      expect(doc.css('a').first.attr('title')).to eq work_item.title
filter/references/work_item_reference_filter_spec.rb:    it 'escapes the title attribute' do
filter/references/work_item_reference_filter_spec.rb:      expect(doc.text).not_to include 'whatever'
filter/references/work_item_reference_filter_spec.rb:    it 'renders non-HTML tooltips' do
filter/references/work_item_reference_filter_spec.rb:      expect(doc.at_css('a')).not_to have_attribute('data-html')
filter/references/work_item_reference_filter_spec.rb:    it 'includes default classes' do
filter/references/work_item_reference_filter_spec.rb:      expect(doc.css('a').first.attr('class')).to eq 'gfm gfm-work_item'
filter/references/work_item_reference_filter_spec.rb:    it 'includes a data-issue attribute' do
filter/references/work_item_reference_filter_spec.rb:      link = doc.css('a').first
filter/references/work_item_reference_filter_spec.rb:      expect(link).to have_attribute('data-work-item')
filter/references/work_item_reference_filter_spec.rb:      expect(link.attr('data-work-item')).to eq work_item.id.to_s
filter/references/work_item_reference_filter_spec.rb:    it 'includes a data-original attribute' do
filter/references/work_item_reference_filter_spec.rb:      link = doc.css('a').first
filter/references/work_item_reference_filter_spec.rb:      expect(link).to have_attribute('data-original')
filter/references/work_item_reference_filter_spec.rb:      expect(link.attr('data-original')).to eq inner_text
filter/references/work_item_reference_filter_spec.rb:    it 'does not escape the data-original attribute' do
filter/references/work_item_reference_filter_spec.rb:      skip if written_reference.start_with?('<a')
filter/references/work_item_reference_filter_spec.rb:      inner_html = 'element <code>node</code> inside'
filter/references/work_item_reference_filter_spec.rb:      expect(doc.children.first.children.first.attr('data-original')).to eq inner_html
filter/references/work_item_reference_filter_spec.rb:    it 'includes a data-reference-format attribute' do
filter/references/work_item_reference_filter_spec.rb:      skip if written_reference.start_with?('<a')
filter/references/work_item_reference_filter_spec.rb:      link = doc.css('a').first
filter/references/work_item_reference_filter_spec.rb:      expect(link).to have_attribute('data-reference-format')
filter/references/work_item_reference_filter_spec.rb:      expect(link.attr('data-reference-format')).to eq('+')
filter/references/work_item_reference_filter_spec.rb:      expect(link.attr('href')).to eq(work_item_url)
filter/references/work_item_reference_filter_spec.rb:    it 'includes a data-reference-format attribute for URL references' do
filter/references/work_item_reference_filter_spec.rb:      link = doc.css('a').first
filter/references/work_item_reference_filter_spec.rb:      expect(link).to have_attribute('data-reference-format')
filter/references/work_item_reference_filter_spec.rb:      expect(link.attr('data-reference-format')).to eq('+')
filter/references/work_item_reference_filter_spec.rb:      expect(link.attr('href')).to eq(work_item_url)
filter/references/work_item_reference_filter_spec.rb:    it 'includes a data-reference-format attribute for extended summary URL references' do
filter/references/work_item_reference_filter_spec.rb:      link = doc.css('a').first
filter/references/work_item_reference_filter_spec.rb:      expect(link).to have_attribute('data-reference-format')
filter/references/work_item_reference_filter_spec.rb:      expect(link.attr('data-reference-format')).to eq('+s')
filter/references/work_item_reference_filter_spec.rb:      expect(link.attr('href')).to eq(work_item_url)
filter/references/work_item_reference_filter_spec.rb:    it 'does not process links containing issue numbers followed by text' do
filter/references/work_item_reference_filter_spec.rb:      doc = reference_filter("<a href='#{href}'></a>")
filter/references/work_item_reference_filter_spec.rb:      link = doc.css('a').first.attr('href')
filter/references/work_item_reference_filter_spec.rb:  context 'when group level work item URL reference' do
filter/references/work_item_reference_filter_spec.rb:    it_behaves_like 'a work item reference'
filter/references/work_item_reference_filter_spec.rb:  context 'when group level work item full reference' do
filter/references/work_item_reference_filter_spec.rb:    it_behaves_like 'a work item reference'
filter/references/work_item_reference_filter_spec.rb:  context 'when cross-project URL reference' do
filter/references/work_item_reference_filter_spec.rb:    it_behaves_like 'a work item reference'
filter/references/work_item_reference_filter_spec.rb:    it 'includes a data-project attribute' do
filter/references/work_item_reference_filter_spec.rb:      link = doc.css('a').first
filter/references/work_item_reference_filter_spec.rb:      expect(link).to have_attribute('data-project')
filter/references/work_item_reference_filter_spec.rb:      expect(link.attr('data-project')).to eq cross_project.id.to_s
filter/references/work_item_reference_filter_spec.rb:    it 'includes data attributes for issuable popover' do
filter/references/work_item_reference_filter_spec.rb:      link = doc.css('a').first
filter/references/work_item_reference_filter_spec.rb:      expect(link.attr('data-project-path')).to eq cross_project.full_path
filter/references/work_item_reference_filter_spec.rb:      expect(link.attr('data-namespace-path')).to eq cross_project.full_path
filter/references/work_item_reference_filter_spec.rb:      expect(link.attr('data-iid')).to eq work_item.iid.to_s
filter/references/work_item_reference_filter_spec.rb:  context 'when cross-project URL reference with comment anchor' do
filter/references/work_item_reference_filter_spec.rb:    it_behaves_like 'a reference containing an element node'
filter/references/work_item_reference_filter_spec.rb:    it_behaves_like 'a reference with work item type information'
filter/references/work_item_reference_filter_spec.rb:    it 'links to a valid reference' do
filter/references/work_item_reference_filter_spec.rb:      expect(doc.css('a').first.attr('href')).to eq reference
filter/references/work_item_reference_filter_spec.rb:    it 'link with trailing slash' do
filter/references/work_item_reference_filter_spec.rb:    it 'links with adjacent text', quarantine: 'https://gitlab.com/gitlab-org/gitlab/-/issues/478370' do
filter/references/work_item_reference_filter_spec.rb:  #   'See <a href=\"http://localhost/cross-namespace/cross-project/-/work_items/1\">Reference</a>''
filter/references/work_item_reference_filter_spec.rb:  context 'when cross-project URL in link href' do
filter/references/work_item_reference_filter_spec.rb:    let_it_be(:inner_text)        { 'Reference' }
filter/references/work_item_reference_filter_spec.rb:    it_behaves_like 'a work item reference'
filter/references/work_item_reference_filter_spec.rb:    it 'includes a data-project attribute' do
filter/references/work_item_reference_filter_spec.rb:      link = doc.css('a').first
filter/references/work_item_reference_filter_spec.rb:      expect(link).to have_attribute('data-project')
filter/references/work_item_reference_filter_spec.rb:      expect(link.attr('data-project')).to eq cross_project.id.to_s
filter/references/work_item_reference_filter_spec.rb:    it 'includes data attributes for issuable popover' do
filter/references/work_item_reference_filter_spec.rb:      link = doc.css('a').first
filter/references/work_item_reference_filter_spec.rb:      expect(link.attr('data-project-path')).to eq cross_project.full_path
filter/references/work_item_reference_filter_spec.rb:      expect(link.attr('data-namespace-path')).to eq cross_project.full_path
filter/references/work_item_reference_filter_spec.rb:      expect(link.attr('data-iid')).to eq work_item.iid.to_s
filter/references/work_item_reference_filter_spec.rb:  context 'for group context' do
filter/references/work_item_reference_filter_spec.rb:    context 'when work item exists at the group level' do
filter/references/work_item_reference_filter_spec.rb:      it 'includes data attributes for issuable popover' do
filter/references/work_item_reference_filter_spec.rb:        link = doc.css('a').first
filter/references/work_item_reference_filter_spec.rb:        expect(link.attr('data-namespace-path')).to eq(group.full_path)
filter/references/work_item_reference_filter_spec.rb:        expect(link.attr('data-iid')).to eq(work_item.iid.to_s)
filter/references/work_item_reference_filter_spec.rb:      it 'links to a valid group level work item by URL' do
filter/references/work_item_reference_filter_spec.rb:        link = doc.css('a').first
filter/references/work_item_reference_filter_spec.rb:        expect(link.attr('href')).to eq(work_item_url)
filter/references/work_item_reference_filter_spec.rb:      it 'links to a valid group level work item with short reference' do
filter/references/work_item_reference_filter_spec.rb:        link = doc.css('a').first
filter/references/work_item_reference_filter_spec.rb:        expect(link.attr('href')).to eq(work_item_url)
filter/references/work_item_reference_filter_spec.rb:      it 'links to a valid group level work item with long reference' do
filter/references/work_item_reference_filter_spec.rb:        link = doc.css('a').first
filter/references/work_item_reference_filter_spec.rb:        expect(link.attr('href')).to eq(work_item_url)
filter/references/work_item_reference_filter_spec.rb:      context 'when work item belongs to a different group than the one from the context' do
filter/references/work_item_reference_filter_spec.rb:        it 'links to a valid group level work item with long reference' do
filter/references/work_item_reference_filter_spec.rb:          link = doc.css('a').first
filter/references/work_item_reference_filter_spec.rb:          expect(link.attr('href')).to eq(work_item_url)
filter/references/work_item_reference_filter_spec.rb:    it 'links to a valid reference for url cross-namespace' do
filter/references/work_item_reference_filter_spec.rb:      link = doc.css('a').first
filter/references/work_item_reference_filter_spec.rb:      expect(link.attr('href')).to eq("#{work_item_url}#note_123")
filter/references/work_item_reference_filter_spec.rb:    it 'links to a valid reference for cross-namespace in link href' do
filter/references/work_item_reference_filter_spec.rb:      link = doc.css('a').first
filter/references/work_item_reference_filter_spec.rb:      expect(link.attr('href')).to eq("#{work_item_url}#note_123")
filter/references/work_item_reference_filter_spec.rb:      expect(link.text).to include('Reference')
filter/references/work_item_reference_filter_spec.rb:  describe 'performance' do
filter/references/work_item_reference_filter_spec.rb:    it 'does not have a N+1 query problem' do
filter/references/abstract_reference_filter_spec.rb:require 'spec_helper'
filter/references/abstract_reference_filter_spec.rb:  let_it_be(:doc) { Nokogiri::HTML.fragment('') }
filter/references/abstract_reference_filter_spec.rb:  describe '#data_attributes_for' do
filter/references/abstract_reference_filter_spec.rb:    it 'is not an XSS vector' do
filter/references/abstract_reference_filter_spec.rb:      data_attributes = filter_instance.data_attributes_for('xss &lt;img onerror=alert(1) src=x&gt;', project, issue, link_content: true)
filter/references/abstract_reference_filter_spec.rb:      expect(data_attributes[:original]).to eq('xss &amp;lt;img onerror=alert(1) src=x&amp;gt;')
filter/references/abstract_reference_filter_spec.rb:  it 'wraps call method with a timeout' do
filter/references/abstract_reference_filter_spec.rb:  it 'uses gsub_with_limit' do
filter/references/abstract_reference_filter_spec.rb:    filter_instance.references_in('text')
filter/references/abstract_reference_filter_spec.rb:  context 'abstract methods' do
filter/references/abstract_reference_filter_spec.rb:    describe '#find_object' do
filter/references/abstract_reference_filter_spec.rb:      it 'raises NotImplementedError' do
filter/references/abstract_reference_filter_spec.rb:    describe '#url_for_object' do
filter/references/abstract_reference_filter_spec.rb:      it 'raises NotImplementedError' do
filter/references/abstract_reference_filter_spec.rb:  it_behaves_like 'pipeline timing check', context: { project: nil }
filter/references/abstract_reference_filter_spec.rb:  it_behaves_like 'a filter timeout' do
filter/references/abstract_reference_filter_spec.rb:    let(:text) { 'text' }
filter/references/user_reference_filter_spec.rb:require 'spec_helper'
filter/references/user_reference_filter_spec.rb:  it_behaves_like 'user reference or project reference'
filter/references/user_reference_filter_spec.rb:  it 'requires project context' do
filter/references/user_reference_filter_spec.rb:    expect { described_class.call('') }.to raise_error(ArgumentError, /:project/)
filter/references/user_reference_filter_spec.rb:  it 'ignores invalid users' do
filter/references/user_reference_filter_spec.rb:  it 'ignores references with text before the @ sign' do
filter/references/user_reference_filter_spec.rb:    it "ignores valid references contained inside '#{elem}' element" do
filter/references/user_reference_filter_spec.rb:  context 'when `disable_all_mention` FF is enabled' do
filter/references/user_reference_filter_spec.rb:    let(:reference) { User.reference_prefix + 'all' }
filter/references/user_reference_filter_spec.rb:    context 'mentioning @all' do
filter/references/user_reference_filter_spec.rb:      it 'ignores reference to @all' do
filter/references/user_reference_filter_spec.rb:        expect(doc.css('a').length).to eq 0
filter/references/user_reference_filter_spec.rb:  context 'mentioning @all (when `disable_all_mention` FF is disabled)' do
filter/references/user_reference_filter_spec.rb:    let(:reference) { User.reference_prefix + 'all' }
filter/references/user_reference_filter_spec.rb:    it_behaves_like 'a reference containing an element node'
filter/references/user_reference_filter_spec.rb:    it 'supports a special @all mention' do
filter/references/user_reference_filter_spec.rb:      expect(doc.css('a').length).to eq 1
filter/references/user_reference_filter_spec.rb:      expect(doc.css('a').first.attr('href'))
filter/references/user_reference_filter_spec.rb:    it 'includes a data-author attribute when there is an author' do
filter/references/user_reference_filter_spec.rb:      expect(doc.css('a').first.attr('data-author')).to eq(user.id.to_s)
filter/references/user_reference_filter_spec.rb:    it 'does not include a data-author attribute when there is no author' do
filter/references/user_reference_filter_spec.rb:      expect(doc.css('a').first.has_attribute?('data-author')).to eq(false)
filter/references/user_reference_filter_spec.rb:    it 'ignores reference to all when the user is not a project member' do
filter/references/user_reference_filter_spec.rb:      expect(doc.css('a').length).to eq 0
filter/references/user_reference_filter_spec.rb:  context 'mentioning a group' do
filter/references/user_reference_filter_spec.rb:    it_behaves_like 'a reference containing an element node'
filter/references/user_reference_filter_spec.rb:    it 'links to the Group' do
filter/references/user_reference_filter_spec.rb:      expect(doc.css('a').first.attr('href')).to eq urls.group_url(group)
filter/references/user_reference_filter_spec.rb:    it 'includes a data-group attribute' do
filter/references/user_reference_filter_spec.rb:      link = doc.css('a').first
filter/references/user_reference_filter_spec.rb:      expect(link).to have_attribute('data-group')
filter/references/user_reference_filter_spec.rb:      expect(link.attr('data-group')).to eq group.id.to_s
filter/references/user_reference_filter_spec.rb:  context 'mentioning a nested group' do
filter/references/user_reference_filter_spec.rb:    it_behaves_like 'a reference containing an element node'
filter/references/user_reference_filter_spec.rb:    it 'links to the nested group' do
filter/references/user_reference_filter_spec.rb:      expect(doc.css('a').first.attr('href')).to eq urls.group_url(group)
filter/references/user_reference_filter_spec.rb:    it 'has the full group name as a title' do
filter/references/user_reference_filter_spec.rb:      expect(doc.css('a').first.attr('title')).to eq group.full_name
filter/references/user_reference_filter_spec.rb:  it 'links with adjacent text' do
filter/references/user_reference_filter_spec.rb:  it 'includes default classes' do
filter/references/user_reference_filter_spec.rb:    expect(doc.css('a').first.attr('class')).to eq 'gfm gfm-project_member js-user-link'
filter/references/user_reference_filter_spec.rb:  context 'when a project is not specified' do
filter/references/user_reference_filter_spec.rb:    it 'does not link a User' do
filter/references/user_reference_filter_spec.rb:      expect(doc).not_to include('a')
filter/references/user_reference_filter_spec.rb:    context 'when skip_project_check set to true' do
filter/references/user_reference_filter_spec.rb:      it 'links to a User' do
filter/references/user_reference_filter_spec.rb:        expect(doc.css('a').first.attr('href')).to eq urls.user_url(user)
filter/references/user_reference_filter_spec.rb:      it 'does not link users using @all reference' do
filter/references/user_reference_filter_spec.rb:        expect(doc).not_to include('a')
filter/references/user_reference_filter_spec.rb:  context 'in group context' do
filter/references/user_reference_filter_spec.rb:    it 'supports a special @all mention' do
filter/references/user_reference_filter_spec.rb:      reference = User.reference_prefix + 'all'
filter/references/user_reference_filter_spec.rb:      expect(doc.css('a').length).to eq(1)
filter/references/user_reference_filter_spec.rb:      expect(doc.css('a').first.attr('href')).to eq urls.group_url(group)
filter/references/user_reference_filter_spec.rb:    it 'supports mentioning a single user' do
filter/references/user_reference_filter_spec.rb:      expect(doc.css('a').first.attr('href')).to eq urls.user_url(group_member)
filter/references/user_reference_filter_spec.rb:    it 'supports mentioning a group' do
filter/references/user_reference_filter_spec.rb:      expect(doc.css('a').first.attr('href')).to eq urls.user_url(group)
filter/references/user_reference_filter_spec.rb:  describe '#namespaces' do
filter/references/user_reference_filter_spec.rb:    it 'returns a Hash containing all Namespaces' do
filter/references/user_reference_filter_spec.rb:  describe '#usernames' do
filter/references/user_reference_filter_spec.rb:    it 'returns the usernames mentioned in a document' do
filter/references/user_reference_filter_spec.rb:  context 'checking N+1' do
filter/references/user_reference_filter_spec.rb:    it 'does not have N+1 per multiple user references', :use_sql_query_cache do
filter/references/user_reference_filter_spec.rb:  it_behaves_like 'limits the number of filtered items' do
filter/references/reference_cache_spec.rb:require 'spec_helper'
filter/references/reference_cache_spec.rb:  describe '#load_reference_cache' do
filter/references/reference_cache_spec.rb:    context 'when rendered_html is not memoized' do
filter/references/reference_cache_spec.rb:      it 'generates new html' do
filter/references/reference_cache_spec.rb:    context 'when rendered_html is memoized' do
filter/references/reference_cache_spec.rb:      let(:result) { { rendered_html: 'html' } }
filter/references/reference_cache_spec.rb:      it 'reuses memoized rendered HTML when available' do
filter/references/reference_cache_spec.rb:    context 'when result is not available' do
filter/references/reference_cache_spec.rb:    context 'when cache is loaded' do
filter/references/reference_cache_spec.rb:      it 'loads the cache' do
filter/references/reference_cache_spec.rb:      describe '#references_per_parent' do
filter/references/reference_cache_spec.rb:        it 'loads references grouped per parent paths' do
filter/references/reference_cache_spec.rb:      describe '#parent_per_reference' do
filter/references/reference_cache_spec.rb:        it 'returns a Hash containing projects grouped per parent paths' do
filter/references/reference_cache_spec.rb:      describe '#records_per_parent' do
filter/references/reference_cache_spec.rb:        it 'returns a Hash containing records grouped per parent' do
filter/references/reference_cache_spec.rb:    context 'when the cache is loaded with absolute references' do
filter/references/reference_cache_spec.rb:      it 'loads references grouped per parent path and absolute references' do
filter/references/reference_cache_spec.rb:  describe '#initialize_reference_cache' do
filter/references/reference_cache_spec.rb:    it 'does not have an N+1 query problem with cross projects' do
filter/references/reference_cache_spec.rb:  describe '#find_for_paths' do
filter/references/reference_cache_spec.rb:    context 'with RequestStore disabled' do
filter/references/reference_cache_spec.rb:      it 'returns a list of Projects for a list of paths' do
filter/references/reference_cache_spec.rb:      it 'return an empty array for paths that do not exist' do
filter/references/reference_cache_spec.rb:        expect(find_for_paths(['nonexistent/project'])).to eq([])
filter/references/reference_cache_spec.rb:      it 'finds group and project by absolute path' do
filter/references/reference_cache_spec.rb:        nonexistent_path = '/nonexistent/project'
filter/references/reference_cache_spec.rb:    context 'with RequestStore enabled', :request_store do
filter/references/reference_cache_spec.rb:      it 'returns a list of Projects for a list of paths' do
filter/references/reference_cache_spec.rb:      context 'when no project with that path exists' do
filter/references/reference_cache_spec.rb:        it 'returns no value' do
filter/references/reference_cache_spec.rb:          expect(find_for_paths(['nonexistent/project'])).to eq([])
filter/references/reference_cache_spec.rb:        it 'adds the ref to the project refs cache' do
filter/references/reference_cache_spec.rb:          find_for_paths(['nonexistent/project'])
filter/references/reference_cache_spec.rb:          expect(project_refs_cache).to eq({ 'nonexistent/project' => nil })
filter/references/reference_cache_spec.rb:  describe '#current_parent_path' do
filter/references/reference_cache_spec.rb:    it 'returns the path of the current parent' do
filter/references/reference_cache_spec.rb:  describe '#current_project_namespace_path' do
filter/references/reference_cache_spec.rb:    it 'returns the path of the current project namespace' do
filter/references/reference_cache_spec.rb:  describe '#full_project_path' do
filter/references/reference_cache_spec.rb:    it 'returns current parent path when no ref specified' do
filter/references/reference_cache_spec.rb:      expect(cache.full_project_path('something', nil)).to eq cache.current_parent_path
filter/references/reference_cache_spec.rb:    it 'returns combined namespace and project ref' do
filter/references/reference_cache_spec.rb:      expect(cache.full_project_path('something', 'cool')).to eq 'something/cool'
filter/references/reference_cache_spec.rb:    it 'returns default namespace and project ref when namespace nil' do
filter/references/reference_cache_spec.rb:      expect(cache.full_project_path(nil, 'cool')).to eq "#{project.namespace.full_path}/cool"
filter/references/reference_cache_spec.rb:    it 'returns absolute paths when matched to an absolute path' do
filter/references/reference_cache_spec.rb:      expect(cache.full_project_path('something', 'cool', match)).to eq '/something/cool'
filter/references/reference_cache_spec.rb:      expect(cache.full_project_path(nil, 'cool', match)).to eq '/cool'
filter/references/reference_cache_spec.rb:  describe '#full_group_path' do
filter/references/reference_cache_spec.rb:    it 'returns current parent path when no group ref specified' do
filter/references/reference_cache_spec.rb:    it 'returns group ref' do
filter/references/reference_cache_spec.rb:      expect(cache.full_group_path('cool_group')).to eq 'cool_group'
filter/references/issue_reference_filter_spec.rb:require 'spec_helper'
filter/references/issue_reference_filter_spec.rb:  shared_examples 'a reference with issue type information' do
filter/references/issue_reference_filter_spec.rb:    it 'contains issue-type as a data attribute' do
filter/references/issue_reference_filter_spec.rb:      expect(doc.css('a').first.attr('data-issue-type')).to eq('issue')
filter/references/issue_reference_filter_spec.rb:  it 'requires project context' do
filter/references/issue_reference_filter_spec.rb:    expect { described_class.call('') }.to raise_error(ArgumentError, /:project/)
filter/references/issue_reference_filter_spec.rb:    it "ignores valid references contained inside '#{elem}' element" do
filter/references/issue_reference_filter_spec.rb:  describe 'performance' do
filter/references/issue_reference_filter_spec.rb:    it 'does not have a N+1 query problem' do
filter/references/issue_reference_filter_spec.rb:  shared_examples 'an internal reference' do
filter/references/issue_reference_filter_spec.rb:    it_behaves_like 'a reference containing an element node'
filter/references/issue_reference_filter_spec.rb:    it_behaves_like 'a reference with issue type information'
filter/references/issue_reference_filter_spec.rb:    it 'links to a valid reference' do
filter/references/issue_reference_filter_spec.rb:      expect(doc.css('a').first.attr('href'))
filter/references/issue_reference_filter_spec.rb:    it 'links with adjacent text' do
filter/references/issue_reference_filter_spec.rb:    it 'ignores invalid issue IDs' do
filter/references/issue_reference_filter_spec.rb:    it 'includes a title attribute' do
filter/references/issue_reference_filter_spec.rb:      expect(doc.css('a').first.attr('title')).to eq issue.title
filter/references/issue_reference_filter_spec.rb:    it 'escapes the title attribute' do
filter/references/issue_reference_filter_spec.rb:    it 'renders non-HTML tooltips' do
filter/references/issue_reference_filter_spec.rb:      expect(doc.at_css('a')).not_to have_attribute('data-html')
filter/references/issue_reference_filter_spec.rb:    it 'includes default classes' do
filter/references/issue_reference_filter_spec.rb:      expect(doc.css('a').first.attr('class')).to eq 'gfm gfm-issue'
filter/references/issue_reference_filter_spec.rb:    it 'includes a data-project attribute' do
filter/references/issue_reference_filter_spec.rb:      link = doc.css('a').first
filter/references/issue_reference_filter_spec.rb:      expect(link).to have_attribute('data-project')
filter/references/issue_reference_filter_spec.rb:      expect(link.attr('data-project')).to eq project.id.to_s
filter/references/issue_reference_filter_spec.rb:    it 'includes a data-namespace-path attribute' do
filter/references/issue_reference_filter_spec.rb:      link = doc.css('a').first
filter/references/issue_reference_filter_spec.rb:      expect(link).to have_attribute('data-namespace-path')
filter/references/issue_reference_filter_spec.rb:      expect(link.attr('data-namespace-path')).to eq(project.full_path)
filter/references/issue_reference_filter_spec.rb:    it 'includes a data-issue attribute' do
filter/references/issue_reference_filter_spec.rb:      link = doc.css('a').first
filter/references/issue_reference_filter_spec.rb:      expect(link).to have_attribute('data-issue')
filter/references/issue_reference_filter_spec.rb:      expect(link.attr('data-issue')).to eq issue.id.to_s
filter/references/issue_reference_filter_spec.rb:    it 'includes data attributes for issuable popover' do
filter/references/issue_reference_filter_spec.rb:      link = doc.css('a').first
filter/references/issue_reference_filter_spec.rb:      expect(link.attr('data-project-path')).to eq project.full_path
filter/references/issue_reference_filter_spec.rb:      expect(link.attr('data-iid')).to eq issue.iid.to_s
filter/references/issue_reference_filter_spec.rb:    it 'includes a data-original attribute' do
filter/references/issue_reference_filter_spec.rb:      link = doc.css('a').first
filter/references/issue_reference_filter_spec.rb:      expect(link).to have_attribute('data-original')
filter/references/issue_reference_filter_spec.rb:      expect(link.attr('data-original')).to eq written_reference
filter/references/issue_reference_filter_spec.rb:    it 'does not escape the data-original attribute' do
filter/references/issue_reference_filter_spec.rb:      inner_html = 'element <code>node</code> inside'
filter/references/issue_reference_filter_spec.rb:      expect(doc.children.first.children.first.attr('data-original')).to eq inner_html
filter/references/issue_reference_filter_spec.rb:    it 'includes a data-reference-format attribute' do
filter/references/issue_reference_filter_spec.rb:      link = doc.css('a').first
filter/references/issue_reference_filter_spec.rb:      expect(link).to have_attribute('data-reference-format')
filter/references/issue_reference_filter_spec.rb:      expect(link.attr('data-reference-format')).to eq('+')
filter/references/issue_reference_filter_spec.rb:      expect(link.attr('href')).to eq(issue_url)
filter/references/issue_reference_filter_spec.rb:    it 'includes a data-reference-format attribute for URL references' do
filter/references/issue_reference_filter_spec.rb:      link = doc.css('a').first
filter/references/issue_reference_filter_spec.rb:      expect(link).to have_attribute('data-reference-format')
filter/references/issue_reference_filter_spec.rb:      expect(link.attr('data-reference-format')).to eq('+')
filter/references/issue_reference_filter_spec.rb:      expect(link.attr('href')).to eq(issue_url)
filter/references/issue_reference_filter_spec.rb:    it 'includes a data-reference-format attribute for extended summary URL references' do
filter/references/issue_reference_filter_spec.rb:      link = doc.css('a').first
filter/references/issue_reference_filter_spec.rb:      expect(link).to have_attribute('data-reference-format')
filter/references/issue_reference_filter_spec.rb:      expect(link.attr('data-reference-format')).to eq('+s')
filter/references/issue_reference_filter_spec.rb:      expect(link.attr('href')).to eq(issue_url)
filter/references/issue_reference_filter_spec.rb:    it 'supports an :only_path context' do
filter/references/issue_reference_filter_spec.rb:      link = doc.css('a').first.attr('href')
filter/references/issue_reference_filter_spec.rb:    it 'does not process links containing issue numbers followed by text' do
filter/references/issue_reference_filter_spec.rb:      doc = reference_filter("<a href='#{href}'></a>")
filter/references/issue_reference_filter_spec.rb:      link = doc.css('a').first.attr('href')
filter/references/issue_reference_filter_spec.rb:  context 'standard internal reference' do
filter/references/issue_reference_filter_spec.rb:    it_behaves_like 'an internal reference'
filter/references/issue_reference_filter_spec.rb:  context 'alternative internal_reference' do
filter/references/issue_reference_filter_spec.rb:    it_behaves_like 'an internal reference'
filter/references/issue_reference_filter_spec.rb:  context 'cross-project / cross-namespace complete reference' do
filter/references/issue_reference_filter_spec.rb:    it_behaves_like 'a reference containing an element node'
filter/references/issue_reference_filter_spec.rb:    it_behaves_like 'a reference with issue type information'
filter/references/issue_reference_filter_spec.rb:    it 'ignores valid references when cross-reference project uses external tracker' do
filter/references/issue_reference_filter_spec.rb:    it 'links to a valid reference' do
filter/references/issue_reference_filter_spec.rb:      expect(doc.css('a').first.attr('href'))
filter/references/issue_reference_filter_spec.rb:    it 'link has valid text' do
filter/references/issue_reference_filter_spec.rb:      expect(doc.css('a').first.text).to eql("#{project2.full_path}##{issue.iid}")
filter/references/issue_reference_filter_spec.rb:    it 'has valid text' do
filter/references/issue_reference_filter_spec.rb:    it 'includes default classes' do
filter/references/issue_reference_filter_spec.rb:      expect(doc.css('a').first.attr('class')).to eq 'gfm gfm-issue'
filter/references/issue_reference_filter_spec.rb:    it 'ignores invalid issue IDs on the referenced project' do
filter/references/issue_reference_filter_spec.rb:  context 'cross-project / same-namespace complete reference' do
filter/references/issue_reference_filter_spec.rb:    it_behaves_like 'a reference containing an element node'
filter/references/issue_reference_filter_spec.rb:    it_behaves_like 'a reference with issue type information'
filter/references/issue_reference_filter_spec.rb:    it 'ignores valid references when cross-reference project uses external tracker' do
filter/references/issue_reference_filter_spec.rb:    it 'links to a valid reference' do
filter/references/issue_reference_filter_spec.rb:      expect(doc.css('a').first.attr('href'))
filter/references/issue_reference_filter_spec.rb:    it 'link has valid text' do
filter/references/issue_reference_filter_spec.rb:      expect(doc.css('a').first.text).to eql("#{project2.path}##{issue.iid}")
filter/references/issue_reference_filter_spec.rb:    it 'has valid text' do
filter/references/issue_reference_filter_spec.rb:    it 'includes default classes' do
filter/references/issue_reference_filter_spec.rb:      expect(doc.css('a').first.attr('class')).to eq 'gfm gfm-issue'
filter/references/issue_reference_filter_spec.rb:    it 'ignores invalid issue IDs on the referenced project' do
filter/references/issue_reference_filter_spec.rb:  context 'cross-project shorthand reference' do
filter/references/issue_reference_filter_spec.rb:    it_behaves_like 'a reference containing an element node'
filter/references/issue_reference_filter_spec.rb:    it_behaves_like 'a reference with issue type information'
filter/references/issue_reference_filter_spec.rb:    it 'ignores valid references when cross-reference project uses external tracker' do
filter/references/issue_reference_filter_spec.rb:    it 'links to a valid reference' do
filter/references/issue_reference_filter_spec.rb:      expect(doc.css('a').first.attr('href'))
filter/references/issue_reference_filter_spec.rb:    it 'link has valid text' do
filter/references/issue_reference_filter_spec.rb:      expect(doc.css('a').first.text).to eql("#{project2.path}##{issue.iid}")
filter/references/issue_reference_filter_spec.rb:    it 'has valid text' do
filter/references/issue_reference_filter_spec.rb:    it 'includes default classes' do
filter/references/issue_reference_filter_spec.rb:      expect(doc.css('a').first.attr('class')).to eq 'gfm gfm-issue'
filter/references/issue_reference_filter_spec.rb:    it 'ignores invalid issue IDs on the referenced project' do
filter/references/issue_reference_filter_spec.rb:  context 'cross-project URL reference' do
filter/references/issue_reference_filter_spec.rb:    let(:namespace) { create(:namespace, name: 'cross-reference') }
filter/references/issue_reference_filter_spec.rb:    it_behaves_like 'a reference containing an element node'
filter/references/issue_reference_filter_spec.rb:    it_behaves_like 'a reference with issue type information'
filter/references/issue_reference_filter_spec.rb:    it 'links to a valid reference' do
filter/references/issue_reference_filter_spec.rb:      expect(doc.css('a').first.attr('href'))
filter/references/issue_reference_filter_spec.rb:    it 'link with trailing slash' do
filter/references/issue_reference_filter_spec.rb:      doc = reference_filter("Fixed (#{issue_url + '/'}.)")
filter/references/issue_reference_filter_spec.rb:    it 'links with adjacent text' do
filter/references/issue_reference_filter_spec.rb:    it 'includes default classes' do
filter/references/issue_reference_filter_spec.rb:      expect(doc.css('a').first.attr('class')).to eq 'gfm gfm-issue'
filter/references/issue_reference_filter_spec.rb:  context 'cross-project reference in link href' do
filter/references/issue_reference_filter_spec.rb:    let(:namespace) { create(:namespace, name: 'cross-reference') }
filter/references/issue_reference_filter_spec.rb:    it_behaves_like 'a reference containing an element node'
filter/references/issue_reference_filter_spec.rb:    it_behaves_like 'a reference with issue type information'
filter/references/issue_reference_filter_spec.rb:    it 'links to a valid reference' do
filter/references/issue_reference_filter_spec.rb:      expect(doc.css('a').first.attr('href'))
filter/references/issue_reference_filter_spec.rb:    it 'links with adjacent text' do
filter/references/issue_reference_filter_spec.rb:    it 'includes default classes' do
filter/references/issue_reference_filter_spec.rb:      expect(doc.css('a').first.attr('class')).to eq 'gfm gfm-issue'
filter/references/issue_reference_filter_spec.rb:  context 'cross-project URL in link href' do
filter/references/issue_reference_filter_spec.rb:    let(:namespace) { create(:namespace, name: 'cross-reference') }
filter/references/issue_reference_filter_spec.rb:    it_behaves_like 'a reference containing an element node'
filter/references/issue_reference_filter_spec.rb:    it_behaves_like 'a reference with issue type information'
filter/references/issue_reference_filter_spec.rb:    it 'links to a valid reference' do
filter/references/issue_reference_filter_spec.rb:      expect(doc.css('a').first.attr('href'))
filter/references/issue_reference_filter_spec.rb:    it 'links with adjacent text' do
filter/references/issue_reference_filter_spec.rb:    it 'includes default classes' do
filter/references/issue_reference_filter_spec.rb:      expect(doc.css('a').first.attr('class')).to eq 'gfm gfm-issue'
filter/references/issue_reference_filter_spec.rb:  context 'when processing a link to the designs tab' do
filter/references/issue_reference_filter_spec.rb:    subject(:link) { reference_filter(input_text).css('a').first }
filter/references/issue_reference_filter_spec.rb:    it 'includes the word "designs" after the reference in the text content', :aggregate_failures do
filter/references/issue_reference_filter_spec.rb:      expect(link.attr('title')).to eq(issue.title)
filter/references/issue_reference_filter_spec.rb:      expect(link.attr('href')).to eq(designs_tab_url)
filter/references/issue_reference_filter_spec.rb:    context 'design management is not available' do
filter/references/issue_reference_filter_spec.rb:      it 'links to the issue, but not to the designs tab' do
filter/references/issue_reference_filter_spec.rb:  context 'group context' do
filter/references/issue_reference_filter_spec.rb:    it 'ignores shorthanded issue reference' do
filter/references/issue_reference_filter_spec.rb:    it 'ignores valid references when cross-reference project uses external tracker' do
filter/references/issue_reference_filter_spec.rb:    it 'links to a valid reference for complete cross-reference' do
filter/references/issue_reference_filter_spec.rb:      link = doc.css('a').first
filter/references/issue_reference_filter_spec.rb:      expect(link.attr('href')).to eq(issue_url)
filter/references/issue_reference_filter_spec.rb:    it 'ignores reference for shorthand cross-reference' do
filter/references/issue_reference_filter_spec.rb:    it 'links to a valid reference for url cross-reference' do
filter/references/issue_reference_filter_spec.rb:      link = doc.css('a').first
filter/references/issue_reference_filter_spec.rb:      expect(link.attr('href')).to eq(issue_url + "#note_123")
filter/references/issue_reference_filter_spec.rb:    it 'links to a valid reference for cross-reference in link href' do
filter/references/issue_reference_filter_spec.rb:      link = doc.css('a').first
filter/references/issue_reference_filter_spec.rb:      expect(link.attr('href')).to eq(issue_url + "#note_123")
filter/references/issue_reference_filter_spec.rb:      expect(link.text).to include('Reference')
filter/references/issue_reference_filter_spec.rb:    it 'links to a valid reference for issue reference in the link href' do
filter/references/issue_reference_filter_spec.rb:      link = doc.css('a').first
filter/references/issue_reference_filter_spec.rb:      expect(link.attr('href')).to eq(issue_url)
filter/references/issue_reference_filter_spec.rb:      expect(link.text).to include('Reference')
filter/references/issue_reference_filter_spec.rb:  describe '.references_in' do
filter/references/issue_reference_filter_spec.rb:    it 'yields valid references' do
filter/references/issue_reference_filter_spec.rb:        described_class.new('', project: nil).references_in(issue.to_reference, &b)
filter/references/issue_reference_filter_spec.rb:    it "doesn't yield invalid references" do
filter/references/issue_reference_filter_spec.rb:        described_class.new('', project: nil).references_in('#0', &b)
filter/references/issue_reference_filter_spec.rb:    it "doesn't yield unsupported references" do
filter/references/issue_reference_filter_spec.rb:        described_class.new('', project: nil).references_in(merge_request.to_reference, &b)
filter/references/issue_reference_filter_spec.rb:  describe '#object_link_text_extras' do
filter/references/issue_reference_filter_spec.rb:    context 'the link does not go to the designs tab' do
filter/references/issue_reference_filter_spec.rb:      it 'does not include designs' do
filter/references/issue_reference_filter_spec.rb:        expect(extras).not_to include('designs')
filter/references/issue_reference_filter_spec.rb:    context 'the link goes to the designs tab' do
filter/references/issue_reference_filter_spec.rb:      it 'includes designs' do
filter/references/issue_reference_filter_spec.rb:        expect(extras).to include('designs')
filter/references/issue_reference_filter_spec.rb:      context 'design management is disabled' do
filter/references/issue_reference_filter_spec.rb:        it 'does not include designs in the extras' do
filter/references/issue_reference_filter_spec.rb:          expect(extras).not_to include('designs')
filter/references/issue_reference_filter_spec.rb:  context 'checking N+1' do
filter/references/issue_reference_filter_spec.rb:    it 'does not have N+1 per multiple references per project' do
filter/references/commit_range_reference_filter_spec.rb:require 'spec_helper'
filter/references/commit_range_reference_filter_spec.rb:  it 'requires project context' do
filter/references/commit_range_reference_filter_spec.rb:    expect { described_class.call('') }.to raise_error(ArgumentError, /:project/)
filter/references/commit_range_reference_filter_spec.rb:    it "ignores valid references contained inside '#{elem}' element" do
filter/references/commit_range_reference_filter_spec.rb:  context 'internal reference' do
filter/references/commit_range_reference_filter_spec.rb:    it 'links to a valid two-dot reference' do
filter/references/commit_range_reference_filter_spec.rb:      expect(doc.css('a').first.attr('href'))
filter/references/commit_range_reference_filter_spec.rb:    it 'links to a valid three-dot reference' do
filter/references/commit_range_reference_filter_spec.rb:      expect(doc.css('a').first.attr('href'))
filter/references/commit_range_reference_filter_spec.rb:    it 'links to a valid short ID' do
filter/references/commit_range_reference_filter_spec.rb:      exp = commit1.short_id + '...' + commit2.short_id
filter/references/commit_range_reference_filter_spec.rb:      expect(reference_filter("See #{reference}").css('a').first.text).to eq exp
filter/references/commit_range_reference_filter_spec.rb:      expect(reference_filter("See #{reference2}").css('a').first.text).to eq exp
filter/references/commit_range_reference_filter_spec.rb:    it 'links with adjacent text' do
filter/references/commit_range_reference_filter_spec.rb:    it 'ignores invalid commit IDs' do
filter/references/commit_range_reference_filter_spec.rb:    it 'includes no title attribute' do
filter/references/commit_range_reference_filter_spec.rb:      expect(doc.css('a').first.attr('title')).to eq ""
filter/references/commit_range_reference_filter_spec.rb:    it 'includes default classes' do
filter/references/commit_range_reference_filter_spec.rb:      expect(doc.css('a').first.attr('class')).to eq 'gfm gfm-commit_range has-tooltip'
filter/references/commit_range_reference_filter_spec.rb:    it 'includes a data-project attribute' do
filter/references/commit_range_reference_filter_spec.rb:      link = doc.css('a').first
filter/references/commit_range_reference_filter_spec.rb:      expect(link).to have_attribute('data-project')
filter/references/commit_range_reference_filter_spec.rb:      expect(link.attr('data-project')).to eq project.id.to_s
filter/references/commit_range_reference_filter_spec.rb:    it 'includes a data-commit-range attribute' do
filter/references/commit_range_reference_filter_spec.rb:      link = doc.css('a').first
filter/references/commit_range_reference_filter_spec.rb:      expect(link).to have_attribute('data-commit-range')
filter/references/commit_range_reference_filter_spec.rb:      expect(link.attr('data-commit-range')).to eq range.to_s
filter/references/commit_range_reference_filter_spec.rb:    it 'supports an :only_path option' do
filter/references/commit_range_reference_filter_spec.rb:      link = doc.css('a').first.attr('href')
filter/references/commit_range_reference_filter_spec.rb:  context 'cross-project / cross-namespace complete reference' do
filter/references/commit_range_reference_filter_spec.rb:    it 'links to a valid reference' do
filter/references/commit_range_reference_filter_spec.rb:      expect(doc.css('a').first.attr('href'))
filter/references/commit_range_reference_filter_spec.rb:    it 'link has valid text' do
filter/references/commit_range_reference_filter_spec.rb:      expect(doc.css('a').first.text)
filter/references/commit_range_reference_filter_spec.rb:    it 'has valid text' do
filter/references/commit_range_reference_filter_spec.rb:    it 'ignores invalid commit IDs on the referenced project' do
filter/references/commit_range_reference_filter_spec.rb:  context 'cross-project / same-namespace complete reference' do
filter/references/commit_range_reference_filter_spec.rb:    it 'links to a valid reference' do
filter/references/commit_range_reference_filter_spec.rb:      expect(doc.css('a').first.attr('href'))
filter/references/commit_range_reference_filter_spec.rb:    it 'link has valid text' do
filter/references/commit_range_reference_filter_spec.rb:      expect(doc.css('a').first.text)
filter/references/commit_range_reference_filter_spec.rb:    it 'has valid text' do
filter/references/commit_range_reference_filter_spec.rb:    it 'ignores invalid commit IDs on the referenced project' do
filter/references/commit_range_reference_filter_spec.rb:  context 'cross-project shorthand reference' do
filter/references/commit_range_reference_filter_spec.rb:    it 'links to a valid reference' do
filter/references/commit_range_reference_filter_spec.rb:      expect(doc.css('a').first.attr('href'))
filter/references/commit_range_reference_filter_spec.rb:    it 'link has valid text' do
filter/references/commit_range_reference_filter_spec.rb:      expect(doc.css('a').first.text)
filter/references/commit_range_reference_filter_spec.rb:    it 'has valid text' do
filter/references/commit_range_reference_filter_spec.rb:    it 'ignores invalid commit IDs on the referenced project' do
filter/references/commit_range_reference_filter_spec.rb:  context 'cross-project URL reference' do
filter/references/commit_range_reference_filter_spec.rb:    let(:reference) { urls.project_compare_url(project2, from: commit1.id, to: 'master') }
filter/references/commit_range_reference_filter_spec.rb:    it 'links to a valid reference' do
filter/references/commit_range_reference_filter_spec.rb:      expect(doc.css('a').first.attr('href'))
filter/references/commit_range_reference_filter_spec.rb:    it 'links with adjacent text' do
filter/references/commit_range_reference_filter_spec.rb:    it 'ignores invalid commit IDs on the referenced project' do
filter/references/commit_range_reference_filter_spec.rb:  context 'group context' do
filter/references/commit_range_reference_filter_spec.rb:    it 'ignores internal references' do
filter/references/commit_range_reference_filter_spec.rb:    it 'links to a full-path reference' do
filter/references/commit_range_reference_filter_spec.rb:      expect(reference_filter("See #{reference}", context).css('a').first.text).to eql(reference)
filter/references/commit_range_reference_filter_spec.rb:  it_behaves_like 'limits the number of filtered items' do
filter/references/snippet_reference_filter_spec.rb:require 'spec_helper'
filter/references/snippet_reference_filter_spec.rb:  it 'requires project context' do
filter/references/snippet_reference_filter_spec.rb:    expect { described_class.call('') }.to raise_error(ArgumentError, /:project/)
filter/references/snippet_reference_filter_spec.rb:    it "ignores valid references contained inside '#{elem}' element" do
filter/references/snippet_reference_filter_spec.rb:  context 'internal reference' do
filter/references/snippet_reference_filter_spec.rb:    it 'links to a valid reference' do
filter/references/snippet_reference_filter_spec.rb:      expect(doc.css('a').first.attr('href')).to eq urls
filter/references/snippet_reference_filter_spec.rb:    it 'links with adjacent text' do
filter/references/snippet_reference_filter_spec.rb:    it 'ignores invalid snippet IDs' do
filter/references/snippet_reference_filter_spec.rb:    it 'includes a title attribute' do
filter/references/snippet_reference_filter_spec.rb:      expect(doc.css('a').first.attr('title')).to eq snippet.title
filter/references/snippet_reference_filter_spec.rb:    it 'escapes the title attribute' do
filter/references/snippet_reference_filter_spec.rb:    it 'includes default classes' do
filter/references/snippet_reference_filter_spec.rb:      expect(doc.css('a').first.attr('class')).to eq 'gfm gfm-snippet has-tooltip'
filter/references/snippet_reference_filter_spec.rb:    it 'includes a data-project attribute' do
filter/references/snippet_reference_filter_spec.rb:      link = doc.css('a').first
filter/references/snippet_reference_filter_spec.rb:      expect(link).to have_attribute('data-project')
filter/references/snippet_reference_filter_spec.rb:      expect(link.attr('data-project')).to eq project.id.to_s
filter/references/snippet_reference_filter_spec.rb:    it 'includes a data-snippet attribute' do
filter/references/snippet_reference_filter_spec.rb:      link = doc.css('a').first
filter/references/snippet_reference_filter_spec.rb:      expect(link).to have_attribute('data-snippet')
filter/references/snippet_reference_filter_spec.rb:      expect(link.attr('data-snippet')).to eq snippet.id.to_s
filter/references/snippet_reference_filter_spec.rb:    it 'supports an :only_path context' do
filter/references/snippet_reference_filter_spec.rb:      link = doc.css('a').first.attr('href')
filter/references/snippet_reference_filter_spec.rb:  context 'cross-project / cross-namespace complete reference' do
filter/references/snippet_reference_filter_spec.rb:    it 'links to a valid reference' do
filter/references/snippet_reference_filter_spec.rb:      expect(doc.css('a').first.attr('href'))
filter/references/snippet_reference_filter_spec.rb:    it 'link has valid text' do
filter/references/snippet_reference_filter_spec.rb:      expect(doc.css('a').first.text).to eql(reference)
filter/references/snippet_reference_filter_spec.rb:    it 'has valid text' do
filter/references/snippet_reference_filter_spec.rb:    it 'ignores invalid snippet IDs on the referenced project' do
filter/references/snippet_reference_filter_spec.rb:    it 'ignores when attempting to reference a group with full path' do
filter/references/snippet_reference_filter_spec.rb:      create(:group, name: 'a_group')
filter/references/snippet_reference_filter_spec.rb:  context 'cross-project / same-namespace complete reference' do
filter/references/snippet_reference_filter_spec.rb:    it 'links to a valid reference' do
filter/references/snippet_reference_filter_spec.rb:      expect(doc.css('a').first.attr('href'))
filter/references/snippet_reference_filter_spec.rb:    it 'link has valid text' do
filter/references/snippet_reference_filter_spec.rb:      expect(doc.css('a').first.text).to eql("#{project2.path}$#{snippet.id}")
filter/references/snippet_reference_filter_spec.rb:    it 'has valid text' do
filter/references/snippet_reference_filter_spec.rb:    it 'ignores invalid snippet IDs on the referenced project' do
filter/references/snippet_reference_filter_spec.rb:  context 'cross-project shorthand reference' do
filter/references/snippet_reference_filter_spec.rb:    it 'links to a valid reference' do
filter/references/snippet_reference_filter_spec.rb:      expect(doc.css('a').first.attr('href'))
filter/references/snippet_reference_filter_spec.rb:    it 'link has valid text' do
filter/references/snippet_reference_filter_spec.rb:      expect(doc.css('a').first.text).to eql("#{project2.path}$#{snippet.id}")
filter/references/snippet_reference_filter_spec.rb:    it 'has valid text' do
filter/references/snippet_reference_filter_spec.rb:    it 'ignores invalid snippet IDs on the referenced project' do
filter/references/snippet_reference_filter_spec.rb:  context 'cross-project URL reference' do
filter/references/snippet_reference_filter_spec.rb:    let(:namespace) { create(:namespace, name: 'cross-reference') }
filter/references/snippet_reference_filter_spec.rb:    it 'links to a valid reference' do
filter/references/snippet_reference_filter_spec.rb:      expect(doc.css('a').first.attr('href'))
filter/references/snippet_reference_filter_spec.rb:    it 'links with adjacent text' do
filter/references/snippet_reference_filter_spec.rb:    it 'ignores invalid snippet IDs on the referenced project' do
filter/references/snippet_reference_filter_spec.rb:  context 'group context' do
filter/references/snippet_reference_filter_spec.rb:    it 'links to a valid reference' do
filter/references/snippet_reference_filter_spec.rb:      expect(result.css('a').first.attr('href')).to eq(urls.project_snippet_url(project, snippet))
filter/references/snippet_reference_filter_spec.rb:    it 'ignores internal references' do
filter/references/snippet_reference_filter_spec.rb:  context 'checking N+1' do
filter/references/snippet_reference_filter_spec.rb:    it 'does not have N+1 per multiple references per project', :use_sql_query_cache do
filter/references/snippet_reference_filter_spec.rb:      # Since we're not batching snippet queries across projects,
filter/references/feature_flag_reference_filter_spec.rb:require 'spec_helper'
filter/references/feature_flag_reference_filter_spec.rb:  it 'requires project context' do
filter/references/feature_flag_reference_filter_spec.rb:    expect { described_class.call('') }.to raise_error(ArgumentError, /:project/)
filter/references/feature_flag_reference_filter_spec.rb:    it "ignores valid references contained inside '#{elem}' element" do
filter/references/feature_flag_reference_filter_spec.rb:  context 'with internal reference' do
filter/references/feature_flag_reference_filter_spec.rb:    it 'links to a valid reference' do
filter/references/feature_flag_reference_filter_spec.rb:      expect(doc.css('a').first.attr('href')).to eq urls.edit_project_feature_flag_url(project, feature_flag)
filter/references/feature_flag_reference_filter_spec.rb:    it 'links with adjacent text' do
filter/references/feature_flag_reference_filter_spec.rb:    it 'ignores invalid feature flag IIDs' do
filter/references/feature_flag_reference_filter_spec.rb:    it 'includes a title attribute' do
filter/references/feature_flag_reference_filter_spec.rb:      expect(doc.css('a').first.attr('title')).to eq feature_flag.name
filter/references/feature_flag_reference_filter_spec.rb:    it 'escapes the title attribute' do
filter/references/feature_flag_reference_filter_spec.rb:    it 'includes default classes' do
filter/references/feature_flag_reference_filter_spec.rb:      expect(doc.css('a').first.attr('class')).to eq 'gfm gfm-feature_flag has-tooltip'
filter/references/feature_flag_reference_filter_spec.rb:    it 'includes a data-project attribute' do
filter/references/feature_flag_reference_filter_spec.rb:      link = doc.css('a').first
filter/references/feature_flag_reference_filter_spec.rb:      expect(link).to have_attribute('data-project')
filter/references/feature_flag_reference_filter_spec.rb:      expect(link.attr('data-project')).to eq project.id.to_s
filter/references/feature_flag_reference_filter_spec.rb:    it 'includes a data-feature-flag attribute' do
filter/references/feature_flag_reference_filter_spec.rb:      link = doc.css('a').first
filter/references/feature_flag_reference_filter_spec.rb:      expect(link).to have_attribute('data-feature-flag')
filter/references/feature_flag_reference_filter_spec.rb:      expect(link.attr('data-feature-flag')).to eq feature_flag.id.to_s
filter/references/feature_flag_reference_filter_spec.rb:    it 'supports an :only_path context' do
filter/references/feature_flag_reference_filter_spec.rb:      link = doc.css('a').first.attr('href')
filter/references/feature_flag_reference_filter_spec.rb:  context 'with cross-project / cross-namespace complete reference' do
filter/references/feature_flag_reference_filter_spec.rb:    it 'links to a valid reference' do
filter/references/feature_flag_reference_filter_spec.rb:      expect(doc.css('a').first.attr('href')).to eq urls.edit_project_feature_flag_url(project2, feature_flag)
filter/references/feature_flag_reference_filter_spec.rb:    it 'produces a valid text in a link' do
filter/references/feature_flag_reference_filter_spec.rb:      expect(doc.css('a').first.text).to eql(reference)
filter/references/feature_flag_reference_filter_spec.rb:    it 'produces a valid text' do
filter/references/feature_flag_reference_filter_spec.rb:    it 'ignores invalid feature flag IIDs on the referenced project' do
filter/references/feature_flag_reference_filter_spec.rb:  context 'with cross-project / same-namespace complete reference' do
filter/references/feature_flag_reference_filter_spec.rb:    it 'links to a valid reference' do
filter/references/feature_flag_reference_filter_spec.rb:      expect(doc.css('a').first.attr('href')).to eq urls.edit_project_feature_flag_url(project2, feature_flag)
filter/references/feature_flag_reference_filter_spec.rb:    it 'produces a valid text in a link' do
filter/references/feature_flag_reference_filter_spec.rb:      expect(doc.css('a').first.text).to eql("[feature_flag:#{project2.path}/#{feature_flag.iid}]")
filter/references/feature_flag_reference_filter_spec.rb:    it 'produces a valid text' do
filter/references/feature_flag_reference_filter_spec.rb:    it 'ignores invalid feature flag IIDs on the referenced project' do
filter/references/feature_flag_reference_filter_spec.rb:  context 'with cross-project shorthand reference' do
filter/references/feature_flag_reference_filter_spec.rb:    it 'links to a valid reference' do
filter/references/feature_flag_reference_filter_spec.rb:      expect(doc.css('a').first.attr('href')).to eq urls.edit_project_feature_flag_url(project2, feature_flag)
filter/references/feature_flag_reference_filter_spec.rb:    it 'produces a valid text in a link' do
filter/references/feature_flag_reference_filter_spec.rb:      expect(doc.css('a').first.text).to eql("[feature_flag:#{project2.path}/#{feature_flag.iid}]")
filter/references/feature_flag_reference_filter_spec.rb:    it 'produces a valid text' do
filter/references/feature_flag_reference_filter_spec.rb:    it 'ignores invalid feature flag IDs on the referenced project' do
filter/references/feature_flag_reference_filter_spec.rb:  context 'with cross-project URL reference' do
filter/references/feature_flag_reference_filter_spec.rb:    let_it_be(:namespace) { create(:namespace, name: 'cross-reference') }
filter/references/feature_flag_reference_filter_spec.rb:    it 'links to a valid reference' do
filter/references/feature_flag_reference_filter_spec.rb:      expect(doc.css('a').first.attr('href')).to eq urls.edit_project_feature_flag_url(project2, feature_flag)
filter/references/feature_flag_reference_filter_spec.rb:    it 'links with adjacent text' do
filter/references/feature_flag_reference_filter_spec.rb:    it 'ignores invalid feature flag IIDs on the referenced project' do
filter/references/feature_flag_reference_filter_spec.rb:  context 'with group context' do
filter/references/feature_flag_reference_filter_spec.rb:    it 'links to a valid reference' do
filter/references/feature_flag_reference_filter_spec.rb:      expect(result.css('a').first.attr('href')).to eq(urls.edit_project_feature_flag_url(project, feature_flag))
filter/references/feature_flag_reference_filter_spec.rb:    it 'ignores internal references' do
filter/references/feature_flag_reference_filter_spec.rb:  context 'when checking N+1' do
filter/references/feature_flag_reference_filter_spec.rb:    it 'does not have N+1 per multiple references per project', :use_sql_query_cache do
filter/references/project_reference_filter_spec.rb:require 'spec_helper'
filter/references/project_reference_filter_spec.rb:  it_behaves_like 'user reference or project reference'
filter/references/project_reference_filter_spec.rb:  it 'ignores invalid projects' do
filter/references/project_reference_filter_spec.rb:  context 'when invalid reference strings are very long' do
filter/references/project_reference_filter_spec.rb:    shared_examples_for 'fails fast' do |ref_string|
filter/references/project_reference_filter_spec.rb:      it 'fails fast for long strings' do
filter/references/project_reference_filter_spec.rb:    it_behaves_like 'fails fast', 'A' * 50000
filter/references/project_reference_filter_spec.rb:    it_behaves_like 'fails fast', '/a' * 50000
filter/references/project_reference_filter_spec.rb:    it_behaves_like 'fails fast', "mailto:#{'a-' * 499_000}@aaaaaaaa..aaaaaaaa.example.com"
filter/references/project_reference_filter_spec.rb:  it 'allows references with text after the > character' do
filter/references/project_reference_filter_spec.rb:    expect(doc.css('a').first.attr('href')).to eq urls.project_url(subject)
filter/references/project_reference_filter_spec.rb:    it "ignores valid references contained inside '#{elem}' element" do
filter/references/project_reference_filter_spec.rb:  it 'includes default classes' do
filter/references/project_reference_filter_spec.rb:    expect(doc.css('a').first.attr('class')).to eq 'gfm gfm-project has-tooltip'
filter/references/project_reference_filter_spec.rb:  context 'in group context' do
filter/references/project_reference_filter_spec.rb:    it 'supports mentioning a project' do
filter/references/project_reference_filter_spec.rb:      expect(doc.css('a').first.attr('href')).to eq urls.project_url(project)
filter/references/project_reference_filter_spec.rb:    it 'supports mentioning a project in a nested group' do
filter/references/project_reference_filter_spec.rb:      expect(doc.css('a').first.attr('href')).to eq urls.project_url(nested_project)
filter/references/project_reference_filter_spec.rb:  describe '#projects_hash' do
filter/references/project_reference_filter_spec.rb:    it 'returns a Hash containing all Projects' do
filter/references/project_reference_filter_spec.rb:  describe '#projects' do
filter/references/project_reference_filter_spec.rb:    it 'returns the projects mentioned in a document' do
filter/references/project_reference_filter_spec.rb:  context 'checking N+1' do
filter/references/project_reference_filter_spec.rb:    it 'does not have N+1 per multiple project references', :use_sql_query_cache do
filter/references/project_reference_filter_spec.rb:  it_behaves_like 'limits the number of filtered items' do
filter/references/merge_request_reference_filter_spec.rb:require 'spec_helper'
filter/references/merge_request_reference_filter_spec.rb:  it 'requires project context' do
filter/references/merge_request_reference_filter_spec.rb:    expect { described_class.call('') }.to raise_error(ArgumentError, /:project/)
filter/references/merge_request_reference_filter_spec.rb:    it "ignores valid references contained inside '#{elem}' element" do
filter/references/merge_request_reference_filter_spec.rb:  describe 'performance' do
filter/references/merge_request_reference_filter_spec.rb:    let(:another_merge) { create(:merge_request, source_project: project, source_branch: 'fix') }
filter/references/merge_request_reference_filter_spec.rb:    it 'does not have a N+1 query problem' do
filter/references/merge_request_reference_filter_spec.rb:  describe 'all references' do
filter/references/merge_request_reference_filter_spec.rb:    let(:tag_el) { doc.css('a').first }
filter/references/merge_request_reference_filter_spec.rb:    it 'adds merge request iid' do
filter/references/merge_request_reference_filter_spec.rb:    it 'adds project data attribute with project id' do
filter/references/merge_request_reference_filter_spec.rb:    it 'does not add `has-tooltip` class' do
filter/references/merge_request_reference_filter_spec.rb:      expect(tag_el["class"]).not_to include('has-tooltip')
filter/references/merge_request_reference_filter_spec.rb:  context 'internal reference' do
filter/references/merge_request_reference_filter_spec.rb:    it 'links to a valid reference' do
filter/references/merge_request_reference_filter_spec.rb:      expect(doc.css('a').first.attr('href')).to eq urls
filter/references/merge_request_reference_filter_spec.rb:    it 'links with adjacent text' do
filter/references/merge_request_reference_filter_spec.rb:    it 'ignores invalid merge IDs' do
filter/references/merge_request_reference_filter_spec.rb:    it 'ignores out-of-bounds merge request IDs on the referenced project' do
filter/references/merge_request_reference_filter_spec.rb:    it 'has the MR title in the title attribute' do
filter/references/merge_request_reference_filter_spec.rb:      expect(doc.css('a').first.attr('title')).to eq(merge.title)
filter/references/merge_request_reference_filter_spec.rb:    it 'escapes the title attribute' do
filter/references/merge_request_reference_filter_spec.rb:    it 'includes default classes, without tooltip' do
filter/references/merge_request_reference_filter_spec.rb:      expect(doc.css('a').first.attr('class')).to eq 'gfm gfm-merge_request'
filter/references/merge_request_reference_filter_spec.rb:    it 'includes a data-project attribute' do
filter/references/merge_request_reference_filter_spec.rb:      link = doc.css('a').first
filter/references/merge_request_reference_filter_spec.rb:      expect(link).to have_attribute('data-project')
filter/references/merge_request_reference_filter_spec.rb:      expect(link.attr('data-project')).to eq project.id.to_s
filter/references/merge_request_reference_filter_spec.rb:    it 'includes a data-merge-request attribute' do
filter/references/merge_request_reference_filter_spec.rb:      link = doc.css('a').first
filter/references/merge_request_reference_filter_spec.rb:      expect(link).to have_attribute('data-merge-request')
filter/references/merge_request_reference_filter_spec.rb:      expect(link.attr('data-merge-request')).to eq merge.id.to_s
filter/references/merge_request_reference_filter_spec.rb:    it 'includes a data-reference-format attribute' do
filter/references/merge_request_reference_filter_spec.rb:      link = doc.css('a').first
filter/references/merge_request_reference_filter_spec.rb:      expect(link).to have_attribute('data-reference-format')
filter/references/merge_request_reference_filter_spec.rb:      expect(link.attr('data-reference-format')).to eq('+')
filter/references/merge_request_reference_filter_spec.rb:      expect(link.attr('href')).to eq(merge_request_url)
filter/references/merge_request_reference_filter_spec.rb:    it 'includes a data-reference-format attribute for URL references' do
filter/references/merge_request_reference_filter_spec.rb:      link = doc.css('a').first
filter/references/merge_request_reference_filter_spec.rb:      expect(link).to have_attribute('data-reference-format')
filter/references/merge_request_reference_filter_spec.rb:      expect(link.attr('data-reference-format')).to eq('+')
filter/references/merge_request_reference_filter_spec.rb:      expect(link.attr('href')).to eq(merge_request_url)
filter/references/merge_request_reference_filter_spec.rb:    it 'includes a data-reference-format attribute for extended summary URL references' do
filter/references/merge_request_reference_filter_spec.rb:      link = doc.css('a').first
filter/references/merge_request_reference_filter_spec.rb:      expect(link).to have_attribute('data-reference-format')
filter/references/merge_request_reference_filter_spec.rb:      expect(link.attr('data-reference-format')).to eq('+s')
filter/references/merge_request_reference_filter_spec.rb:      expect(link.attr('href')).to eq(merge_request_url)
filter/references/merge_request_reference_filter_spec.rb:    it 'supports an :only_path context' do
filter/references/merge_request_reference_filter_spec.rb:      link = doc.css('a').first.attr('href')
filter/references/merge_request_reference_filter_spec.rb:  context 'cross-project / cross-namespace complete reference' do
filter/references/merge_request_reference_filter_spec.rb:    it 'links to a valid reference' do
filter/references/merge_request_reference_filter_spec.rb:      expect(doc.css('a').first.attr('href'))
filter/references/merge_request_reference_filter_spec.rb:    it 'link has valid text' do
filter/references/merge_request_reference_filter_spec.rb:      expect(doc.css('a').first.text).to eq(reference)
filter/references/merge_request_reference_filter_spec.rb:    it 'has valid text' do
filter/references/merge_request_reference_filter_spec.rb:    it 'has correct data attributes' do
filter/references/merge_request_reference_filter_spec.rb:      link = doc.css('a').first
filter/references/merge_request_reference_filter_spec.rb:      expect(link.attr('data-project')).to eq project2.id.to_s
filter/references/merge_request_reference_filter_spec.rb:      expect(link.attr('data-project-path')).to eq project2.full_path
filter/references/merge_request_reference_filter_spec.rb:      expect(link.attr('data-iid')).to eq merge.iid.to_s
filter/references/merge_request_reference_filter_spec.rb:    it 'ignores invalid merge IDs on the referenced project' do
filter/references/merge_request_reference_filter_spec.rb:  context 'cross-project / same-namespace complete reference' do
filter/references/merge_request_reference_filter_spec.rb:    it 'links to a valid reference' do
filter/references/merge_request_reference_filter_spec.rb:      expect(doc.css('a').first.attr('href'))
filter/references/merge_request_reference_filter_spec.rb:    it 'link has valid text' do
filter/references/merge_request_reference_filter_spec.rb:      expect(doc.css('a').first.text).to eq("#{project2.path}!#{merge.iid}")
filter/references/merge_request_reference_filter_spec.rb:    it 'has valid text' do
filter/references/merge_request_reference_filter_spec.rb:    it 'ignores invalid merge IDs on the referenced project' do
filter/references/merge_request_reference_filter_spec.rb:  context 'cross-project shorthand reference' do
filter/references/merge_request_reference_filter_spec.rb:    it 'links to a valid reference' do
filter/references/merge_request_reference_filter_spec.rb:      expect(doc.css('a').first.attr('href'))
filter/references/merge_request_reference_filter_spec.rb:    it 'link has valid text' do
filter/references/merge_request_reference_filter_spec.rb:      expect(doc.css('a').first.text).to eq("#{project2.path}!#{merge.iid}")
filter/references/merge_request_reference_filter_spec.rb:    it 'has valid text' do
filter/references/merge_request_reference_filter_spec.rb:    it 'ignores invalid merge IDs on the referenced project' do
filter/references/merge_request_reference_filter_spec.rb:  context 'URL reference for a commit' do
filter/references/merge_request_reference_filter_spec.rb:    it 'links to a valid reference' do
filter/references/merge_request_reference_filter_spec.rb:      expect(doc.css('a').first.attr('href'))
filter/references/merge_request_reference_filter_spec.rb:    it 'commit ref tag is valid' do
filter/references/merge_request_reference_filter_spec.rb:      commit_ref_tag = doc.css('a').first.css('span.gfm.gfm-commit')
filter/references/merge_request_reference_filter_spec.rb:    it 'has valid text' do
filter/references/merge_request_reference_filter_spec.rb:    it 'ignores invalid commit short_ids on link text' do
filter/references/merge_request_reference_filter_spec.rb:  context 'cross-project URL reference' do
filter/references/merge_request_reference_filter_spec.rb:    let(:namespace) { create(:namespace, name: 'cross-reference') }
filter/references/merge_request_reference_filter_spec.rb:    let(:reference) { urls.project_merge_request_url(project2, merge) + '/diffs#note_123' }
filter/references/merge_request_reference_filter_spec.rb:    it 'links to a valid reference' do
filter/references/merge_request_reference_filter_spec.rb:      expect(doc.css('a').first.attr('href'))
filter/references/merge_request_reference_filter_spec.rb:    it 'links with adjacent text' do
filter/references/merge_request_reference_filter_spec.rb:  context 'group context' do
filter/references/merge_request_reference_filter_spec.rb:    it 'links to a valid reference' do
filter/references/merge_request_reference_filter_spec.rb:      expect(result.css('a').first.attr('href')).to eq(urls.project_merge_request_url(project, merge))
filter/references/merge_request_reference_filter_spec.rb:  context 'checking N+1' do
filter/references/merge_request_reference_filter_spec.rb:    let(:merge_request1) { create(:merge_request, source_project: project, source_branch: 'branch1') }
filter/references/merge_request_reference_filter_spec.rb:    let(:merge_request2) { create(:merge_request, source_project: project, source_branch: 'branch2') }
filter/references/merge_request_reference_filter_spec.rb:    it 'does not have a N+1 query problem' do
filter/minimum_markdown_sanitization_filter_spec.rb:require 'spec_helper'
filter/minimum_markdown_sanitization_filter_spec.rb:  it 'sanitizes tags that are not allowed' do
filter/minimum_markdown_sanitization_filter_spec.rb:    act = list.map { |tag| "<#{tag}>#{tag}</#{tag}>" }.join(' ')
filter/minimum_markdown_sanitization_filter_spec.rb:    exp = list.map { |tag| tag }.join(' ')
filter/minimum_markdown_sanitization_filter_spec.rb:    expect(filter(act).to_html.squeeze(' ')).to eq exp
filter/minimum_markdown_sanitization_filter_spec.rb:  it 'sanitizes tag attributes' do
filter/minimum_markdown_sanitization_filter_spec.rb:  it 'allows allowlisted HTML tags from the user' do
filter/minimum_markdown_sanitization_filter_spec.rb:    act = list.map { |tag| "<#{tag}>#{tag}</#{tag}>" }.join(' ')
filter/minimum_markdown_sanitization_filter_spec.rb:    expect(filter(act).to_html.squeeze(' ')).to eq act
filter/minimum_markdown_sanitization_filter_spec.rb:  it 'sanitizes `class` attribute on any element' do
filter/minimum_markdown_sanitization_filter_spec.rb:  it 'sanitizes `id` attribute on any element' do
filter/minimum_markdown_sanitization_filter_spec.rb:  it 'only allows http and https protocols' do
filter/minimum_markdown_sanitization_filter_spec.rb:  it_behaves_like 'does not use pipeline timing check'
filter/minimum_markdown_sanitization_filter_spec.rb:  it_behaves_like 'a filter timeout' do
filter/minimum_markdown_sanitization_filter_spec.rb:    let(:text) { 'text' }
filter/table_of_contents_legacy_filter_spec.rb:require 'spec_helper'
filter/table_of_contents_legacy_filter_spec.rb:  it 'does nothing when :no_header_anchors is truthy' do
filter/table_of_contents_legacy_filter_spec.rb:    exp = act = header(1, 'Header')
filter/table_of_contents_legacy_filter_spec.rb:  it 'does nothing with empty headers' do
filter/table_of_contents_legacy_filter_spec.rb:      expect(doc.css("h#{i} a").first.attr('id')).to eq "user-content-header-#{i}"
filter/table_of_contents_legacy_filter_spec.rb:  describe 'anchor tag' do
filter/table_of_contents_legacy_filter_spec.rb:    it 'has an `anchor` class' do
filter/table_of_contents_legacy_filter_spec.rb:      doc = filter(header(1, 'Header'), context)
filter/table_of_contents_legacy_filter_spec.rb:      expect(doc.css('h1 a').first.attr('class')).to eq 'anchor'
filter/table_of_contents_legacy_filter_spec.rb:    it 'has a namespaced id' do
filter/table_of_contents_legacy_filter_spec.rb:      doc = filter(header(1, 'Header'), context)
filter/table_of_contents_legacy_filter_spec.rb:      expect(doc.css('h1 a').first.attr('id')).to eq 'user-content-header'
filter/table_of_contents_legacy_filter_spec.rb:    it 'links to the non-namespaced id' do
filter/table_of_contents_legacy_filter_spec.rb:      doc = filter(header(1, 'Header'), context)
filter/table_of_contents_legacy_filter_spec.rb:      expect(doc.css('h1 a').first.attr('href')).to eq '#header'
filter/table_of_contents_legacy_filter_spec.rb:    describe 'generated IDs' do
filter/table_of_contents_legacy_filter_spec.rb:      it 'translates spaces to dashes' do
filter/table_of_contents_legacy_filter_spec.rb:        doc = filter(header(1, 'This header has spaces in it'), context)
filter/table_of_contents_legacy_filter_spec.rb:        expect(doc.css('h1 a').first.attr('href')).to eq '#this-header-has-spaces-in-it'
filter/table_of_contents_legacy_filter_spec.rb:      it 'squeezes multiple spaces and dashes' do
filter/table_of_contents_legacy_filter_spec.rb:        doc = filter(header(1, 'This---header     is poorly-formatted'), context)
filter/table_of_contents_legacy_filter_spec.rb:        expect(doc.css('h1 a').first.attr('href')).to eq '#this-header-is-poorly-formatted'
filter/table_of_contents_legacy_filter_spec.rb:      it 'removes punctuation' do
filter/table_of_contents_legacy_filter_spec.rb:        expect(doc.css('h1 a').first.attr('href')).to eq '#this-header-is-filled-with-punctuation'
filter/table_of_contents_legacy_filter_spec.rb:      it 'removes any leading or trailing spaces' do
filter/table_of_contents_legacy_filter_spec.rb:        expect(doc.css('h1 a').first.attr('href')).to eq '#title-with-spaces'
filter/table_of_contents_legacy_filter_spec.rb:      it 'appends a unique number to duplicates' do
filter/table_of_contents_legacy_filter_spec.rb:        doc = filter(header(1, 'One') + header(2, 'One'), context)
filter/table_of_contents_legacy_filter_spec.rb:        expect(doc.css('h1 a').first.attr('href')).to eq '#one'
filter/table_of_contents_legacy_filter_spec.rb:        expect(doc.css('h2 a').first.attr('href')).to eq '#one-1'
filter/table_of_contents_legacy_filter_spec.rb:      it 'prepends a prefix to digits-only ids' do
filter/table_of_contents_legacy_filter_spec.rb:        expect(doc.css('h1 a').first.attr('href')).to eq '#anchor-123'
filter/table_of_contents_legacy_filter_spec.rb:        expect(doc.css('h2 a').first.attr('href')).to eq '#anchor-10'
filter/table_of_contents_legacy_filter_spec.rb:      it 'supports Unicode' do
filter/table_of_contents_legacy_filter_spec.rb:        doc = filter(header(1, ''), context)
filter/table_of_contents_legacy_filter_spec.rb:        expect(doc.css('h1 a').first.attr('id')).to eq 'user-content-'
filter/table_of_contents_legacy_filter_spec.rb:        expect(doc.css('h1 a').first.attr('href')).to eq "##{CGI.escape('')}"
filter/table_of_contents_legacy_filter_spec.rb:      it 'limits header href length with 255 characters' do
filter/table_of_contents_legacy_filter_spec.rb:        doc = filter(header(1, 'a' * 500), context)
filter/table_of_contents_legacy_filter_spec.rb:        expect(doc.css('h1 a').first.attr('href')).to eq "##{'a' * 255}"
filter/table_of_contents_legacy_filter_spec.rb:  describe 'result' do
filter/table_of_contents_legacy_filter_spec.rb:    let(:results) { result(header(1, 'Header 1') + header(2, 'Header 2')) }
filter/table_of_contents_legacy_filter_spec.rb:    it 'is contained within a `ul` element' do
filter/table_of_contents_legacy_filter_spec.rb:      expect(doc.children.first.name).to eq 'ul'
filter/table_of_contents_legacy_filter_spec.rb:      expect(doc.children.first.attr('class')).to eq 'section-nav'
filter/table_of_contents_legacy_filter_spec.rb:    it 'contains an `li` element for each header' do
filter/table_of_contents_legacy_filter_spec.rb:      expect(doc.css('li').length).to eq 2
filter/table_of_contents_legacy_filter_spec.rb:      links = doc.css('li a')
filter/table_of_contents_legacy_filter_spec.rb:      expect(links.first.attr('href')).to eq '#header-1'
filter/table_of_contents_legacy_filter_spec.rb:      expect(links.first.text).to eq 'Header 1'
filter/table_of_contents_legacy_filter_spec.rb:      expect(links.last.attr('href')).to eq '#header-2'
filter/table_of_contents_legacy_filter_spec.rb:      expect(links.last.text).to eq 'Header 2'
filter/table_of_contents_legacy_filter_spec.rb:    context 'when table of contents nesting' do
filter/table_of_contents_legacy_filter_spec.rb:          header(1, 'Header 1') +
filter/table_of_contents_legacy_filter_spec.rb:          header(2, 'Header 1-1') +
filter/table_of_contents_legacy_filter_spec.rb:          header(3, 'Header 1-1-1') +
filter/table_of_contents_legacy_filter_spec.rb:          header(2, 'Header 1-2') +
filter/table_of_contents_legacy_filter_spec.rb:          header(1, 'Header 2') +
filter/table_of_contents_legacy_filter_spec.rb:          header(2, 'Header 2-1')
filter/table_of_contents_legacy_filter_spec.rb:      it 'keeps list levels regarding header levels' do
filter/table_of_contents_legacy_filter_spec.rb:        items = doc.css('li')
filter/table_of_contents_legacy_filter_spec.rb:        expect(items[0].ancestors).to satisfy_none { |node| node.name == 'li' }
filter/table_of_contents_legacy_filter_spec.rb:        expect(items[4].ancestors).to satisfy_none { |node| node.name == 'li' }
filter/table_of_contents_legacy_filter_spec.rb:    context 'when header text contains escaped content' do
filter/table_of_contents_legacy_filter_spec.rb:      let(:content) { '&lt;img src="x" onerror="alert(42)"&gt;' }
filter/table_of_contents_legacy_filter_spec.rb:      it 'outputs escaped content' do
filter/task_list_filter_spec.rb:require 'spec_helper'
filter/task_list_filter_spec.rb:  it 'adds `<task-button></task-button>` to every list item' do
filter/task_list_filter_spec.rb:    expect(doc.xpath('.//li//task-button').count).to eq(2)
filter/task_list_filter_spec.rb:  it 'ignores checkbox on following line' do
filter/task_list_filter_spec.rb:    expect(doc.xpath('.//li//input').count).to eq(0)
filter/task_list_filter_spec.rb:  describe 'inapplicable list items' do
filter/task_list_filter_spec.rb:    shared_examples 'a valid inapplicable task list item' do |html|
filter/task_list_filter_spec.rb:        expect(doc.css('li.inapplicable input[data-inapplicable]').count).to eq(1)
filter/task_list_filter_spec.rb:        expect(doc.css('li.inapplicable > s').count).to eq(1)
filter/task_list_filter_spec.rb:    shared_examples 'an invalid inapplicable task list item' do |html|
filter/task_list_filter_spec.rb:        expect(doc.css('li.inapplicable input[data-inapplicable]').count).to eq(0)
filter/task_list_filter_spec.rb:    it_behaves_like 'a valid inapplicable task list item', '[~] foobar'
filter/task_list_filter_spec.rb:    it_behaves_like 'a valid inapplicable task list item', '[~] foo <em>bar</em>'
filter/task_list_filter_spec.rb:    it_behaves_like 'an invalid inapplicable task list item', '[ ] foobar'
filter/task_list_filter_spec.rb:    it_behaves_like 'an invalid inapplicable task list item', '[x] foobar'
filter/task_list_filter_spec.rb:    it_behaves_like 'an invalid inapplicable task list item', 'foo [~] bar'
filter/task_list_filter_spec.rb:    it 'does not wrap a sublist with <s>' do
filter/task_list_filter_spec.rb:      html = '[~] foo <em>bar</em>\n<ol><li>sublist</li></ol>'
filter/task_list_filter_spec.rb:      expect(doc.to_html).to include('<s>foo <em>bar</em>\n</s>')
filter/task_list_filter_spec.rb:      expect(doc.css('li.inapplicable input[data-inapplicable]').count).to eq(1)
filter/task_list_filter_spec.rb:      expect(doc.css('li.inapplicable > s').count).to eq(1)
filter/task_list_filter_spec.rb:  it_behaves_like 'pipeline timing check'
filter/gollum_tags_filter_spec.rb:require 'spec_helper'
filter/gollum_tags_filter_spec.rb:  shared_examples 'gollum tag parsing' do
filter/gollum_tags_filter_spec.rb:    context 'when tag is only a page name or url' do
filter/gollum_tags_filter_spec.rb:      it 'creates a link' do
filter/gollum_tags_filter_spec.rb:        tag = '[[page name or url]]'
filter/gollum_tags_filter_spec.rb:        expect(doc.at_css('a').text).to eq 'page name or url'
filter/gollum_tags_filter_spec.rb:        expect(doc.at_css('a')['href']).to eq 'page%20name%20or%20url'
filter/gollum_tags_filter_spec.rb:        expect(doc.at_css('a')['data-wikilink']).to eq 'true'
filter/gollum_tags_filter_spec.rb:    context 'when tag is link text and a page name or url' do
filter/gollum_tags_filter_spec.rb:      it 'creates a link' do
filter/gollum_tags_filter_spec.rb:        tag = '[[link-text|http://example.com/pdfs/gollum.pdf]]'
filter/gollum_tags_filter_spec.rb:        expect(doc.at_css('a').text).to eq 'link-text'
filter/gollum_tags_filter_spec.rb:        expect(doc.at_css('a')['href']).to eq 'http://example.com/pdfs/gollum.pdf'
filter/gollum_tags_filter_spec.rb:        expect(doc.at_css('a')['data-wikilink']).to eq 'true'
filter/gollum_tags_filter_spec.rb:    it 'inside back ticks will be exempt from linkification' do
filter/gollum_tags_filter_spec.rb:      doc = filter('<code>[[link-in-backticks]]</code>', context)
filter/gollum_tags_filter_spec.rb:      expect(doc.at_css('code').text).to eq '[[link-in-backticks]]'
filter/gollum_tags_filter_spec.rb:    it 'leaves other text content untouched' do
filter/gollum_tags_filter_spec.rb:      doc = filter('This is [[a link|link]]', context)
filter/gollum_tags_filter_spec.rb:      expect(doc.to_html).to eq 'This is <a href="link" data-wikilink="true">a link</a>'
filter/gollum_tags_filter_spec.rb:    context 'sanitization of HTML entities' do
filter/gollum_tags_filter_spec.rb:      it 'does not unescape HTML entities' do
filter/gollum_tags_filter_spec.rb:        doc = filter('This is [[a link|&lt;script&gt;alert(0)&lt;/script&gt;]]', context)
filter/gollum_tags_filter_spec.rb:        expect(doc.to_html).to eq 'This is <a href="&lt;script&gt;alert(0)&lt;/script&gt;" data-wikilink="true">a link</a>'
filter/gollum_tags_filter_spec.rb:      it 'does not unescape HTML entities in the link text' do
filter/gollum_tags_filter_spec.rb:        doc = filter('This is [[&lt;script&gt;alert(0)&lt;/script&gt;|link]]', context)
filter/gollum_tags_filter_spec.rb:        expect(doc.to_html).to eq 'This is <a href="link" data-wikilink="true">&lt;script&gt;alert(0)&lt;/script&gt;</a>'
filter/gollum_tags_filter_spec.rb:      it 'does not unescape HTML entities outside the link text' do
filter/gollum_tags_filter_spec.rb:        doc = filter('This is &lt;script&gt;alert(0)&lt;/script&gt; [[a link|link]]', context)
filter/gollum_tags_filter_spec.rb:        expect(doc.to_html).to eq 'This is &lt;script&gt;alert(0)&lt;/script&gt; <a href="link" data-wikilink="true">a link</a>'
filter/gollum_tags_filter_spec.rb:    it 'sanitizes the href attribute (case 1)' do
filter/gollum_tags_filter_spec.rb:      tag = '[[a|http:\'"injected=attribute&gt;&lt;img/src="0"onerror="alert(0)"&gt;https://gitlab.com/gitlab-org/gitlab/-/issues/1]]'
filter/gollum_tags_filter_spec.rb:      expect(doc.at_css('a').to_html).to eq '<a href="http:\'%22injected=attribute&gt;&lt;img/src=%220%22onerror=%22alert(0)%22&gt;https://gitlab.com/gitlab-org/gitlab/-/issues/1" data-wikilink="true">a</a>'
filter/gollum_tags_filter_spec.rb:    it 'sanitizes the href attribute (case 2)' do
filter/gollum_tags_filter_spec.rb:      tag = '<i>[[a|\'"&gt;&lt;svg&gt;&lt;i/class=gl-show-field-errors&gt;&lt;input/title="&lt;script&gt;alert(0)&lt;/script&gt;"/&gt;&lt;/svg&gt;https://gitlab.com/gitlab-org/gitlab/-/issues/1]]'
filter/gollum_tags_filter_spec.rb:      expect(doc.at_css('i a').to_html).to eq "<a href=\"'%22&gt;&lt;svg&gt;&lt;i/class=gl-show-field-errors&gt;&lt;input/title=%22&lt;script&gt;alert(0)&lt;/script&gt;%22/&gt;&lt;/svg&gt;https://gitlab.com/gitlab-org/gitlab/-/issues/1\" data-wikilink=\"true\">a</a>"
filter/gollum_tags_filter_spec.rb:    it 'protects against malicious input' do
filter/gollum_tags_filter_spec.rb:      text = "]#{'[[a' * 200000}[]"
filter/gollum_tags_filter_spec.rb:  it_behaves_like 'gollum tag parsing' do
filter/gollum_tags_filter_spec.rb:  it_behaves_like 'gollum tag parsing' do
filter/gollum_tags_filter_spec.rb:  context 'when parsing default markdown' do
filter/gollum_tags_filter_spec.rb:    it 'ignores the tag' do
filter/gollum_tags_filter_spec.rb:      tag = '[[page name or url]]'
filter/gollum_tags_filter_spec.rb:      expect(doc.at_css('a')).to be_nil
filter/gollum_tags_filter_spec.rb:  it_behaves_like 'pipeline timing check'
filter/gollum_tags_filter_spec.rb:  it_behaves_like 'limits the number of filtered items', context: { pipeline: :ascii_doc } do
filter/gollum_tags_filter_spec.rb:    let(:text) { '[[page name or url]] [[page name or url]] [[page name or url]]' }
filter/gollum_tags_filter_spec.rb:    let(:ends_with) { '</a> [[page name or url]]' }
filter/sanitize_link_filter_spec.rb:require 'spec_helper'
filter/sanitize_link_filter_spec.rb:  it_behaves_like 'XSS prevention'
filter/sanitize_link_filter_spec.rb:  it_behaves_like 'sanitize link'
filter/sanitize_link_filter_spec.rb:  it_behaves_like 'does not use pipeline timing check'
filter/sanitize_link_filter_spec.rb:  it_behaves_like 'a filter timeout' do
filter/sanitize_link_filter_spec.rb:    let(:text) { 'text' }
filter/normalize_source_filter_spec.rb:require 'spec_helper'
filter/normalize_source_filter_spec.rb:  it 'removes the UTF8 BOM from the beginning of the text' do
filter/normalize_source_filter_spec.rb:    expect(output).to match '---'
filter/normalize_source_filter_spec.rb:  it 'does not remove those characters from anywhere else in the text' do
filter/audio_link_filter_spec.rb:require 'spec_helper'
filter/audio_link_filter_spec.rb:    return '<img/>' if path.nil?
filter/audio_link_filter_spec.rb:  shared_examples 'an audio element' do
filter/audio_link_filter_spec.rb:    it 'replaces the image tag with an audio tag' do
filter/audio_link_filter_spec.rb:      expect(container.name).to eq 'span'
filter/audio_link_filter_spec.rb:      expect(container['class']).to eq 'media-container audio-container'
filter/audio_link_filter_spec.rb:      expect(audio.name).to eq 'audio'
filter/audio_link_filter_spec.rb:      expect(audio['src']).to eq src
filter/audio_link_filter_spec.rb:      expect(link.name).to eq 'a'
filter/audio_link_filter_spec.rb:      expect(link['href']).to eq src
filter/audio_link_filter_spec.rb:      expect(link['target']).to eq '_blank'
filter/audio_link_filter_spec.rb:  shared_examples 'an unchanged element' do |ext|
filter/audio_link_filter_spec.rb:    it 'leaves the document unchanged' do
filter/audio_link_filter_spec.rb:      expect(element.name).to eq 'img'
filter/audio_link_filter_spec.rb:      expect(element['src']).to eq src
filter/audio_link_filter_spec.rb:  context 'when the element src has an audio extension' do
filter/audio_link_filter_spec.rb:      it_behaves_like 'an audio element' do
filter/audio_link_filter_spec.rb:      it_behaves_like 'an audio element' do
filter/audio_link_filter_spec.rb:  context 'when the element has no src attribute' do
filter/audio_link_filter_spec.rb:    it_behaves_like 'an unchanged element'
filter/audio_link_filter_spec.rb:  context 'when the element src is an image' do
filter/audio_link_filter_spec.rb:    let(:src) { '/path/my_image.jpg' }
filter/audio_link_filter_spec.rb:    it_behaves_like 'an unchanged element'
filter/audio_link_filter_spec.rb:  context 'when the element src has an invalid file extension' do
filter/audio_link_filter_spec.rb:    let(:src) { '/path/my_audio.somewav' }
filter/audio_link_filter_spec.rb:    it_behaves_like 'an unchanged element'
filter/audio_link_filter_spec.rb:  context 'when data-canonical-src is empty' do
filter/audio_link_filter_spec.rb:    context 'and src is audio' do
filter/audio_link_filter_spec.rb:      let(:src) { '/path/audio.wav' }
filter/audio_link_filter_spec.rb:      it_behaves_like 'an audio element'
filter/audio_link_filter_spec.rb:    context 'and src is an image' do
filter/audio_link_filter_spec.rb:      let(:src) { '/path/my_image.jpg' }
filter/audio_link_filter_spec.rb:      it_behaves_like 'an unchanged element'
filter/audio_link_filter_spec.rb:  context 'when data-canonical-src is set' do
filter/audio_link_filter_spec.rb:    it 'uses the correct src' do
filter/audio_link_filter_spec.rb:      proxy_src = 'https://assets.example.com/6d8b63'
filter/audio_link_filter_spec.rb:      canonical_src = 'http://example.com/test.wav'
filter/audio_link_filter_spec.rb:      expect(container['class']).to eq 'media-container audio-container'
filter/audio_link_filter_spec.rb:      expect(audio['src']).to eq proxy_src
filter/audio_link_filter_spec.rb:      expect(audio['data-canonical-src']).to eq canonical_src
filter/audio_link_filter_spec.rb:      expect(link['href']).to eq proxy_src
filter/audio_link_filter_spec.rb:  it_behaves_like 'pipeline timing check'
filter/front_matter_filter_spec.rb:require 'spec_helper'
filter/front_matter_filter_spec.rb:  it 'allows for `encoding:` before the front matter' do
filter/front_matter_filter_spec.rb:    expect(output).not_to match 'encoding'
filter/front_matter_filter_spec.rb:  it 'converts YAML front matter to a fenced code block' do
filter/front_matter_filter_spec.rb:      expect(output).not_to include '---'
filter/front_matter_filter_spec.rb:  it 'converts TOML frontmatter to a fenced code block' do
filter/front_matter_filter_spec.rb:      expect(output).not_to include '+++'
filter/front_matter_filter_spec.rb:  it 'converts JSON front matter to a fenced code block' do
filter/front_matter_filter_spec.rb:      expect(output).not_to include ';;;'
filter/front_matter_filter_spec.rb:  it 'converts arbitrary front matter to a fenced code block' do
filter/front_matter_filter_spec.rb:      expect(output).not_to include '---arbitrary'
filter/front_matter_filter_spec.rb:  context 'source position mapping' do
filter/front_matter_filter_spec.rb:    it 'keeps spaces before and after' do
filter/front_matter_filter_spec.rb:    it 'keeps an empty line in place of the encoding' do
filter/front_matter_filter_spec.rb:  context 'on content without front matter' do
filter/front_matter_filter_spec.rb:    it 'returns the content unmodified' do
filter/front_matter_filter_spec.rb:  context 'on front matter without content' do
filter/front_matter_filter_spec.rb:    it 'converts YAML front matter to a fenced code block' do
filter/front_matter_filter_spec.rb:  describe 'protects against malicious backtracking' do
filter/front_matter_filter_spec.rb:    it 'fails fast for strings with many spaces' do
filter/front_matter_filter_spec.rb:    it 'fails fast for strings with many newlines' do
filter/front_matter_filter_spec.rb:    it 'fails fast for strings with many `coding:`' do
filter/front_matter_filter_spec.rb:  it_behaves_like 'pipeline timing check'
filter/front_matter_filter_spec.rb:  it_behaves_like 'limits the number of filtered items' do
filter/broadcast_message_placeholders_filter_spec.rb:require 'spec_helper'
filter/broadcast_message_placeholders_filter_spec.rb:  describe 'when current user is set' do
filter/broadcast_message_placeholders_filter_spec.rb:    context 'replaces placeholder in text' do
filter/broadcast_message_placeholders_filter_spec.rb:      let(:text) { 'Email: {{email}}' }
filter/broadcast_message_placeholders_filter_spec.rb:    context 'replaces placeholder when they are in a link' do
filter/broadcast_message_placeholders_filter_spec.rb:      let(:text) { '<a href="http://example.com?email={{email}}"">link</a>' }
filter/broadcast_message_placeholders_filter_spec.rb:    context 'replaces placeholder when they are in an escaped link' do
filter/broadcast_message_placeholders_filter_spec.rb:      let(:text) { '<a href="http://example.com?name=%7B%7Bname%7D%7D">link</a>' }
filter/broadcast_message_placeholders_filter_spec.rb:    context 'works with empty text' do
filter/broadcast_message_placeholders_filter_spec.rb:    context 'replaces multiple placeholders in a given text' do
filter/broadcast_message_placeholders_filter_spec.rb:    context 'available placeholders' do
filter/broadcast_message_placeholders_filter_spec.rb:      context 'replaces the email of the user' do
filter/broadcast_message_placeholders_filter_spec.rb:      context 'replaces the name of the user' do
filter/broadcast_message_placeholders_filter_spec.rb:      context 'replaces the ID of the user' do
filter/broadcast_message_placeholders_filter_spec.rb:      context 'replaces the username of the user' do
filter/broadcast_message_placeholders_filter_spec.rb:      context 'replaces the instance_id' do
filter/broadcast_message_placeholders_filter_spec.rb:          stub_application_setting(uuid: '123')
filter/broadcast_message_placeholders_filter_spec.rb:  describe 'when there is no current user set' do
filter/broadcast_message_placeholders_filter_spec.rb:    context 'replaces placeholder with empty string' do
filter/broadcast_message_placeholders_filter_spec.rb:  it_behaves_like 'pipeline timing check'
filter/plantuml_filter_spec.rb:require 'spec_helper'
filter/plantuml_filter_spec.rb:  it 'replaces plantuml pre tag with img tag' do
filter/plantuml_filter_spec.rb:    output = '<img class="plantuml" src="http://localhost:8080/png/U9npoazIqBLJ24uiIbImKl18pSd91m0rkGMq" data-diagram="plantuml" data-diagram-src="data:text/plain;base64,Qm9iIC0+IFNhcmEgOiBIZWxsbw==">'
filter/plantuml_filter_spec.rb:  it 'allows the lang attribute on the code tag to support RST files processed by gitlab-markup gem' do
filter/plantuml_filter_spec.rb:    output = '<img class="plantuml" src="http://localhost:8080/png/U9npoazIqBLJ24uiIbImKl18pSd91m0rkGMq" data-diagram="plantuml" data-diagram-src="data:text/plain;base64,Qm9iIC0+IFNhcmEgOiBIZWxsbw==">'
filter/plantuml_filter_spec.rb:  it 'does not replace plantuml pre tag with img tag if disabled' do
filter/plantuml_filter_spec.rb:  it 'does not replace plantuml pre tag with img tag if url is invalid' do
filter/plantuml_filter_spec.rb:  it "strips at most one trailing newline from the diagram's source" do
filter/plantuml_filter_spec.rb:    # ' Next line left intentionally blank.
filter/plantuml_filter_spec.rb:    input = %(<pre data-canonical-lang="plantuml"><code>Bob -&gt; Sara : Hello\n' Next line left intentionally blank.\n\n</code></pre>)
filter/plantuml_filter_spec.rb:    output = '<img class="plantuml" src="http://localhost:8080/png/U9npoazIqBLJ24uiIbImKl18pSd9vr9Ny4kjA578oSnBLSX9JIjHoCmhISqhoSpFIyp9gLH8oadCozRZ0W0Q7XD1" data-diagram="plantuml" data-diagram-src="data:text/plain;base64,Qm9iIC0+IFNhcmEgOiBIZWxsbwonIE5leHQgbGluZSBsZWZ0IGludGVudGlvbmFsbHkgYmxhbmsuCg==">'
filter/plantuml_filter_spec.rb:  it_behaves_like 'pipeline timing check'
filter/ascii_doc_post_processing_filter_spec.rb:require 'spec_helper'
filter/ascii_doc_post_processing_filter_spec.rb:    result = filter('<pre data-math-style="inline">some code</pre><div data-math>and</div>').to_html
filter/ascii_doc_post_processing_filter_spec.rb:    expect(result).to eq('<pre data-math-style="inline" class="js-render-math">some code</pre><div data-math>and</div>')
filter/ascii_doc_post_processing_filter_spec.rb:    result = filter('<pre data-mermaid-style="display">some code</pre>').to_html
filter/ascii_doc_post_processing_filter_spec.rb:    expect(result).to eq('<pre data-mermaid-style="display" class="js-render-mermaid">some code</pre>')
filter/ascii_doc_post_processing_filter_spec.rb:    result = filter('<pre>some code</pre><div data-math>and</div>').to_html
filter/ascii_doc_post_processing_filter_spec.rb:    expect(result).to eq('<pre>some code</pre><div data-math>and</div>')
filter/ascii_doc_post_processing_filter_spec.rb:  it_behaves_like 'pipeline timing check'
filter/commit_trailers_filter_spec.rb:require 'spec_helper'
filter/commit_trailers_filter_spec.rb:require 'ffaker'
filter/commit_trailers_filter_spec.rb:  context 'detects' do
filter/commit_trailers_filter_spec.rb:    context 'trailers in the form of *-by' do
filter/commit_trailers_filter_spec.rb:        it 'replaces users with links' do
filter/commit_trailers_filter_spec.rb:    it 'trailers prefixed with whitespaces' do
filter/commit_trailers_filter_spec.rb:    it 'does not detect GitLab users via a secondary email' do
filter/commit_trailers_filter_spec.rb:    context 'non GitLab users' do
filter/commit_trailers_filter_spec.rb:      shared_examples 'mailto links' do
filter/commit_trailers_filter_spec.rb:        it 'replaces them with mailto links' do
filter/commit_trailers_filter_spec.rb:      context 'when Gravatar is disabled' do
filter/commit_trailers_filter_spec.rb:        it_behaves_like 'mailto links'
filter/commit_trailers_filter_spec.rb:      context 'when Gravatar is enabled' do
filter/commit_trailers_filter_spec.rb:        it_behaves_like 'mailto links'
filter/commit_trailers_filter_spec.rb:    it 'multiple trailers in the same message' do
filter/commit_trailers_filter_spec.rb:    context 'special names' do
filter/commit_trailers_filter_spec.rb:          'John S. Doe',
filter/commit_trailers_filter_spec.rb:          'L33t H@x0r'
filter/commit_trailers_filter_spec.rb:    it 'commit messages without trailers' do
filter/commit_trailers_filter_spec.rb:    it 'trailers without emails' do
filter/commit_trailers_filter_spec.rb:      exp = message = commit_html(Array.new(5) { 'Merged-By:' }.join("\n"))
filter/commit_trailers_filter_spec.rb:    it 'trailers that are inline the commit message body' do
filter/commit_trailers_filter_spec.rb:      expect(doc.css('a').size).to eq 0
filter/commit_trailers_filter_spec.rb:    it 'starts with two newlines to separate with actual commit message' do
filter/commit_trailers_filter_spec.rb:      expect(doc.xpath('pre').text).to start_with("\n\n")
filter/commit_trailers_filter_spec.rb:    it 'preserves the commit trailer structure' do
filter/commit_trailers_filter_spec.rb:    it 'preserves the original name used in the commit message' do
filter/commit_trailers_filter_spec.rb:    it 'preserves the original email used in the commit message' do
filter/commit_trailers_filter_spec.rb:    it 'only replaces trailer lines not the full commit message' do
filter/commit_trailers_filter_spec.rb:    context 'with Gitlab-hosted avatars in commit trailers' do
filter/commit_trailers_filter_spec.rb:      let(:user_with_avatar) { create(:user, :public_email, :with_avatar, username: 'foobar') }
filter/commit_trailers_filter_spec.rb:      it 'returns a full path for avatar urls' do
filter/commit_trailers_filter_spec.rb:        expect(doc.css('img')[0].attr('src')).to start_with expected
filter/commit_trailers_filter_spec.rb:  it_behaves_like 'pipeline timing check'
filter/syntax_highlight_filter_spec.rb:require 'spec_helper'
filter/syntax_highlight_filter_spec.rb:      result = filter('<pre><code>def fun end</code></pre>')
filter/syntax_highlight_filter_spec.rb:      expect(result.to_html.delete("\n")).to eq('<div class="gl-relative markdown-code-block js-markdown-code"><pre class="code highlight js-syntax-highlight language-plaintext" v-pre="true"><code><span id="LC1" class="line" lang="plaintext">def fun end</span></code></pre><copy-code></copy-code><insert-code-snippet></insert-code-snippet></div>')
filter/syntax_highlight_filter_spec.rb:      result = filter('<pre data-mermaid-style="display" data-canonical-lang="mermaid"><code class="js-render-mermaid">mermaid code</code></pre>')
filter/syntax_highlight_filter_spec.rb:      expect(result.to_html.delete("\n")).to eq('<div class="gl-relative markdown-code-block js-markdown-code"><pre data-mermaid-style="display" data-canonical-lang="mermaid" class="code highlight js-syntax-highlight language-mermaid" v-pre="true"><code class="js-render-mermaid"><span id="LC1" class="line" lang="mermaid">mermaid code</span></code></pre><copy-code></copy-code><insert-code-snippet></insert-code-snippet></div>')
filter/syntax_highlight_filter_spec.rb:      result = filter('<pre><code>one</code> and <code>two</code></pre>')
filter/syntax_highlight_filter_spec.rb:      expect(result.to_html).to eq('<pre><code>one</code> and <code>two</code></pre>')
filter/syntax_highlight_filter_spec.rb:    it "captures all text and doesn't fail trying to replace a node with no parent" do
filter/syntax_highlight_filter_spec.rb:      expect(result.to_html.delete("\n")).to eq('<div><div class="gl-relative markdown-code-block js-markdown-code"><pre class="code highlight js-syntax-highlight language-plaintext" v-pre="true"><code><span id="LC1" class="line" lang="plaintext"></span><span id="LC2" class="line" lang="plaintext">something</span><span id="LC3" class="line" lang="plaintext">else</span></code></pre><copy-code></copy-code><insert-code-snippet></insert-code-snippet></div></div>')
filter/syntax_highlight_filter_spec.rb:      result = filter('<pre data-canonical-lang="ruby"><code>def fun end</code></pre>')
filter/syntax_highlight_filter_spec.rb:      expect(result.to_html.delete("\n")).to eq('<div class="gl-relative markdown-code-block js-markdown-code"><pre data-canonical-lang="ruby" class="code highlight js-syntax-highlight language-ruby" v-pre="true"><code><span id="LC1" class="line" lang="ruby"><span class="k">def</span> <span class="nf">fun</span> <span class="k">end</span></span></code></pre><copy-code></copy-code><insert-code-snippet></insert-code-snippet></div>')
filter/syntax_highlight_filter_spec.rb:      result = filter('<pre data-canonical-lang="gnuplot"><code>This is a test</code></pre>')
filter/syntax_highlight_filter_spec.rb:      expect(result.to_html.delete("\n")).to eq('<div class="gl-relative markdown-code-block js-markdown-code"><pre data-canonical-lang="gnuplot" class="code highlight js-syntax-highlight language-plaintext" v-pre="true"><code><span id="LC1" class="line" lang="plaintext">This is a test</span></code></pre><copy-code></copy-code><insert-code-snippet></insert-code-snippet></div>')
filter/syntax_highlight_filter_spec.rb:          copy_code_btn = '<copy-code></copy-code>' unless lang == 'suggestion'
filter/syntax_highlight_filter_spec.rb:          insert_code_snippet_btn = '<insert-code-snippet></insert-code-snippet>' unless lang == 'suggestion'
filter/syntax_highlight_filter_spec.rb:      result = filter('<pre data-sourcepos="1:1-3:3" data-canonical-lang="plaintext"><code>This is a test</code></pre>')
filter/syntax_highlight_filter_spec.rb:      expect(result.to_html.delete("\n")).to eq('<div class="gl-relative markdown-code-block js-markdown-code"><pre data-sourcepos="1:1-3:3" data-canonical-lang="plaintext" class="code highlight js-syntax-highlight language-plaintext" v-pre="true"><code><span id="LC1" class="line" lang="plaintext">This is a test</span></code></pre><copy-code></copy-code><insert-code-snippet></insert-code-snippet></div>')
filter/syntax_highlight_filter_spec.rb:      result = filter('<pre data-sourcepos="&#34;%22 href=&#34;x&#34;></pre><base href=http://unsafe-website.com/><pre x=&#34;"><code></code></pre>')
filter/syntax_highlight_filter_spec.rb:      expect(result.to_html.delete("\n")).to eq('<div class="gl-relative markdown-code-block js-markdown-code"><pre data-sourcepos=\'"%22 href="x"&gt;&lt;/pre&gt;&lt;base href=http://unsafe-website.com/&gt;&lt;pre x="\' class="code highlight js-syntax-highlight language-plaintext" v-pre="true"><code></code></pre><copy-code></copy-code><insert-code-snippet></insert-code-snippet></div>')
filter/syntax_highlight_filter_spec.rb:      result = filter('<pre data-canonical-lang="ruby"><code>This is a test</code></pre>')
filter/syntax_highlight_filter_spec.rb:      expect(result.to_html.delete("\n")).to eq('<div class="gl-relative markdown-code-block js-markdown-code"><pre data-canonical-lang="ruby" class="code highlight js-syntax-highlight" v-pre="true"><code><span id="LC1" class="line" lang="">This is a test</span></code></pre><copy-code></copy-code><insert-code-snippet></insert-code-snippet></div>')
filter/syntax_highlight_filter_spec.rb:      result = filter('<pre><code>This is a test</code></pre>')
filter/syntax_highlight_filter_spec.rb:      expect(result.to_html).to eq('<pre><code>This is a test</code></pre>')
filter/syntax_highlight_filter_spec.rb:  it_behaves_like 'a filter timeout' do
filter/syntax_highlight_filter_spec.rb:    let(:text) { '<pre data-canonical-lang="ruby"><code>def fun end</code></pre>' }
filter/syntax_highlight_filter_spec.rb:  it_behaves_like 'pipeline timing check'
filter/broadcast_message_sanitization_filter_spec.rb:require 'spec_helper'
filter/broadcast_message_sanitization_filter_spec.rb:  it_behaves_like 'default allowlist'
filter/broadcast_message_sanitization_filter_spec.rb:  describe 'custom allowlist' do
filter/broadcast_message_sanitization_filter_spec.rb:    context 'allows `a` elements' do
filter/broadcast_message_sanitization_filter_spec.rb:    context 'allows `br` elements' do
filter/broadcast_message_sanitization_filter_spec.rb:    context 'when `a` elements have `style` attribute' do
filter/broadcast_message_sanitization_filter_spec.rb:      let(:allowed_style) { 'color: red; border: blue; background: green; padding: 10px; margin: 10px; text-decoration: underline;' }
filter/broadcast_message_sanitization_filter_spec.rb:      context 'allows specific properties' do
filter/broadcast_message_sanitization_filter_spec.rb:      it 'disallows other properties in `style` attribute on `a` elements' do
filter/broadcast_message_sanitization_filter_spec.rb:        style = [allowed_style, 'position: fixed'].join(';')
filter/broadcast_message_sanitization_filter_spec.rb:        expect(doc.at_css('a')['style']).to eq(allowed_style)
filter/broadcast_message_sanitization_filter_spec.rb:    context 'allows `class` on `a` elements' do
filter/jira_import/adf_to_commonmark_filter_spec.rb:require 'spec_helper'
filter/jira_import/adf_to_commonmark_filter_spec.rb:  let_it_be(:fixtures_path) { 'lib/kramdown/atlassian_document_format' }
filter/jira_import/adf_to_commonmark_filter_spec.rb:  it 'renders a complex document' do
filter/jira_import/adf_to_commonmark_filter_spec.rb:    source = fixture_file(File.join(fixtures_path, 'complex_document.json'))
filter/jira_import/adf_to_commonmark_filter_spec.rb:    target = fixture_file(File.join(fixtures_path, 'complex_document.md'))
filter/jira_import/adf_to_commonmark_filter_spec.rb:  it 'renders original source when it is invalid JSON' do
filter/jira_import/adf_to_commonmark_filter_spec.rb:    source = fixture_file(File.join(fixtures_path, 'invalid_json.json'))
filter/jira_import/adf_to_commonmark_filter_spec.rb:  it 'renders original source when missing document node' do
filter/jira_import/adf_to_commonmark_filter_spec.rb:    source = fixture_file(File.join(fixtures_path, 'invalid_no_doc.json'))
filter/inline_diff_filter_spec.rb:require 'spec_helper'
filter/inline_diff_filter_spec.rb:  it 'adds inline diff span tags for deletions when using square brackets' do
filter/inline_diff_filter_spec.rb:    expect(filter(doc).to_html).to eq('START <span class="idiff left right deletion">something deleted</span> END')
filter/inline_diff_filter_spec.rb:  it 'adds inline diff span tags for deletions when using curley braces' do
filter/inline_diff_filter_spec.rb:    expect(filter(doc).to_html).to eq('START <span class="idiff left right deletion">something deleted</span> END')
filter/inline_diff_filter_spec.rb:  it 'does not add inline diff span tags when a closing tag is not provided' do
filter/inline_diff_filter_spec.rb:  it 'adds inline span tags for additions when using square brackets' do
filter/inline_diff_filter_spec.rb:    expect(filter(doc).to_html).to eq('START <span class="idiff left right addition">something added</span> END')
filter/inline_diff_filter_spec.rb:  it 'adds inline span tags for additions  when using curley braces' do
filter/inline_diff_filter_spec.rb:    expect(filter(doc).to_html).to eq('START <span class="idiff left right addition">something added</span> END')
filter/inline_diff_filter_spec.rb:  it 'does not add inline diff span tags when a closing addition tag is not provided' do
filter/inline_diff_filter_spec.rb:  it 'does not add inline diff span tags when the tags do not match' do
filter/inline_diff_filter_spec.rb:  it 'prevents user-land html being injected' do
filter/inline_diff_filter_spec.rb:    doc = "START {+&lt;script&gt;alert('I steal cookies')&lt;/script&gt;+} END"
filter/inline_diff_filter_spec.rb:    expect(filter(doc).to_html).to eq("START <span class=\"idiff left right addition\">&lt;script&gt;alert('I steal cookies')&lt;/script&gt;</span> END")
filter/inline_diff_filter_spec.rb:  it 'preserves content inside pre tags' do
filter/inline_diff_filter_spec.rb:  it 'preserves content inside code tags' do
filter/inline_diff_filter_spec.rb:  it 'preserves content inside tt tags' do
filter/inline_diff_filter_spec.rb:  it 'protects against malicious backtracking' do
filter/inline_diff_filter_spec.rb:    doc = '[-{-' * 250_000
filter/inline_diff_filter_spec.rb:  it_behaves_like 'pipeline timing check'
filter/inline_diff_filter_spec.rb:  it_behaves_like 'limits the number of filtered items' do
filter/inline_diff_filter_spec.rb:    let(:text) { '[+added+] [+added+] [+added+]' }
filter/inline_diff_filter_spec.rb:    let(:ends_with) { '</span> [+added+]' }
filter/convert_text_to_doc_filter_spec.rb:require 'spec_helper'
filter/convert_text_to_doc_filter_spec.rb:  it 'returns a nokogiri doc' do
filter/convert_text_to_doc_filter_spec.rb:    doc = filter('<h1>test</h2')
filter/asset_proxy_filter_spec.rb:require 'spec_helper'
filter/asset_proxy_filter_spec.rb:  it 'does not replace if disabled' do
filter/asset_proxy_filter_spec.rb:    src     = 'http://example.com/test.png'
filter/asset_proxy_filter_spec.rb:    expect(doc.at_css('img')['src']).to eq src
filter/asset_proxy_filter_spec.rb:  context 'during initialization' do
filter/asset_proxy_filter_spec.rb:      Gitlab.config.asset_proxy['enabled'] = false
filter/asset_proxy_filter_spec.rb:    it '#initialize_settings' do
filter/asset_proxy_filter_spec.rb:      stub_application_setting(asset_proxy_secret_key: 'shared-secret')
filter/asset_proxy_filter_spec.rb:      stub_application_setting(asset_proxy_url: 'https://assets.example.com')
filter/asset_proxy_filter_spec.rb:      expect(Gitlab.config.asset_proxy.secret_key).to eq 'shared-secret'
filter/asset_proxy_filter_spec.rb:      expect(Gitlab.config.asset_proxy.url).to eq 'https://assets.example.com'
filter/asset_proxy_filter_spec.rb:    context 'when allowlist is empty' do
filter/asset_proxy_filter_spec.rb:      it 'defaults to the install domain' do
filter/asset_proxy_filter_spec.rb:    it 'supports deprecated whitelist settings' do
filter/asset_proxy_filter_spec.rb:  context 'when properly configured' do
filter/asset_proxy_filter_spec.rb:      stub_asset_proxy_setting(secret_key: 'shared-secret')
filter/asset_proxy_filter_spec.rb:      stub_asset_proxy_setting(url: 'https://assets.example.com')
filter/asset_proxy_filter_spec.rb:      'http://example.com/test.png' | 'https://assets.example.com/08df250eeeef1a8cf2c761475ac74c5065105612/687474703a2f2f6578616d706c652e636f6d2f746573742e706e67'
filter/asset_proxy_filter_spec.rb:      '///example.com/test.png' | 'https://assets.example.com/3368d2c7b9bed775bdd1e811f36a4b80a0dcd8ab/2f2f2f6578616d706c652e636f6d2f746573742e706e67'
filter/asset_proxy_filter_spec.rb:      '//example.com/test.png' | 'https://assets.example.com/a2e9aa56319e31bbd05be72e633f2864ff08becb/2f2f6578616d706c652e636f6d2f746573742e706e67'
filter/asset_proxy_filter_spec.rb:      # If it can't be parsed, default to use asset proxy
filter/asset_proxy_filter_spec.rb:      'oigjsie8787%$**(#(%0' | 'https://assets.example.com/1b893f9a71d66c99437f27e19b9a061a6f5d9391/6f69676a7369653837383725242a2a2823282530'
filter/asset_proxy_filter_spec.rb:      'https://example.com/x?' | 'https://assets.example.com/2f29a8c7f13f3ae14dc18c154dbbd657d703e75f/68747470733a2f2f6578616d706c652e636f6d2f783fc2ac'
filter/asset_proxy_filter_spec.rb:      'http:example.com' | 'https://assets.example.com/bcefecd18484ec2850887d6730273e5e70f5ed1a/687474703a6578616d706c652e636f6d'
filter/asset_proxy_filter_spec.rb:      'https:example.com' | 'https://assets.example.com/648e074361143780357db0b5cf73d4438d5484d3/68747470733a6578616d706c652e636f6d'
filter/asset_proxy_filter_spec.rb:      'https://example.com/##' | 'https://assets.example.com/d7d0c845cc553d9430804c07e9456545ef3e6fe6/68747470733a2f2f6578616d706c652e636f6d2f2323'
filter/asset_proxy_filter_spec.rb:      nil | 'http://gitlab.com/test.png'
filter/asset_proxy_filter_spec.rb:      nil | 'http://gitlab.com/test.png?url=http://example.com/test.png'
filter/asset_proxy_filter_spec.rb:      nil | 'http://images.mydomain.com/test.png'
filter/asset_proxy_filter_spec.rb:      it 'correctly modifies the img tag' do
filter/asset_proxy_filter_spec.rb:        expect(doc.at_css('img')['src']).to eq src
filter/asset_proxy_filter_spec.rb:        expect(doc.at_css('img')['data-canonical-src']).to eq data_canonical_src
filter/asset_proxy_filter_spec.rb:  it_behaves_like 'pipeline timing check', context: { disable_asset_proxy: true }
filter/custom_emoji_filter_spec.rb:require 'spec_helper'
filter/custom_emoji_filter_spec.rb:  let_it_be(:custom_emoji) { create(:custom_emoji, name: 'tanuki', group: group) }
filter/custom_emoji_filter_spec.rb:  let_it_be(:custom_emoji2) { create(:custom_emoji, name: 'happy_tanuki', group: group, file: 'https://foo.bar/happy.png') }
filter/custom_emoji_filter_spec.rb:  it_behaves_like 'emoji filter' do
filter/custom_emoji_filter_spec.rb:    let(:emoji_name) { ':tanuki:' }
filter/custom_emoji_filter_spec.rb:  it 'replaces supported name custom emoji' do
filter/custom_emoji_filter_spec.rb:    doc = filter('<p>:tanuki:</p>', project: project)
filter/custom_emoji_filter_spec.rb:    expect(doc.css('gl-emoji').first.attributes['title'].value).to eq('tanuki')
filter/custom_emoji_filter_spec.rb:  it 'correctly uses the custom emoji URL' do
filter/custom_emoji_filter_spec.rb:    doc = filter('<p>:tanuki:</p>')
filter/custom_emoji_filter_spec.rb:    expect(doc.css('gl-emoji').first.attributes['data-fallback-src'].value).to eq(custom_emoji.file)
filter/custom_emoji_filter_spec.rb:  it 'matches multiple same custom emoji' do
filter/custom_emoji_filter_spec.rb:    doc = filter(':tanuki: :tanuki:')
filter/custom_emoji_filter_spec.rb:    expect(doc.css('gl-emoji').size).to eq 2
filter/custom_emoji_filter_spec.rb:  it 'matches multiple custom emoji' do
filter/custom_emoji_filter_spec.rb:    doc = filter(':tanuki: (:happy_tanuki:)')
filter/custom_emoji_filter_spec.rb:    expect(doc.css('gl-emoji').size).to eq 2
filter/custom_emoji_filter_spec.rb:  it 'does not match enclosed colons' do
filter/custom_emoji_filter_spec.rb:    doc = filter('tanuki:tanuki:')
filter/custom_emoji_filter_spec.rb:    expect(doc.css('gl-emoji').size).to be 0
filter/custom_emoji_filter_spec.rb:  it 'does not match an unknown emoji' do
filter/custom_emoji_filter_spec.rb:    doc = filter(':tanuki: :tanooki:')
filter/custom_emoji_filter_spec.rb:    expect(doc.css('gl-emoji').size).to be 1
filter/custom_emoji_filter_spec.rb:  it 'does not do N+1 query' do
filter/custom_emoji_filter_spec.rb:    create(:custom_emoji, name: 'party-parrot', group: group)
filter/custom_emoji_filter_spec.rb:      filter('<p>:tanuki:</p>')
filter/custom_emoji_filter_spec.rb:      filter('<p>:tanuki:</p> <p>:party-parrot:</p>')
filter/custom_emoji_filter_spec.rb:  it 'uses custom emoji from ancestor group' do
filter/custom_emoji_filter_spec.rb:    doc = filter('<p>:tanuki:</p>', group: subgroup)
filter/custom_emoji_filter_spec.rb:    expect(doc.css('gl-emoji').size).to eq 1
filter/custom_emoji_filter_spec.rb:  context 'when asset proxy is configured' do
filter/custom_emoji_filter_spec.rb:        secret_key: 'shared-secret',
filter/custom_emoji_filter_spec.rb:        url: 'https://assets.example.com'
filter/custom_emoji_filter_spec.rb:    it 'uses the proxied url' do
filter/custom_emoji_filter_spec.rb:      doc = filter('<p>:tanuki:</p>')
filter/custom_emoji_filter_spec.rb:      expect(doc.css('gl-emoji').first.attributes['data-fallback-src'].value).to start_with('https://assets.example.com')
filter/custom_emoji_filter_spec.rb:  it_behaves_like 'pipeline timing check'
filter/custom_emoji_filter_spec.rb:  it_behaves_like 'a filter timeout' do
filter/custom_emoji_filter_spec.rb:    let(:text) { 'text' }
filter/custom_emoji_filter_spec.rb:  it_behaves_like 'limits the number of filtered items' do
filter/custom_emoji_filter_spec.rb:    let(:text) { ':tanuki: :tanuki: :tanuki:' }
filter/custom_emoji_filter_spec.rb:    let(:ends_with) { '</gl-emoji> :tanuki:' }
filter/footnote_filter_spec.rb:require 'spec_helper'
filter/footnote_filter_spec.rb:  context 'when footnotes exist' do
filter/footnote_filter_spec.rb:    let(:link_node)  { doc.css('sup > a').first }
filter/footnote_filter_spec.rb:    let(:identifier) { link_node[:id].delete_prefix('fnref-1-') }
filter/footnote_filter_spec.rb:    it 'properly adds the necessary ids and classes' do
filter/footnote_filter_spec.rb:    context 'when GITLAB_TEST_FOOTNOTE_ID is set' do
filter/footnote_filter_spec.rb:      let(:test_footnote_id) { '42' }
filter/footnote_filter_spec.rb:        stub_env('GITLAB_TEST_FOOTNOTE_ID', test_footnote_id)
filter/footnote_filter_spec.rb:      it 'uses the test footnote ID instead of a random number' do
filter/footnote_filter_spec.rb:  context 'when detecting footnotes' do
filter/footnote_filter_spec.rb:      false  | '1. [one](#fnref-abc)'
filter/footnote_filter_spec.rb:      it 'detects valid footnotes' do
filter/footnote_filter_spec.rb:        expect(result[:output].at_css('section.footnotes').present?).to eq(valid)
filter/footnote_filter_spec.rb:  context 'when too many footnotes' do
filter/footnote_filter_spec.rb:    it 'ignores them all' do
filter/footnote_filter_spec.rb:      expect(result[:output].at_css('section.footnotes').present?).to be_falsey
filter/footnote_filter_spec.rb:  it_behaves_like 'pipeline timing check'
filter/json_table_filter_spec.rb:require 'spec_helper'
filter/json_table_filter_spec.rb:      <div><table data-table-fields='[{"key":"starts_at","label":"Date \\u003c \\u0026 \\u003e","sortable":true},{"key":"url","label":"URL"}]' data-table-filter="true" data-table-markdown="true">
filter/json_table_filter_spec.rb:      <div><table data-table-fields='[{"key":"starts_at"},{"key":"url"}]' data-table-markdown="true">
filter/json_table_filter_spec.rb:  context 'when fields are provided' do
filter/json_table_filter_spec.rb:    it 'generates the correct HTML' do
filter/json_table_filter_spec.rb:  context 'when fields are not provided' do
filter/json_table_filter_spec.rb:    it 'generates the correct HTML' do
filter/json_table_filter_spec.rb:  context 'when markdown is not enabled' do
filter/json_table_filter_spec.rb:    it 'does not change the HTML' do
filter/json_table_filter_spec.rb:  context 'when json is invalid' do
filter/json_table_filter_spec.rb:    it 'does not change the HTML' do
filter/wiki_link_filter_spec.rb:require 'spec_helper'
filter/wiki_link_filter_spec.rb:  it "doesn't rewrite absolute links" do
filter/wiki_link_filter_spec.rb:    filtered_link = filter("<a href='http://example.com:8000/'>Link</a>", wiki: wiki).children[0]
filter/wiki_link_filter_spec.rb:    expect(filtered_link.attribute('href').value).to eq('http://example.com:8000/')
filter/wiki_link_filter_spec.rb:  it "doesn't rewrite links to project uploads" do
filter/wiki_link_filter_spec.rb:    filtered_link = filter("<a href='/uploads/a.test'>Link</a>", wiki: wiki).children[0]
filter/wiki_link_filter_spec.rb:    expect(filtered_link.attribute('href').value).to eq('/uploads/a.test')
filter/wiki_link_filter_spec.rb:  describe 'when links are rewritable' do
filter/wiki_link_filter_spec.rb:      filtered_elements = filter("<a href='#{original_path}'><img src='#{original_path}'>example</img></a>", wiki: wiki)
filter/wiki_link_filter_spec.rb:      expect(filtered_elements.search('img').first.attribute('data-canonical-src').value).to eq(original_path)
filter/wiki_link_filter_spec.rb:      expect(filtered_elements.search('a').first.attribute('data-canonical-src').value).to eq(original_path)
filter/wiki_link_filter_spec.rb:  describe 'when links are not rewritable' do
filter/wiki_link_filter_spec.rb:      filtered_link = filter("<a href='/uploads/a.test'>Link</a>", wiki: wiki).children[0]
filter/wiki_link_filter_spec.rb:      expect(filtered_link.value?('data-canonical-src')).to eq(false)
filter/wiki_link_filter_spec.rb:  describe 'when links point to the relative wiki path' do
filter/wiki_link_filter_spec.rb:    it 'does not rewrite links' do
filter/wiki_link_filter_spec.rb:      filtered_link = filter("<a href='#{path}'>Link</a>", wiki: wiki, page_slug: 'home').children[0]
filter/wiki_link_filter_spec.rb:      expect(filtered_link.attribute('href').value).to eq(path)
filter/wiki_link_filter_spec.rb:    it 'does not rewrite links to old relative wiki path' do
filter/wiki_link_filter_spec.rb:      old_wiki_base_path = wiki.wiki_base_path.sub('/-/', '/')
filter/wiki_link_filter_spec.rb:      filtered_link = filter("<a href='#{path}'>Link</a>", wiki: wiki, page_slug: 'home').children[0]
filter/wiki_link_filter_spec.rb:      expect(filtered_link.attribute('href').value).to eq(path)
filter/wiki_link_filter_spec.rb:    context 'with an "a" html tag' do
filter/wiki_link_filter_spec.rb:      it 'rewrites links' do
filter/wiki_link_filter_spec.rb:        filtered_link = filter("<a href='#{repository_upload_folder}/a.test'>Link</a>", wiki: wiki).children[0]
filter/wiki_link_filter_spec.rb:        expect(filtered_link.attribute('href').value).to eq("#{wiki.wiki_base_path}/#{repository_upload_folder}/a.test")
filter/wiki_link_filter_spec.rb:    context 'with "img" html tag' do
filter/wiki_link_filter_spec.rb:      context 'inside an "a" html tag' do
filter/wiki_link_filter_spec.rb:        it 'rewrites links' do
filter/wiki_link_filter_spec.rb:          filtered_elements = filter("<a href='#{repository_upload_folder}/a.jpg'><img src='#{repository_upload_folder}/a.jpg'>example</img></a>", wiki: wiki)
filter/wiki_link_filter_spec.rb:          expect(filtered_elements.search('img').first.attribute('src').value).to eq(path)
filter/wiki_link_filter_spec.rb:          expect(filtered_elements.search('a').first.attribute('href').value).to eq(path)
filter/wiki_link_filter_spec.rb:      context 'outside an "a" html tag' do
filter/wiki_link_filter_spec.rb:        it 'rewrites links' do
filter/wiki_link_filter_spec.rb:          filtered_link = filter("<img src='#{repository_upload_folder}/a.jpg'>example</img>", wiki: wiki).children[0]
filter/wiki_link_filter_spec.rb:          expect(filtered_link.attribute('src').value).to eq(path)
filter/wiki_link_filter_spec.rb:    context 'with "video" html tag' do
filter/wiki_link_filter_spec.rb:      it 'rewrites links' do
filter/wiki_link_filter_spec.rb:        filtered_link = filter("<video src='#{repository_upload_folder}/a.mp4'></video>", wiki: wiki).children[0]
filter/wiki_link_filter_spec.rb:        expect(filtered_link.attribute('src').value).to eq("#{wiki.wiki_base_path}/#{repository_upload_folder}/a.mp4")
filter/wiki_link_filter_spec.rb:    context 'with "audio" html tag' do
filter/wiki_link_filter_spec.rb:      it 'rewrites links' do
filter/wiki_link_filter_spec.rb:        filtered_link = filter("<audio src='#{repository_upload_folder}/a.wav'></audio>", wiki: wiki).children[0]
filter/wiki_link_filter_spec.rb:        expect(filtered_link.attribute('src').value).to eq("#{wiki.wiki_base_path}/#{repository_upload_folder}/a.wav")
filter/wiki_link_filter_spec.rb:      it "doesn't rewrite invalid invalid_links like #{invalid_link}" do
filter/wiki_link_filter_spec.rb:        filtered_link = filter("<a href='#{invalid_link}'>Link</a>", wiki: wiki).children[0]
filter/wiki_link_filter_spec.rb:        expect(filtered_link.attribute('href').value).to eq(invalid_link)
filter/wiki_link_filter_spec.rb:  it_behaves_like 'pipeline timing check'
filter/markdown_engines/base_spec.rb:require 'spec_helper'
filter/markdown_engines/base_spec.rb:  it 'raise error if render not implemented' do
filter/markdown_engines/base_spec.rb:    expect { engine.render('# hi') }.to raise_error(NotImplementedError)
filter/markdown_engines/base_spec.rb:  it 'turns off sourcepos' do
filter/markdown_engines/base_spec.rb:  it 'accepts a nil context' do
filter/markdown_engines/glfm_markdown_spec.rb:require 'spec_helper'
filter/markdown_engines/glfm_markdown_spec.rb:  it 'defaults to generating sourcepos' do
filter/markdown_engines/glfm_markdown_spec.rb:    expect(engine.render('# hi')).to eq expected
filter/markdown_engines/glfm_markdown_spec.rb:  it 'turns off sourcepos' do
filter/markdown_engines/glfm_markdown_spec.rb:    expect(engine.render('# hi')).to eq expected
filter/markdown_engines/glfm_markdown_spec.rb:  it 'turns off header anchors' do
filter/markdown_engines/glfm_markdown_spec.rb:    expect(engine.render('# hi')).to eq expected
filter/markdown_engines/glfm_markdown_spec.rb:  it 'turns off autolinking' do
filter/markdown_engines/glfm_markdown_spec.rb:    expect(engine.render('http://example.com')).to eq expected
filter/markdown_engines/glfm_markdown_spec.rb:  it 'returns proper inline sourcepos' do
filter/markdown_engines/glfm_markdown_spec.rb:    expect(engine.render('`code`')).to eq expected
filter/markdown_engines/glfm_markdown_spec.rb:  it 'turns on minimal markdown options' do
filter/markdown_engines/glfm_markdown_spec.rb:    expect(engine.render('http://example.com _emphasis_ $x + y$')).to eq expected
filter/markdown_engines/cmark_spec.rb:require 'spec_helper'
filter/markdown_engines/cmark_spec.rb:  it 'defaults to generating sourcepos' do
filter/markdown_engines/cmark_spec.rb:    expect(engine.render('# hi')).to eq %(<h1 data-sourcepos="1:1-1:4">hi</h1>\n)
filter/markdown_engines/cmark_spec.rb:  it 'turns off sourcepos' do
filter/markdown_engines/cmark_spec.rb:    expect(engine.render('# hi')).to eq %(<h1>hi</h1>\n)
filter/wiki_link_gollum_filter_spec.rb:require 'spec_helper'
filter/wiki_link_gollum_filter_spec.rb:  context 'when link is not external or to a wiki' do
filter/wiki_link_gollum_filter_spec.rb:    it 'does not add additional classes or attributes' do
filter/wiki_link_gollum_filter_spec.rb:      tag = '[[Something|unknown]]'
filter/wiki_link_gollum_filter_spec.rb:      expect(doc.to_html).to eq '<p dir="auto">See <a href="unknown" data-wikilink="true">Something</a></p>'
filter/wiki_link_gollum_filter_spec.rb:  context 'when linking internal images' do
filter/wiki_link_gollum_filter_spec.rb:    it 'creates img tag if image exists' do
filter/wiki_link_gollum_filter_spec.rb:      blob = instance_double('Gitlab::Git::Blob', mime_type: 'image/jpeg',
filter/wiki_link_gollum_filter_spec.rb:        name: 'images/image.jpg', path: 'images/image.jpg', data: '')
filter/wiki_link_gollum_filter_spec.rb:      expect(wiki).to receive(:find_file).with('images/image.jpg', load_content: false).and_return(wiki_file)
filter/wiki_link_gollum_filter_spec.rb:      tag = '[[images/image.jpg]]'
filter/wiki_link_gollum_filter_spec.rb:      expect(doc.at_css('img')['src']).to eq LazyImageTagHelper.placeholder_image
filter/wiki_link_gollum_filter_spec.rb:      expect(doc.at_css('img')['data-src']).to eq 'images/image.jpg'
filter/wiki_link_gollum_filter_spec.rb:      expect(doc.at_css('img').classes).to include 'gfm'
filter/wiki_link_gollum_filter_spec.rb:    it 'does not creates img tag if image does not exist' do
filter/wiki_link_gollum_filter_spec.rb:      expect(wiki).to receive(:find_file).with('images/image.jpg', load_content: false).and_return(nil)
filter/wiki_link_gollum_filter_spec.rb:      tag = '[[images/image.jpg]]'
filter/wiki_link_gollum_filter_spec.rb:      expect(doc.css('img').size).to eq 0
filter/wiki_link_gollum_filter_spec.rb:  context 'when linking external images' do
filter/wiki_link_gollum_filter_spec.rb:    it 'creates img tag for valid URL' do
filter/wiki_link_gollum_filter_spec.rb:      tag = '[[http://example.com/image.jpg]]'
filter/wiki_link_gollum_filter_spec.rb:      expect(doc.at_css('img')['src']).to eq LazyImageTagHelper.placeholder_image
filter/wiki_link_gollum_filter_spec.rb:      expect(doc.at_css('img')['data-src']).to eq 'http://example.com/image.jpg'
filter/wiki_link_gollum_filter_spec.rb:    it 'does not creates img tag for invalid URL' do
filter/wiki_link_gollum_filter_spec.rb:      tag = '[[http://example.com/image.pdf]]'
filter/wiki_link_gollum_filter_spec.rb:      expect(doc.css('img').size).to eq 0
filter/wiki_link_gollum_filter_spec.rb:  context 'when linking external resources' do
filter/wiki_link_gollum_filter_spec.rb:    it 'created link text will be equal to the resource text' do
filter/wiki_link_gollum_filter_spec.rb:      tag = '[[http://example.com]]'
filter/wiki_link_gollum_filter_spec.rb:      expect(doc.at_css('a').text).to eq 'http://example.com'
filter/wiki_link_gollum_filter_spec.rb:      expect(doc.at_css('a')['href']).to eq 'http://example.com'
filter/wiki_link_gollum_filter_spec.rb:    it 'created link text will be link-text' do
filter/wiki_link_gollum_filter_spec.rb:      tag = '[[link-text|http://example.com/pdfs/gollum.pdf]]'
filter/wiki_link_gollum_filter_spec.rb:      expect(doc.at_css('a').text).to eq 'link-text'
filter/wiki_link_gollum_filter_spec.rb:      expect(doc.at_css('a')['href']).to eq 'http://example.com/pdfs/gollum.pdf'
filter/wiki_link_gollum_filter_spec.rb:    it 'does not add `gfm-gollum-wiki-page` class to the link' do
filter/wiki_link_gollum_filter_spec.rb:      tag = '[[http://example.com]]'
filter/wiki_link_gollum_filter_spec.rb:      expect(doc.at_css('a')['class']).to eq 'gfm'
filter/wiki_link_gollum_filter_spec.rb:  context 'when linking internal resources' do
filter/wiki_link_gollum_filter_spec.rb:    it 'created link text includes the resource text and wiki base path' do
filter/wiki_link_gollum_filter_spec.rb:      tag = '[[wiki-slug]]'
filter/wiki_link_gollum_filter_spec.rb:      expected_path = ::File.join(wiki.wiki_base_path, 'wiki-slug')
filter/wiki_link_gollum_filter_spec.rb:      expect(doc.at_css('a').text).to eq 'wiki-slug'
filter/wiki_link_gollum_filter_spec.rb:      expect(doc.at_css('a')['href']).to eq expected_path
filter/wiki_link_gollum_filter_spec.rb:      expect(doc.at_css('a')['data-reference-type']).to eq 'wiki_page'
filter/wiki_link_gollum_filter_spec.rb:      expect(doc.at_css('a')['data-canonical-src']).to eq 'wiki-slug'
filter/wiki_link_gollum_filter_spec.rb:      expect(doc.at_css('a')['data-gollum']).to eq 'true'
filter/wiki_link_gollum_filter_spec.rb:      expect(doc.at_css('a')['data-project']).to eq project.id.to_s
filter/wiki_link_gollum_filter_spec.rb:      expect(doc.at_css('a')['data-group']).to be_nil
filter/wiki_link_gollum_filter_spec.rb:      expect(doc.at_css('a')['class']).to eq 'gfm gfm-gollum-wiki-page'
filter/wiki_link_gollum_filter_spec.rb:    it 'created link text will be link-text' do
filter/wiki_link_gollum_filter_spec.rb:      tag = '[[link-text|wiki-slug]]'
filter/wiki_link_gollum_filter_spec.rb:      expected_path = ::File.join(wiki.wiki_base_path, 'wiki-slug')
filter/wiki_link_gollum_filter_spec.rb:      expect(doc.at_css('a').text).to eq 'link-text'
filter/wiki_link_gollum_filter_spec.rb:      expect(doc.at_css('a')['href']).to eq expected_path
filter/wiki_link_gollum_filter_spec.rb:    it 'inside back ticks will be exempt from linkification' do
filter/wiki_link_gollum_filter_spec.rb:      doc = pipeline_filter('`[[link-in-backticks]]`', wiki: wiki)
filter/wiki_link_gollum_filter_spec.rb:      expect(doc.at_css('code').text).to eq '[[link-in-backticks]]'
filter/wiki_link_gollum_filter_spec.rb:    it 'handles escaping brackets in title' do
filter/wiki_link_gollum_filter_spec.rb:      tag = '[[this \[and\] that]]'
filter/wiki_link_gollum_filter_spec.rb:      expected_path = ::File.join(wiki.wiki_base_path, 'this%20%5Band%5D%20that')
filter/wiki_link_gollum_filter_spec.rb:      expect(doc.at_css('a').text).to eq 'this [and] that'
filter/wiki_link_gollum_filter_spec.rb:      expect(doc.at_css('a')['href']).to eq expected_path
filter/wiki_link_gollum_filter_spec.rb:    it 'handles group wiki links' do
filter/wiki_link_gollum_filter_spec.rb:      tag = '[[wiki-slug]]'
filter/wiki_link_gollum_filter_spec.rb:      expected_path = ::File.join(wiki.wiki_base_path, 'wiki-slug')
filter/wiki_link_gollum_filter_spec.rb:      expect(doc.at_css('a').text).to eq 'wiki-slug'
filter/wiki_link_gollum_filter_spec.rb:      expect(doc.at_css('a')['href']).to eq expected_path
filter/wiki_link_gollum_filter_spec.rb:      expect(doc.at_css('a')['data-reference-type']).to eq 'wiki_page'
filter/wiki_link_gollum_filter_spec.rb:      expect(doc.at_css('a')['data-canonical-src']).to eq 'wiki-slug'
filter/wiki_link_gollum_filter_spec.rb:      expect(doc.at_css('a')['data-gollum']).to eq 'true'
filter/wiki_link_gollum_filter_spec.rb:      expect(doc.at_css('a')['data-project']).to be_nil
filter/wiki_link_gollum_filter_spec.rb:      expect(doc.at_css('a')['data-group']).to eq group.id.to_s
filter/wiki_link_gollum_filter_spec.rb:      expect(doc.at_css('a')['class']).to eq 'gfm gfm-gollum-wiki-page'
filter/wiki_link_gollum_filter_spec.rb:  it 'leaves other text content untouched' do
filter/wiki_link_gollum_filter_spec.rb:    doc = pipeline_filter('This is [[a link|link]]', wiki: wiki)
filter/wiki_link_gollum_filter_spec.rb:  context 'for sanitization of HTML entities' do
filter/wiki_link_gollum_filter_spec.rb:    it 'does not unescape HTML entities' do
filter/wiki_link_gollum_filter_spec.rb:      doc = pipeline_filter('This is [[a link|&lt;script&gt;alert(0)&lt;/script&gt;]]', wiki: wiki)
filter/wiki_link_gollum_filter_spec.rb:      expect(doc.at_css('a').text).to eq 'a link'
filter/wiki_link_gollum_filter_spec.rb:      expect(doc.at_css('a')['href']).to eq "#{wiki.wiki_base_path}/%3Cscript%3Ealert(0)%3C/script%3E"
filter/wiki_link_gollum_filter_spec.rb:      expect(doc.at_css('a')['data-canonical-src']).to eq '%3Cscript%3Ealert(0)%3C/script%3E'
filter/wiki_link_gollum_filter_spec.rb:    it 'does not unescape HTML entities in the link text' do
filter/wiki_link_gollum_filter_spec.rb:      doc = pipeline_filter('This is [[&lt;script&gt;alert(0)&lt;/script&gt;|link]]', wiki: wiki)
filter/wiki_link_gollum_filter_spec.rb:      expect(doc.at_css('a')['href']).to eq "#{wiki.wiki_base_path}/link"
filter/wiki_link_gollum_filter_spec.rb:      expect(doc.at_css('a')['data-canonical-src']).to eq 'link'
filter/wiki_link_gollum_filter_spec.rb:      expect(doc.to_html).to end_with '>&lt;script&gt;alert(0)&lt;/script&gt;</a></p>'
filter/wiki_link_gollum_filter_spec.rb:    it 'does not unescape HTML entities outside the link text' do
filter/wiki_link_gollum_filter_spec.rb:      doc = pipeline_filter('This is &lt;script&gt;alert(0)&lt;/script&gt; [[a link|link]]', wiki: wiki)
filter/wiki_link_gollum_filter_spec.rb:      expect(doc.to_html).to start_with '<p dir="auto">This is &lt;script&gt;alert(0)&lt;/script&gt; <a href'
filter/wiki_link_gollum_filter_spec.rb:  it 'adds `gfm-gollum-wiki-page` classes to the link' do
filter/wiki_link_gollum_filter_spec.rb:    tag = '[[wiki-slug]]'
filter/wiki_link_gollum_filter_spec.rb:    expect(doc.at_css('a')['class']).to eq 'gfm gfm-gollum-wiki-page'
filter/wiki_link_gollum_filter_spec.rb:  it 'sanitizes the href attribute (case 1)' do
filter/wiki_link_gollum_filter_spec.rb:    tag = '[[a|http:\'"injected=attribute&gt;&lt;img/src="0"onerror="alert(0)"&gt;https://gitlab.com/gitlab-org/gitlab/-/issues/1]]'
filter/wiki_link_gollum_filter_spec.rb:    expect(doc.at_css('a')['href']).to eq 'http:\'%22injected=attribute%3E%3Cimg/src=%220%22onerror=%22alert(0)%22%3Ehttps://gitlab.com/gitlab-org/gitlab/-/issues/1'
filter/wiki_link_gollum_filter_spec.rb:    expect(doc.at_css('a')['data-canonical-src'])
filter/wiki_link_gollum_filter_spec.rb:      .to eq 'http:\'%22injected=attribute%3E%3Cimg/src=%220%22onerror=%22alert(0)%22%3Ehttps://gitlab.com/gitlab-org/gitlab/-/issues/1'
filter/wiki_link_gollum_filter_spec.rb:  it 'sanitizes the href attribute (case 2)' do
filter/wiki_link_gollum_filter_spec.rb:    tag = '<i>[[a|\'"&gt;&lt;svg&gt;&lt;i/class=gl-show-field-errors&gt;&lt;input/title="&lt;script&gt;alert(0)&lt;/script&gt;"/&gt;&lt;/svg&gt;https://gitlab.com/gitlab-org/gitlab/-/issues/1]]'
filter/wiki_link_gollum_filter_spec.rb:    expect(doc.at_css('i a')['href']).to eq "#{wiki.wiki_base_path}/'%22%3E%3Csvg%3E%3Ci/class=gl-show-field-errors%3E%3Cinput/title=%22%3Cscript%3Ealert(0)%3C/script%3E%22/%3E%3C/svg%3Ehttps://gitlab.com/gitlab-org/gitlab/-/issues/1"
filter/wiki_link_gollum_filter_spec.rb:    expect(doc.at_css('i a')['data-canonical-src']).to eq "'%22%3E%3Csvg%3E%3Ci/class=gl-show-field-errors%3E%3Cinput/title=%22%3Cscript%3Ealert(0)%3C/script%3E%22/%3E%3C/svg%3Ehttps://gitlab.com/gitlab-org/gitlab/-/issues/1"
filter/wiki_link_gollum_filter_spec.rb:  context 'when the href gets sanitized out' do
filter/wiki_link_gollum_filter_spec.rb:    it 'ignores the link' do
filter/wiki_link_gollum_filter_spec.rb:      doc = pipeline_filter('[[test|http://]]', wiki: wiki)
filter/wiki_link_gollum_filter_spec.rb:      expect(doc.at_css('a')['data-gollum']).to be_nil
filter/wiki_link_gollum_filter_spec.rb:  it_behaves_like 'pipeline timing check'
filter/wiki_link_gollum_filter_spec.rb:  describe 'limits the number of filtered image items' do
filter/wiki_link_gollum_filter_spec.rb:      stub_const('Banzai::Filter::WikiLinkGollumFilter::IMAGE_LINK_LIMIT', 2)
filter/wiki_link_gollum_filter_spec.rb:    it 'enforces image limits' do
filter/wiki_link_gollum_filter_spec.rb:      blob = instance_double('Gitlab::Git::Blob', mime_type: 'image/jpeg',
filter/wiki_link_gollum_filter_spec.rb:        name: 'images/image.jpg', path: 'images/image.jpg', data: '')
filter/wiki_link_gollum_filter_spec.rb:      expect(wiki).to receive(:find_file).with('images/image.jpg', load_content: false).twice.and_return(wiki_file)
filter/wiki_link_gollum_filter_spec.rb:      text = '[[images/image.jpg]] [[images/image.jpg]] [[images/image.jpg]]'
filter/wiki_link_gollum_filter_spec.rb:      ends_with = '>images/image.jpg</a></p>'
filter/wiki_link_gollum_filter_spec.rb:  it_behaves_like 'limits the number of filtered items' do
filter/wiki_link_gollum_filter_spec.rb:    let(:text) { '[[http://example.com]] [[http://example.com]] [[http://example.com]]' }
filter/wiki_link_gollum_filter_spec.rb:      '<a href="http://example.com" data-wikilink="true" rel="nofollow noreferrer noopener" target="_blank">http://example.com</a></p>'
filter/include_filter_spec.rb:require 'spec_helper'
filter/include_filter_spec.rb:  let_it_be(:text_include) { '::include{file=file.md}' }
filter/include_filter_spec.rb:  let_it_be(:file_data) { 'included text' }
filter/include_filter_spec.rb:      requested_path: './',
filter/include_filter_spec.rb:      requested_path: './',
filter/include_filter_spec.rb:    allow(project.repository).to receive(:blob_at).with(ref, 'file.md').and_return(file_blob)
filter/include_filter_spec.rb:    allow(Gitlab::Git::Blob).to receive(:find).with(project.repository, ref, 'file.md').and_return(file_blob)
filter/include_filter_spec.rb:  it 'works for wikis' do
filter/include_filter_spec.rb:  it 'works for blobs' do
filter/include_filter_spec.rb:  it 'does not work for non-wiki/blob' do
filter/include_filter_spec.rb:  describe 'include syntax' do
filter/include_filter_spec.rb:    context 'when incorrect syntax' do
filter/include_filter_spec.rb:          ' ::include{file=file.md}',
filter/include_filter_spec.rb:          '::include{file=file.md} ',
filter/include_filter_spec.rb:          ':include{file=file.md}',
filter/include_filter_spec.rb:          '::include{file.md}',
filter/include_filter_spec.rb:          '::include(file=file.md)'
filter/include_filter_spec.rb:        it 'does not change the text' do
filter/include_filter_spec.rb:    context 'when correct syntax' do
filter/include_filter_spec.rb:      it 'recognizes file syntax' do
filter/include_filter_spec.rb:        expect(filter('::include{file=file.md}', filter_context)).to eq file_data
filter/include_filter_spec.rb:      it 'recognizes file syntax with space' do
filter/include_filter_spec.rb:        allow(project.repository).to receive(:blob_at).with(ref, 'file two.md').and_return(file_blob)
filter/include_filter_spec.rb:        allow(Gitlab::Git::Blob).to receive(:find).with(project.repository, ref, 'file two.md').and_return(file_blob)
filter/include_filter_spec.rb:        expect(filter('::include{file=file two.md}', filter_context)).to eq file_data
filter/include_filter_spec.rb:      it 'recognizes url syntax' do
filter/include_filter_spec.rb:        expect(filter('::include{file=https://example.com}', filter_context))
filter/include_filter_spec.rb:          .to eq '[https://example.com](https://example.com)'
filter/include_filter_spec.rb:    it 'handles case where the include filename is nil' do
filter/include_filter_spec.rb:        .with(anything, anything, limit: anything).and_yield(0 => 'foo')
filter/include_filter_spec.rb:      expect(filter('::include{file=file.md}', filter_context)).to eq 'foo'
filter/include_filter_spec.rb:  context 'when reading a file in the repository' do
filter/include_filter_spec.rb:    it 'returns the blob contents' do
filter/include_filter_spec.rb:    context 'when the blob does not exist' do
filter/include_filter_spec.rb:        allow(Gitlab::Git::Blob).to receive(:find).with(project.repository, ref, 'missing.md').and_return(nil)
filter/include_filter_spec.rb:      it 'replaces text with error' do
filter/include_filter_spec.rb:        expect(filter('::include{file=missing.md}', filter_context))
filter/include_filter_spec.rb:          .to eq "**Error including '[missing.md](missing.md)' : not found**\n"
filter/include_filter_spec.rb:    it 'allows at most N blob includes' do
filter/include_filter_spec.rb:    context 'when reading a wiki blob' do
filter/include_filter_spec.rb:        allow(project.repository).to receive(:blob_at).with(ref, 'wiki.md').and_return(wiki_blob)
filter/include_filter_spec.rb:        allow(Gitlab::Git::Blob).to receive(:find).with(project.repository, ref, 'wiki.md').and_return(wiki_blob)
filter/include_filter_spec.rb:      it 'strips any frontmatter' do
filter/include_filter_spec.rb:        expect(filter('::include{file=wiki.md}', filter_wiki_context)).to eq file_data
filter/include_filter_spec.rb:  context 'when reading content from a URL' do
filter/include_filter_spec.rb:    let_it_be(:http_url) { 'http://example.com' }
filter/include_filter_spec.rb:    let_it_be(:http_include) { '::include{file=http://example.com}' }
filter/include_filter_spec.rb:    let_it_be(:https_include) { '::include{file=https://example.com}' }
filter/include_filter_spec.rb:    let_it_be(:invalid_url) { '::include{file=http://example.com/foo bar}' }
filter/include_filter_spec.rb:    context 'when wiki_asciidoc_allow_uri_includes is false' do
filter/include_filter_spec.rb:      it 'does not allow url includes' do
filter/include_filter_spec.rb:        expect(filter(http_include, filter_context)).to eq '[http://example.com](http://example.com)'
filter/include_filter_spec.rb:        expect(filter(https_include, filter_context)).to eq '[https://example.com](https://example.com)'
filter/include_filter_spec.rb:      it 'allows non-url includes' do
filter/include_filter_spec.rb:        expect(filter(text_include, filter_context)).to include 'included text'
filter/include_filter_spec.rb:    context 'when wiki_asciidoc_allow_uri_includes is true' do
filter/include_filter_spec.rb:      it 'fetches the data using a GET request' do
filter/include_filter_spec.rb:        stub_request(:get, http_url).to_return(status: 200, body: 'something')
filter/include_filter_spec.rb:        expect(filter(http_include, filter_context)).to eq 'something'
filter/include_filter_spec.rb:      context 'when the URI returns 404' do
filter/include_filter_spec.rb:        it 'raises NoData' do
filter/include_filter_spec.rb:          stub_request(:get, http_url).to_return(status: 404, body: 'not found')
filter/include_filter_spec.rb:            .to eq "**Error including '[http://example.com](http://example.com)' : not readable**\n"
filter/include_filter_spec.rb:      context 'when URI::InvalidURIError' do
filter/include_filter_spec.rb:        it 'rescues the error' do
filter/include_filter_spec.rb:            .to eq "**Error including '[http://example.com/foo bar](http://example.com/foo bar)' : not found**\n"
filter/include_filter_spec.rb:      it 'allows at most N HTTP includes' do
filter/include_filter_spec.rb:        stub_request(:get, http_url).to_return(status: 200, body: 'something')
filter/include_filter_spec.rb:  context 'when including' do
filter/include_filter_spec.rb:    it 'truncates to our size limits' do
filter/include_filter_spec.rb:      expect(result).to eq('include...')
filter/suggestion_filter_spec.rb:require 'spec_helper'
filter/suggestion_filter_spec.rb:  it 'includes `js-render-suggestion` class' do
filter/suggestion_filter_spec.rb:    result = doc.css('code').first
filter/suggestion_filter_spec.rb:    expect(result[:class]).to include('js-render-suggestion')
filter/suggestion_filter_spec.rb:  it 'includes no `js-render-suggestion` when filter is disabled' do
filter/suggestion_filter_spec.rb:    result = doc.css('code').first
filter/suggestion_filter_spec.rb:  context 'multi-line suggestions' do
filter/suggestion_filter_spec.rb:    it 'element has correct data-lang-params' do
filter/suggestion_filter_spec.rb:      pre = doc.css('pre').first
filter/suggestion_filter_spec.rb:      expect(pre[data_attr]).to eq('-3+2')
filter/suggestion_filter_spec.rb:  it_behaves_like 'pipeline timing check'
filter/truncate_source_filter_spec.rb:require 'spec_helper'
filter/truncate_source_filter_spec.rb:  let(:short_text) { 'foo' * 10 }
filter/truncate_source_filter_spec.rb:  let(:long_text) { ([short_text] * 10).join(' ') }
filter/truncate_source_filter_spec.rb:  context 'when markdown belongs to a blob' do
filter/truncate_source_filter_spec.rb:    it 'does nothing when limit is unspecified' do
filter/truncate_source_filter_spec.rb:    it 'truncates normally when limit specified' do
filter/truncate_source_filter_spec.rb:      truncated = 'foofoof...'
filter/truncate_source_filter_spec.rb:  context 'when markdown belongs to a field (non-blob)' do
filter/truncate_source_filter_spec.rb:    it 'does nothing when limit is greater' do
filter/truncate_source_filter_spec.rb:    it 'truncates to the default when limit is unspecified' do
filter/truncate_source_filter_spec.rb:      truncated = 'foofoofoofoofoofoofoofoofoofoo foofoofoofoofoof...'
filter/truncate_source_filter_spec.rb:    it 'prepends the user message' do
filter/truncate_source_filter_spec.rb:    it 'does nothing to a short-enough text' do
filter/truncate_source_filter_spec.rb:    it 'truncates UTF-8 text by bytes, on a character boundary' do
filter/truncate_source_filter_spec.rb:      utf8_text = ''
filter/truncate_source_filter_spec.rb:      truncated = '...'
filter/quick_action_filter_spec.rb:require 'spec_helper'
filter/quick_action_filter_spec.rb:  it 'detects action in paragraph' do
filter/quick_action_filter_spec.rb:    described_class.call('<p data-sourcepos="1:1-2:3">/quick</p>', {}, result)
filter/quick_action_filter_spec.rb:  it 'does not detect action in paragraph if no sourcepos' do
filter/quick_action_filter_spec.rb:    described_class.call('<p>/quick</p>', {}, result)
filter/quick_action_filter_spec.rb:  it 'does not detect action in blockquote' do
filter/quick_action_filter_spec.rb:    described_class.call('<blockquote data-sourcepos="1:1-1:1">/quick</blockquote>', {}, result)
filter/quick_action_filter_spec.rb:  it 'does not detect action in html block' do
filter/quick_action_filter_spec.rb:    described_class.call('<li data-sourcepos="1:1-1:1">/quick</li>', {}, result)
filter/quick_action_filter_spec.rb:  it 'does not detect action in code block' do
filter/quick_action_filter_spec.rb:    described_class.call('<code data-sourcepos="1:1-1:1">/quick</code>', {}, result)
filter/service_desk_upload_link_filter_spec.rb:require 'spec_helper'
filter/service_desk_upload_link_filter_spec.rb:  let(:file_name) { 'test.jpg' }
filter/service_desk_upload_link_filter_spec.rb:  let(:secret) { 'e90decf88d8f96fe9e1389afc2e4a91f' }
filter/service_desk_upload_link_filter_spec.rb:  context 'when replace_upload_links enabled' do
filter/service_desk_upload_link_filter_spec.rb:    context 'when it has only one attachment to replace' do
filter/service_desk_upload_link_filter_spec.rb:      context 'when filename in text is same as in link' do
filter/service_desk_upload_link_filter_spec.rb:        it 'replaces the link with original filename in strong' do
filter/service_desk_upload_link_filter_spec.rb:          expect(doc.at_css('a')).to be_nil
filter/service_desk_upload_link_filter_spec.rb:          expect(doc.at_css('strong').text).to eq(file_name)
filter/service_desk_upload_link_filter_spec.rb:      context 'when filename in text is not same as in link' do
filter/service_desk_upload_link_filter_spec.rb:        let(:filename_in_text) { 'Custom name' }
filter/service_desk_upload_link_filter_spec.rb:        it 'replaces the link with filename in text & original filename, in strong' do
filter/service_desk_upload_link_filter_spec.rb:          expect(doc.at_css('a')).to be_nil
filter/service_desk_upload_link_filter_spec.rb:          expect(doc.at_css('strong').text).to eq("#{filename_in_text} (#{file_name})")
filter/service_desk_upload_link_filter_spec.rb:    context 'when it has more than one attachment to replace' do
filter/service_desk_upload_link_filter_spec.rb:      let(:file_name_1) { 'test1.jpg' }
filter/service_desk_upload_link_filter_spec.rb:      let(:secret_1) { '17817c73e368777e6f743392e334fb8a' }
filter/service_desk_upload_link_filter_spec.rb:      context 'when all of uploads can be replaced' do
filter/service_desk_upload_link_filter_spec.rb:        it 'replaces all links with original filename in strong' do
filter/service_desk_upload_link_filter_spec.rb:          expect(doc.at_css('a')).to be_nil
filter/service_desk_upload_link_filter_spec.rb:          expect(doc.at_css("strong:contains('#{file_name}')")).not_to be_nil
filter/service_desk_upload_link_filter_spec.rb:          expect(doc.at_css("strong:contains('#{file_name_1}')")).not_to be_nil
filter/service_desk_upload_link_filter_spec.rb:      context 'when not all of uploads can be replaced' do
filter/service_desk_upload_link_filter_spec.rb:        it 'replaces only specific links with original filename in strong' do
filter/service_desk_upload_link_filter_spec.rb:          expect(doc.at_css("strong:contains('#{file_name}')")).not_to be_nil
filter/service_desk_upload_link_filter_spec.rb:          expect(doc.at_css("a:contains('#{file_name_1}')")).not_to be_nil
filter/service_desk_upload_link_filter_spec.rb:  context 'when uploads_as_attachments is empty' do
filter/service_desk_upload_link_filter_spec.rb:    it 'does not replaces the link' do
filter/service_desk_upload_link_filter_spec.rb:      expect(doc.at_css('a')).not_to be_nil
filter/service_desk_upload_link_filter_spec.rb:      expect(doc.at_css('a')['href']).to eq upload_path
filter/service_desk_upload_link_filter_spec.rb:  it_behaves_like 'pipeline timing check'
filter/ascii_doc_sanitization_filter_spec.rb:require 'spec_helper'
filter/ascii_doc_sanitization_filter_spec.rb:  it 'preserves footnotes refs' do
filter/ascii_doc_sanitization_filter_spec.rb:    result = filter('<p>This paragraph has a footnote.<sup>[<a id="_footnoteref_1" href="#_footnotedef_1" title="View footnote.">1</a>]</sup></p>').to_html
filter/ascii_doc_sanitization_filter_spec.rb:    expect(result).to eq('<p>This paragraph has a footnote.<sup>[<a id="_footnoteref_1" href="#_footnotedef_1" title="View footnote.">1</a>]</sup></p>')
filter/ascii_doc_sanitization_filter_spec.rb:  it 'preserves footnotes defs' do
filter/ascii_doc_sanitization_filter_spec.rb:    result = filter('<div id="_footnotedef_1">
filter/ascii_doc_sanitization_filter_spec.rb:<a href="#_footnoteref_1">1</a>. This is the text of the footnote.</div>').to_html
filter/ascii_doc_sanitization_filter_spec.rb:  it 'preserves user-content- prefixed ids on anchors' do
filter/ascii_doc_sanitization_filter_spec.rb:    result = filter('<p><a id="user-content-cross-references"></a>A link to another location within an AsciiDoc document.</p>').to_html
filter/ascii_doc_sanitization_filter_spec.rb:  context 'with blocks' do
filter/ascii_doc_sanitization_filter_spec.rb:  it 'preserves section anchor ids' do
filter/ascii_doc_sanitization_filter_spec.rb:  it 'removes non prefixed ids' do
filter/ascii_doc_sanitization_filter_spec.rb:    result = filter('<p><a id="cross-references"></a>A link to another location within an AsciiDoc document.</p>').to_html
filter/repository_link_filter_spec.rb:require 'spec_helper'
filter/repository_link_filter_spec.rb:  let(:ref)            { 'markdown' }
filter/repository_link_filter_spec.rb:  let(:requested_path) { '/' }
filter/repository_link_filter_spec.rb:  it 'does not trigger a gitaly n+1', :request_store do
filter/repository_link_filter_spec.rb:  shared_examples 'preserve unchanged' do
filter/repository_link_filter_spec.rb:    it 'does not modify any relative URL in anchor' do
filter/repository_link_filter_spec.rb:      doc = filter(link('README.md'))
filter/repository_link_filter_spec.rb:      expect(doc.at_css('a')['href']).to eq 'README.md'
filter/repository_link_filter_spec.rb:    it 'does not modify any relative URL in image' do
filter/repository_link_filter_spec.rb:      doc = filter(image('files/images/logo-black.png'))
filter/repository_link_filter_spec.rb:      expect(doc.at_css('img')['src']).to eq 'files/images/logo-black.png'
filter/repository_link_filter_spec.rb:    it 'does not modify any relative URL in video' do
filter/repository_link_filter_spec.rb:      doc = filter(video('files/videos/intro.mp4'), commit: project.commit('video'), ref: 'video')
filter/repository_link_filter_spec.rb:      expect(doc.at_css('video')['src']).to eq 'files/videos/intro.mp4'
filter/repository_link_filter_spec.rb:    it 'does not modify any relative URL in audio' do
filter/repository_link_filter_spec.rb:      doc = filter(audio('files/audio/sample.wav'), commit: project.commit('audio'), ref: 'audio')
filter/repository_link_filter_spec.rb:      expect(doc.at_css('audio')['src']).to eq 'files/audio/sample.wav'
filter/repository_link_filter_spec.rb:  context 'with a wiki' do
filter/repository_link_filter_spec.rb:    let(:wiki) { double('ProjectWiki') }
filter/repository_link_filter_spec.rb:    include_examples 'preserve unchanged'
filter/repository_link_filter_spec.rb:  context 'without a repository' do
filter/repository_link_filter_spec.rb:    include_examples 'preserve unchanged'
filter/repository_link_filter_spec.rb:  context 'with an empty repository' do
filter/repository_link_filter_spec.rb:    include_examples 'preserve unchanged'
filter/repository_link_filter_spec.rb:  context 'without project repository access' do
filter/repository_link_filter_spec.rb:    include_examples 'preserve unchanged'
filter/repository_link_filter_spec.rb:  it 'does not raise an exception on invalid URIs' do
filter/repository_link_filter_spec.rb:  it 'does not raise an exception on URIs containing invalid utf-8 byte sequences' do
filter/repository_link_filter_spec.rb:  it 'does not raise an exception on URIs containing invalid utf-8 byte sequences in context requested path' do
filter/repository_link_filter_spec.rb:    expect { filter(link("files/test.md"), requested_path: '%FF') }.not_to raise_error
filter/repository_link_filter_spec.rb:  it 'does not raise an exception with a garbled path' do
filter/repository_link_filter_spec.rb:  it 'does not explode with an escaped null byte' do
filter/repository_link_filter_spec.rb:  it 'ignores ref if commit is passed' do
filter/repository_link_filter_spec.rb:    doc = filter(link('non/existent.file'), commit: project.commit('empty-branch'))
filter/repository_link_filter_spec.rb:    expect(doc.at_css('a')['href'])
filter/repository_link_filter_spec.rb:  shared_examples 'valid repository' do
filter/repository_link_filter_spec.rb:    it 'handles Gitaly unavailable exceptions gracefully' do
filter/repository_link_filter_spec.rb:      expect { doc = filter(link('doc/api/README.md')) }.not_to raise_error
filter/repository_link_filter_spec.rb:      expect(doc.at_css('a')['href'])
filter/repository_link_filter_spec.rb:    it 'handles Gitaly timeout exceptions gracefully' do
filter/repository_link_filter_spec.rb:      expect { doc = filter(link('doc/api/README.md')) }.not_to raise_error
filter/repository_link_filter_spec.rb:      expect(doc.at_css('a')['href'])
filter/repository_link_filter_spec.rb:    it 'rebuilds absolute URL for a file in the repo' do
filter/repository_link_filter_spec.rb:      doc = filter(link('/doc/api/README.md'))
filter/repository_link_filter_spec.rb:      expect(doc.at_css('a')['href'])
filter/repository_link_filter_spec.rb:    it 'does not modify relative URLs in system notes' do
filter/repository_link_filter_spec.rb:      expect(doc.at_css('a')['href']).to eq path
filter/repository_link_filter_spec.rb:    it 'ignores absolute URLs with two leading slashes' do
filter/repository_link_filter_spec.rb:      doc = filter(link('//doc/api/README.md'))
filter/repository_link_filter_spec.rb:      expect(doc.at_css('a')['href']).to eq '//doc/api/README.md'
filter/repository_link_filter_spec.rb:    it 'rebuilds relative URL for a file in the repo' do
filter/repository_link_filter_spec.rb:      doc = filter(link('doc/api/README.md'))
filter/repository_link_filter_spec.rb:      expect(doc.at_css('a')['href'])
filter/repository_link_filter_spec.rb:    it 'rebuilds relative URL for a missing file in the repo' do
filter/repository_link_filter_spec.rb:      doc = filter(link('missing-file'))
filter/repository_link_filter_spec.rb:      expect(doc.at_css('a')['href'])
filter/repository_link_filter_spec.rb:    it 'rebuilds relative URL for a file in the repo with leading ./' do
filter/repository_link_filter_spec.rb:      doc = filter(link('./doc/api/README.md'))
filter/repository_link_filter_spec.rb:      expect(doc.at_css('a')['href'])
filter/repository_link_filter_spec.rb:    it 'rebuilds relative URL for a file in the repo up one directory' do
filter/repository_link_filter_spec.rb:      relative_link = link('../api/README.md')
filter/repository_link_filter_spec.rb:      doc = filter(relative_link, requested_path: 'doc/update/7.14-to-8.0.md')
filter/repository_link_filter_spec.rb:      expect(doc.at_css('a')['href'])
filter/repository_link_filter_spec.rb:    it 'rebuilds relative URL for a file in the repo up multiple directories' do
filter/repository_link_filter_spec.rb:      relative_link = link('../../../api/README.md')
filter/repository_link_filter_spec.rb:      doc = filter(relative_link, requested_path: 'doc/foo/bar/baz/README.md')
filter/repository_link_filter_spec.rb:      expect(doc.at_css('a')['href'])
filter/repository_link_filter_spec.rb:    it 'rebuilds relative URL for a file in the repository root' do
filter/repository_link_filter_spec.rb:      relative_link = link('../README.md')
filter/repository_link_filter_spec.rb:      doc = filter(relative_link, requested_path: 'doc/some-file.md')
filter/repository_link_filter_spec.rb:      expect(doc.at_css('a')['href'])
filter/repository_link_filter_spec.rb:    it 'rebuilds relative URL for a file in the repo with an anchor' do
filter/repository_link_filter_spec.rb:      doc = filter(link('README.md#section'))
filter/repository_link_filter_spec.rb:      expect(doc.at_css('a')['href'])
filter/repository_link_filter_spec.rb:    it 'rebuilds relative URL for a directory in the repo' do
filter/repository_link_filter_spec.rb:      doc = filter(link('doc/api/'))
filter/repository_link_filter_spec.rb:      expect(doc.at_css('a')['href'])
filter/repository_link_filter_spec.rb:    it 'rebuilds relative URL for an image in the repo' do
filter/repository_link_filter_spec.rb:      doc = filter(image('files/images/logo-black.png'))
filter/repository_link_filter_spec.rb:      expect(doc.at_css('img')['src'])
filter/repository_link_filter_spec.rb:    it 'rebuilds relative URL for link to an image in the repo' do
filter/repository_link_filter_spec.rb:      doc = filter(link('files/images/logo-black.png'))
filter/repository_link_filter_spec.rb:      expect(doc.at_css('a')['href'])
filter/repository_link_filter_spec.rb:    it 'rebuilds relative URL for a video in the repo' do
filter/repository_link_filter_spec.rb:      doc = filter(video('files/videos/intro.mp4'), commit: project.commit('video'), ref: 'video')
filter/repository_link_filter_spec.rb:      expect(doc.at_css('video')['src'])
filter/repository_link_filter_spec.rb:    it 'rebuilds relative URL for audio in the repo' do
filter/repository_link_filter_spec.rb:      doc = filter(audio('files/audio/sample.wav'), commit: project.commit('audio'), ref: 'audio')
filter/repository_link_filter_spec.rb:      expect(doc.at_css('audio')['src'])
filter/repository_link_filter_spec.rb:    it 'does not modify relative URL with an anchor only' do
filter/repository_link_filter_spec.rb:      doc = filter(link('#section-1'))
filter/repository_link_filter_spec.rb:      expect(doc.at_css('a')['href']).to eq '#section-1'
filter/repository_link_filter_spec.rb:    it 'does not modify absolute URL' do
filter/repository_link_filter_spec.rb:      doc = filter(link('http://example.com'))
filter/repository_link_filter_spec.rb:      expect(doc.at_css('a')['href']).to eq 'http://example.com'
filter/repository_link_filter_spec.rb:    it 'does not call gitaly' do
filter/repository_link_filter_spec.rb:      filter(link('http://example.com'))
filter/repository_link_filter_spec.rb:    it 'supports Unicode filenames' do
filter/repository_link_filter_spec.rb:      path = 'files/images/.png'
filter/repository_link_filter_spec.rb:      # Stub this method so the file doesn't actually need to be in the repo
filter/repository_link_filter_spec.rb:      expect(doc.at_css('img')['src']).to eq "/#{project_path}/-/raw/#{Addressable::URI.escape(ref)}/#{escaped}"
filter/repository_link_filter_spec.rb:    it 'supports percent sign in filenames' do
filter/repository_link_filter_spec.rb:      doc = filter(link('doc/api/README%.md'))
filter/repository_link_filter_spec.rb:      expect(doc.at_css('a')['href'])
filter/repository_link_filter_spec.rb:    context 'when requested path is a file in the repo' do
filter/repository_link_filter_spec.rb:      let(:requested_path) { 'doc/api/README.md' }
filter/repository_link_filter_spec.rb:      it 'rebuilds URL relative to the containing directory' do
filter/repository_link_filter_spec.rb:        doc = filter(link('users.md'))
filter/repository_link_filter_spec.rb:        expect(doc.at_css('a')['href']).to eq "/#{project_path}/-/blob/#{Addressable::URI.escape(ref)}/doc/api/users.md"
filter/repository_link_filter_spec.rb:    context 'when requested path is a directory in the repo' do
filter/repository_link_filter_spec.rb:      let(:requested_path) { 'doc/api/' }
filter/repository_link_filter_spec.rb:      it 'rebuilds URL relative to the directory' do
filter/repository_link_filter_spec.rb:        doc = filter(link('users.md'))
filter/repository_link_filter_spec.rb:        expect(doc.at_css('a')['href']).to eq "/#{project_path}/-/blob/#{Addressable::URI.escape(ref)}/doc/api/users.md"
filter/repository_link_filter_spec.rb:    context 'when ref name contains percent sign' do
filter/repository_link_filter_spec.rb:      let(:ref) { '100%branch' }
filter/repository_link_filter_spec.rb:      let(:commit) { project.commit('1b12f15a11fc6e62177bef08f47bc7b5ce50b141') }
filter/repository_link_filter_spec.rb:      let(:requested_path) { 'foo/bar/' }
filter/repository_link_filter_spec.rb:      it 'correctly escapes the ref' do
filter/repository_link_filter_spec.rb:        doc = filter(link('.gitkeep'))
filter/repository_link_filter_spec.rb:        expect(doc.at_css('a')['href']).to eq "/#{project_path}/-/blob/#{Addressable::URI.escape(ref)}/foo/bar/.gitkeep"
filter/repository_link_filter_spec.rb:    context 'when ref name contains special chars' do
filter/repository_link_filter_spec.rb:      let(:ref) { 'mark#\'@],+;-._/#@!$&()+down' }
filter/repository_link_filter_spec.rb:      let(:path) { 'files/images/logo-black.png' }
filter/repository_link_filter_spec.rb:      it 'correctly escapes the ref' do
filter/repository_link_filter_spec.rb:        # Addressable won't escape the '#', so we do this manually
filter/repository_link_filter_spec.rb:        ref_escaped = 'mark%23\'@%5D,+;-._/%23@!$&()+down'
filter/repository_link_filter_spec.rb:        # Stub this method so the branch doesn't actually need to be in the repo
filter/repository_link_filter_spec.rb:        expect(doc.at_css('a')['href'])
filter/repository_link_filter_spec.rb:    context 'when requested path is a directory with space in the repo' do
filter/repository_link_filter_spec.rb:      let(:ref) { 'master' }
filter/repository_link_filter_spec.rb:      let(:commit) { project.commit('38008cb17ce1466d8fec2dfa6f6ab8dcfe5cf49e') }
filter/repository_link_filter_spec.rb:      let(:requested_path) { 'with space/' }
filter/repository_link_filter_spec.rb:      it 'does not escape the space twice' do
filter/repository_link_filter_spec.rb:        doc = filter(link('README.md'))
filter/repository_link_filter_spec.rb:        expect(doc.at_css('a')['href']).to eq "/#{project_path}/-/blob/#{Addressable::URI.escape(ref)}/with%20space/README.md"
filter/repository_link_filter_spec.rb:  context 'when public project repo with a valid commit' do
filter/repository_link_filter_spec.rb:    include_examples 'valid repository'
filter/repository_link_filter_spec.rb:  context 'when private project repo with a valid commit' do
filter/repository_link_filter_spec.rb:    include_examples 'valid repository'
filter/repository_link_filter_spec.rb:  context 'with a valid ref' do
filter/repository_link_filter_spec.rb:    include_examples 'valid repository'
filter/repository_link_filter_spec.rb:  it_behaves_like 'pipeline timing check'
filter/image_lazy_load_filter_spec.rb:require 'spec_helper'
filter/image_lazy_load_filter_spec.rb:  it 'adds a class attribute' do
filter/image_lazy_load_filter_spec.rb:    doc = filter(image('/uploads/e90decf88d8f96fe9e1389afc2e4a91f/test.jpg'))
filter/image_lazy_load_filter_spec.rb:    expect(doc.at_css('img')['class']).to eq 'lazy'
filter/image_lazy_load_filter_spec.rb:  it 'appends to the current class attribute' do
filter/image_lazy_load_filter_spec.rb:    doc = filter(image_with_class('/uploads/e90decf88d8f96fe9e1389afc2e4a91f/test.jpg', 'test'))
filter/image_lazy_load_filter_spec.rb:    expect(doc.at_css('img')['class']).to eq 'test lazy'
filter/image_lazy_load_filter_spec.rb:  it 'adds a async decoding attribute' do
filter/image_lazy_load_filter_spec.rb:    doc = filter(image_with_class('/uploads/e90decf88d8f96fe9e1389afc2e4a91f/test.jpg', 'test'))
filter/image_lazy_load_filter_spec.rb:    expect(doc.at_css('img')['decoding']).to eq 'async'
filter/image_lazy_load_filter_spec.rb:  it 'transforms the image src to a data-src' do
filter/image_lazy_load_filter_spec.rb:    doc = filter(image('/uploads/e90decf88d8f96fe9e1389afc2e4a91f/test.jpg'))
filter/image_lazy_load_filter_spec.rb:    expect(doc.at_css('img')['data-src']).to eq '/uploads/e90decf88d8f96fe9e1389afc2e4a91f/test.jpg'
filter/image_lazy_load_filter_spec.rb:  it 'works with external images' do
filter/image_lazy_load_filter_spec.rb:    doc = filter(image('https://i.imgur.com/DfssX9C.jpg'))
filter/image_lazy_load_filter_spec.rb:    expect(doc.at_css('img')['data-src']).to eq 'https://i.imgur.com/DfssX9C.jpg'
filter/image_lazy_load_filter_spec.rb:  it_behaves_like 'pipeline timing check'
filter/truncate_visible_filter_spec.rb:require 'spec_helper'
filter/truncate_visible_filter_spec.rb:    user = create(:user, username: 'gfm')
filter/truncate_visible_filter_spec.rb:  # Since we're truncating nodes of an html document, actually use the
filter/truncate_visible_filter_spec.rb:  shared_examples_for 'truncates text' do
filter/truncate_visible_filter_spec.rb:  describe 'displays inline code' do
filter/truncate_visible_filter_spec.rb:    let(:markdown) { 'Text with `inline code`' }
filter/truncate_visible_filter_spec.rb:    let(:expected) { 'Text with <code>inline code</code>' }
filter/truncate_visible_filter_spec.rb:    it_behaves_like 'truncates text'
filter/truncate_visible_filter_spec.rb:  describe 'truncates the text with multiple paragraphs' do
filter/truncate_visible_filter_spec.rb:    let(:expected) { 'Paragraph 1...' }
filter/truncate_visible_filter_spec.rb:    it_behaves_like 'truncates text'
filter/truncate_visible_filter_spec.rb:  describe 'truncates the first line of a code block' do
filter/truncate_visible_filter_spec.rb:    it_behaves_like 'truncates text'
filter/truncate_visible_filter_spec.rb:  describe 'preserves code color scheme' do
filter/truncate_visible_filter_spec.rb:    let(:markdown) { "```ruby\ndef test\n  'hello world'\nend\n```" }
filter/truncate_visible_filter_spec.rb:      '<code><span id="LC1" class="line" lang="ruby">' \
filter/truncate_visible_filter_spec.rb:      '<span class="k">def</span> <span class="nf">test</span>...</span>'
filter/truncate_visible_filter_spec.rb:    it_behaves_like 'truncates text'
filter/truncate_visible_filter_spec.rb:  describe 'truncates a single long line of text' do
filter/truncate_visible_filter_spec.rb:    let(:text) { 'The quick brown fox jumped over the lazy dog twice' } # 50 chars
filter/truncate_visible_filter_spec.rb:    let(:expected) { (text * 2).sub(/.{3}/, '...') }
filter/truncate_visible_filter_spec.rb:    it_behaves_like 'truncates text'
filter/truncate_visible_filter_spec.rb:  it 'preserves a link href when link text is truncated' do
filter/truncate_visible_filter_spec.rb:    text = 'The quick brown fox jumped over the lazy dog' # 44 chars
filter/truncate_visible_filter_spec.rb:    link_url = 'http://example.com/foo/bar/baz' # 30 chars
filter/truncate_visible_filter_spec.rb:    expected_link_text = 'http://example...</a>'
filter/truncate_visible_filter_spec.rb:  it 'truncates HTML properly' do
filter/truncate_visible_filter_spec.rb:    # Make sure we didn't create invalid markup
filter/truncate_visible_filter_spec.rb:    expect(doc.css('a').length).to eq(1)
filter/truncate_visible_filter_spec.rb:    expect(doc.css('a')[0].attr('href')).to eq urls.user_path(user)
filter/truncate_visible_filter_spec.rb:    expect(doc.css('a')[0].text).to eq "@#{user.username}"
filter/truncate_visible_filter_spec.rb:  it 'truncates HTML with emoji properly' do
filter/truncate_visible_filter_spec.rb:    # Make sure we didn't create invalid markup
filter/truncate_visible_filter_spec.rb:    expect(doc.css('gl-emoji').length).to eq(2)
filter/truncate_visible_filter_spec.rb:    expect(doc.css('gl-emoji')[0].attr('data-name')).to eq 'wink'
filter/truncate_visible_filter_spec.rb:    expect(doc.css('gl-emoji')[1].attr('data-name')).to eq 'grinning'
filter/truncate_visible_filter_spec.rb:  it 'does not truncate if truncate_visible_max_chars not specified' do
filter/math_filter_spec.rb:require 'spec_helper'
filter/math_filter_spec.rb:  it 'add js-render to all math' do
filter/math_filter_spec.rb:    expect(doc.search('.js-render-math').count).to eq(5)
filter/math_filter_spec.rb:  context 'when limiting how many elements can be marked as math' do
filter/math_filter_spec.rb:    subject { pipeline_filter('$`2+2`$ + $3+3$ + $$4+4$$', context) }
filter/math_filter_spec.rb:      stub_const('Banzai::Filter::MathFilter::RENDER_NODES_LIMIT', 2)
filter/math_filter_spec.rb:    it 'enforces limits by default' do
filter/math_filter_spec.rb:      expect(subject.search('.js-render-math').count).to eq(2)
filter/math_filter_spec.rb:    context 'when project with user namespace (no group)' do
filter/math_filter_spec.rb:      it 'limits' do
filter/math_filter_spec.rb:        expect(subject.search('.js-render-math').count).to eq(2)
filter/math_filter_spec.rb:    context 'when project with group, no namespace settings' do
filter/math_filter_spec.rb:      it 'limits' do
filter/math_filter_spec.rb:        expect(subject.search('.js-render-math').count).to eq(2)
filter/math_filter_spec.rb:    context 'when project with group, default namespace settings' do
filter/math_filter_spec.rb:      it 'limits' do
filter/math_filter_spec.rb:        expect(subject.search('.js-render-math').count).to eq(2)
filter/math_filter_spec.rb:    context 'when limits math_rendering_limits_enabled is false' do
filter/math_filter_spec.rb:      it 'does not limit' do
filter/math_filter_spec.rb:        expect(subject.search('.js-render-math').count).to eq(3)
filter/math_filter_spec.rb:    context 'when for wikis' do
filter/math_filter_spec.rb:      it 'does limit' do
filter/math_filter_spec.rb:        expect(subject.search('.js-render-math').count).to eq(2)
filter/math_filter_spec.rb:    context 'when for blobs' do
filter/math_filter_spec.rb:      it 'does limit for blobs' do
filter/math_filter_spec.rb:        expect(subject.search('.js-render-math').count).to eq(2)
filter/math_filter_spec.rb:  describe 'legacy math filter' do
filter/math_filter_spec.rb:    shared_examples 'inline math' do
filter/math_filter_spec.rb:      it 'removes surrounding dollar signs and adds class code, math and js-render-math' do
filter/math_filter_spec.rb:        expected = result_template.gsub('<math>', '<code data-math-style="inline" class="code math js-render-math">')
filter/math_filter_spec.rb:        expected.gsub!('</math>', '</code>')
filter/math_filter_spec.rb:    shared_examples 'display math' do
filter/math_filter_spec.rb:      let_it_be(:template_prefix_with_pre) { '<pre data-canonical-lang="math" data-math-style="display" class="js-render-math"><code>' }
filter/math_filter_spec.rb:      let_it_be(:template_prefix_with_code) { '<code data-math-style="display" class="code math js-render-math">' }
filter/math_filter_spec.rb:      it 'removes surrounding dollar signs and adds class code, math and js-render-math' do
filter/math_filter_spec.rb:        template_suffix = "</code>#{'</pre>' if use_pre_tags}"
filter/math_filter_spec.rb:        expected = result_template.gsub('<math>', template_prefix)
filter/math_filter_spec.rb:        expected.gsub!('</math>', template_suffix)
filter/math_filter_spec.rb:    describe 'inline math using $...$ syntax' do
filter/math_filter_spec.rb:      context 'with valid syntax' do
filter/math_filter_spec.rb:          '$2+2$'                                  | '<p><math>2+2</math></p>'
filter/math_filter_spec.rb:          '$22+1$ and $22 + a^2$'                  | '<p><math>22+1</math> and <math>22 + a^2</math></p>'
filter/math_filter_spec.rb:          '$22 and $2+2$'                          | '<p>$22 and <math>2+2</math></p>'
filter/math_filter_spec.rb:          '$2+2$ $22 and flightjs/Flight$22 $2+2$' | '<p><math>2+2</math> $22 and flightjs/Flight$22 <math>2+2</math></p>'
filter/math_filter_spec.rb:          '$1/2$ &lt;b&gt;test&lt;/b&gt;'          | '<p><math>1/2</math> &lt;b&gt;test&lt;/b&gt;</p>'
filter/math_filter_spec.rb:          '$a!$'                                   | '<p><math>a!</math></p>'
filter/math_filter_spec.rb:          '$x$'                                    | '<p><math>x</math></p>'
filter/math_filter_spec.rb:          '$1+2\$$'                                | '<p><math>1+2\$</math></p>'
filter/math_filter_spec.rb:          '$1+\$2$'                                | '<p><math>1+\$2</math></p>'
filter/math_filter_spec.rb:          '$1+\%2$'                                | '<p><math>1+\%2</math></p>'
filter/math_filter_spec.rb:          '$1+\#2$'                                | '<p><math>1+\#2</math></p>'
filter/math_filter_spec.rb:          '$1+\&2$'                                | '<p><math>1+\&amp;2</math></p>'
filter/math_filter_spec.rb:          '$1+\{2$'                                | '<p><math>1+\{2</math></p>'
filter/math_filter_spec.rb:          '$1+\}2$'                                | '<p><math>1+\}2</math></p>'
filter/math_filter_spec.rb:          '$1+\_2$'                                | '<p><math>1+\_2</math></p>'
filter/math_filter_spec.rb:          it_behaves_like 'inline math'
filter/math_filter_spec.rb:    describe 'inline math using $`...`$ syntax' do
filter/math_filter_spec.rb:      context 'with valid syntax' do
filter/math_filter_spec.rb:          '$`2+2`$'                                    | '<p><math>2+2</math></p>'
filter/math_filter_spec.rb:          '$`22+1`$ and $`22 + a^2`$'                  | '<p><math>22+1</math> and <math>22 + a^2</math></p>'
filter/math_filter_spec.rb:          '$22 and $`2+2`$'                            | '<p>$22 and <math>2+2</math></p>'
filter/math_filter_spec.rb:          '$`2+2`$ $22 and flightjs/Flight$22 $`2+2`$' | '<p><math>2+2</math> $22 and flightjs/Flight$22 <math>2+2</math></p>'
filter/math_filter_spec.rb:          'test $$`2+2`$$ test'                        | '<p>test $<math>2+2</math>$ test</p>'
filter/math_filter_spec.rb:          '$`1+\$2`$'                                  | '<p><math>1+\$2</math></p>'
filter/math_filter_spec.rb:          it_behaves_like 'inline math'
filter/math_filter_spec.rb:    describe 'inline display math using $$...$$ syntax' do
filter/math_filter_spec.rb:      context 'with valid syntax' do
filter/math_filter_spec.rb:          '$$2+2$$'                                    | '<p><math>2+2</math></p>'
filter/math_filter_spec.rb:          '$$   2+2  $$'                               | '<p><math>2+2</math></p>'
filter/math_filter_spec.rb:          '$$22+1$$ and $$22 + a^2$$'                  | '<p><math>22+1</math> and <math>22 + a^2</math></p>'
filter/math_filter_spec.rb:          '$22 and $$2+2$$'                            | '<p>$22 and <math>2+2</math></p>'
filter/math_filter_spec.rb:          '$$2+2$$ $22 and flightjs/Flight$22 $$2+2$$' | '<p><math>2+2</math> $22 and flightjs/Flight$22 <math>2+2</math></p>'
filter/math_filter_spec.rb:          'flightjs/Flight$22 and $$a^2 + b^2 = c^2$$' | '<p>flightjs/Flight$22 and <math>a^2 + b^2 = c^2</math></p>'
filter/math_filter_spec.rb:          '$$a!$$'                                     | '<p><math>a!</math></p>'
filter/math_filter_spec.rb:          '$$x$$'                                      | '<p><math>x</math></p>'
filter/math_filter_spec.rb:          '$$20,000 and $$30,000'                      | '<p><math>20,000 and</math>30,000</p>'
filter/math_filter_spec.rb:          it_behaves_like 'display math'
filter/math_filter_spec.rb:    describe 'block display math using $$\n...\n$$ syntax' do
filter/math_filter_spec.rb:      context 'with valid syntax' do
filter/math_filter_spec.rb:          it_behaves_like 'display math' do
filter/math_filter_spec.rb:      context 'when it spans multiple lines' do
filter/math_filter_spec.rb:        it_behaves_like 'display math' do
filter/math_filter_spec.rb:      context 'when it contains \\' do
filter/math_filter_spec.rb:        it_behaves_like 'display math' do
filter/math_filter_spec.rb:    describe 'display math using ```math...``` syntax' do
filter/math_filter_spec.rb:      it 'adds data-math-style display attribute to display math' do
filter/math_filter_spec.rb:        pre = doc.xpath('descendant-or-self::pre').first
filter/math_filter_spec.rb:        expect(pre['data-math-style']).to eq 'display'
filter/math_filter_spec.rb:      it 'adds js-render-math class to display math' do
filter/math_filter_spec.rb:        pre = doc.xpath('descendant-or-self::pre').first
filter/math_filter_spec.rb:      it 'ignores code blocks that are not math' do
filter/math_filter_spec.rb:      it 'requires the pre to contain both code and math' do
filter/math_filter_spec.rb:        input = '<pre data-canonical-lang="math">something</pre>'
filter/math_filter_spec.rb:    describe 'unrecognized syntax' do
filter/math_filter_spec.rb:        '`2+2`'               | '<p><code>2+2</code></p>'
filter/math_filter_spec.rb:        'test $`2+2` test'    | '<p>test $<code>2+2</code> test</p>'
filter/math_filter_spec.rb:        'test `2+2`$ test'    | '<p>test <code>2+2</code>$ test</p>'
filter/math_filter_spec.rb:        '$20,000 and $30,000' | '<p>$20,000 and $30,000</p>'
filter/math_filter_spec.rb:        '$20,000 in $USD'     | '<p>$20,000 in $USD</p>'
filter/math_filter_spec.rb:        '$ a^2 $'             | '<p>$ a^2 $</p>'
filter/math_filter_spec.rb:        '$$$'                 | '<p>$$$</p>'
filter/math_filter_spec.rb:        '`$1+2$`'             | '<p><code>$1+2$</code></p>'
filter/math_filter_spec.rb:        '`$$1+2$$`'           | '<p><code>$$1+2$$</code></p>'
filter/math_filter_spec.rb:        '`$\$1+2$$`'          | '<p><code>$\$1+2$$</code></p>'
filter/math_filter_spec.rb:        it 'is ignored' do
filter/math_filter_spec.rb:    it 'handles multiple styles in one text block' do
filter/math_filter_spec.rb:      doc = legacy_pipeline_filter('$`2+2`$ + $3+3$ + $$4+4$$', context)
filter/math_filter_spec.rb:      expect(doc.search('.js-render-math').count).to eq(3)
filter/math_filter_spec.rb:      expect(doc.search('[data-math-style="inline"]').count).to eq(2)
filter/math_filter_spec.rb:      expect(doc.search('[data-math-style="display"]').count).to eq(1)
filter/math_filter_spec.rb:  it_behaves_like 'pipeline timing check'
filter/image_link_filter_spec.rb:require 'spec_helper'
filter/image_link_filter_spec.rb:  let(:path) { '/uploads/e90decf88d8f96fe9e1389afc2e4a91f/test.jpg' }
filter/image_link_filter_spec.rb:  it 'wraps the image with a link to the image src' do
filter/image_link_filter_spec.rb:    expect(doc.at_css('img')['src']).to eq doc.at_css('a')['href']
filter/image_link_filter_spec.rb:  it 'ignores images with empty data-src' do
filter/image_link_filter_spec.rb:    doc = filter(image(path, data_src: ''), context)
filter/image_link_filter_spec.rb:    expect(doc.at_css('a')).to be_nil
filter/image_link_filter_spec.rb:  it 'does not wrap a duplicate link' do
filter/image_link_filter_spec.rb:  it 'works with external images' do
filter/image_link_filter_spec.rb:    doc = filter(image('https://i.imgur.com/DfssX9C.jpg'), context)
filter/image_link_filter_spec.rb:    expect(doc.at_css('img')['src']).to eq doc.at_css('a')['href']
filter/image_link_filter_spec.rb:  it 'works with inline images' do
filter/image_link_filter_spec.rb:  it 'keep the data-canonical-src' do
filter/image_link_filter_spec.rb:    expect(doc.at_css('img')['src']).to eq doc.at_css('a')['href']
filter/image_link_filter_spec.rb:    expect(doc.at_css('img')['data-canonical-src']).to eq doc.at_css('a')['data-canonical-src']
filter/image_link_filter_spec.rb:  it 'moves the data-diagram* attributes' do
filter/image_link_filter_spec.rb:    expect(doc.at_css('a')['data-diagram']).to eq "plantuml"
filter/image_link_filter_spec.rb:    expect(doc.at_css('a')['data-diagram-src']).to eq "data:text/plain;base64,Qm9iIC0+IFNhcmEgOiBIZWxsbw=="
filter/image_link_filter_spec.rb:    expect(doc.at_css('a img')['data-diagram']).to be_nil
filter/image_link_filter_spec.rb:    expect(doc.at_css('a img')['data-diagram-src']).to be_nil
filter/image_link_filter_spec.rb:  it 'adds no-attachment icon class to the link' do
filter/image_link_filter_spec.rb:    expect(doc.at_css('a')['class']).to match(%r{no-attachment-icon})
filter/image_link_filter_spec.rb:  context 'when :link_replaces_image is true' do
filter/image_link_filter_spec.rb:    it 'replaces the image with link to image src', :aggregate_failures do
filter/image_link_filter_spec.rb:      expect(doc.at_css('a')['href']).to eq(path)
filter/image_link_filter_spec.rb:    it 'uses image alt as a link text', :aggregate_failures do
filter/image_link_filter_spec.rb:      doc = filter(image(path, alt: 'My image'), context)
filter/image_link_filter_spec.rb:      expect(doc.at_css('a')['href']).to eq(path)
filter/image_link_filter_spec.rb:    it 'uses image data-src as a link text', :aggregate_failures do
filter/image_link_filter_spec.rb:      data_src = '/uploads/data-src.png'
filter/image_link_filter_spec.rb:      expect(doc.at_css('a')['href']).to eq(data_src)
filter/image_link_filter_spec.rb:    it 'adds attachment icon class to the link' do
filter/image_link_filter_spec.rb:      expect(doc.at_css('a')['class']).to match(%r{with-attachment-icon})
filter/image_link_filter_spec.rb:    context 'when link attributes contain malicious code' do
filter/image_link_filter_spec.rb:        %q(<a class='fixed-top fixed-bottom' data-create-path=/malicious-url><style> .tab-content>.tab-pane{display: block !important}</style>)
filter/image_link_filter_spec.rb:      context 'when image alt contains malicious code' do
filter/image_link_filter_spec.rb:        it 'ignores image alt and uses image path as the link text', :aggregate_failures do
filter/image_link_filter_spec.rb:          expect(doc.at_css('a')['href']).to eq(path)
filter/image_link_filter_spec.rb:      context 'when image src contains malicious code' do
filter/image_link_filter_spec.rb:        it 'ignores image src and does not use it as the link text' do
filter/image_link_filter_spec.rb:        it 'keeps image src unchanged, malicious code does not execute as part of url' do
filter/image_link_filter_spec.rb:          expect(doc.at_css('a')['href']).to eq(malicious_code)
filter/image_link_filter_spec.rb:      context 'when image data-src contains malicious code' do
filter/image_link_filter_spec.rb:        it 'ignores data-src and uses image path as the link text', :aggregate_failures do
filter/image_link_filter_spec.rb:        it 'uses image data-src, malicious code does not execute as part of url' do
filter/image_link_filter_spec.rb:          expect(doc.at_css('a')['href']).to eq(malicious_code)
filter/image_link_filter_spec.rb:  it_behaves_like 'pipeline timing check'
filter/upload_link_filter_spec.rb:require 'spec_helper'
filter/upload_link_filter_spec.rb:  let(:upload_path) { '/uploads/e90decf88d8f96fe9e1389afc2e4a91f/test.jpg' }
filter/upload_link_filter_spec.rb:  it 'preserves original url in data-canonical-src attribute' do
filter/upload_link_filter_spec.rb:    expect(doc.at_css('a')['data-canonical-src']).to eq(upload_path)
filter/upload_link_filter_spec.rb:  context 'to a project upload' do
filter/upload_link_filter_spec.rb:    context 'with an absolute URL' do
filter/upload_link_filter_spec.rb:      it 'rewrites the link correctly' do
filter/upload_link_filter_spec.rb:        expect(doc.at_css('a')['href']).to eq(absolute_path)
filter/upload_link_filter_spec.rb:        expect(doc.at_css('a').classes).to include('gfm')
filter/upload_link_filter_spec.rb:        expect(doc.at_css('a')['data-link']).to eq('true')
filter/upload_link_filter_spec.rb:    it 'rebuilds relative URL for a link' do
filter/upload_link_filter_spec.rb:      expect(doc.at_css('a')['href']).to eq(relative_path)
filter/upload_link_filter_spec.rb:      expect(doc.at_css('a').classes).to include('gfm')
filter/upload_link_filter_spec.rb:      expect(doc.at_css('a')['data-link']).to eq('true')
filter/upload_link_filter_spec.rb:      expect(doc.at_css('a')['href']).to eq(relative_path)
filter/upload_link_filter_spec.rb:      expect(doc.at_css('a').classes).to include('gfm')
filter/upload_link_filter_spec.rb:      expect(doc.at_css('a')['data-link']).to eq('true')
filter/upload_link_filter_spec.rb:    it 'rebuilds relative URL for an image' do
filter/upload_link_filter_spec.rb:      expect(doc.at_css('img')['src']).to eq(relative_path)
filter/upload_link_filter_spec.rb:      expect(doc.at_css('img').classes).to include('gfm')
filter/upload_link_filter_spec.rb:      expect(doc.at_css('img')['data-link']).not_to eq('true')
filter/upload_link_filter_spec.rb:      expect(doc.at_css('img')['src']).to eq(relative_path)
filter/upload_link_filter_spec.rb:      expect(doc.at_css('img').classes).to include('gfm')
filter/upload_link_filter_spec.rb:      expect(doc.at_css('img')['data-link']).not_to eq('true')
filter/upload_link_filter_spec.rb:    it 'does not modify absolute URL' do
filter/upload_link_filter_spec.rb:      doc = filter(link('http://example.com'))
filter/upload_link_filter_spec.rb:      expect(doc.at_css('a')['href']).to eq 'http://example.com'
filter/upload_link_filter_spec.rb:      expect(doc.at_css('a').classes).not_to include('gfm')
filter/upload_link_filter_spec.rb:      expect(doc.at_css('a')['data-link']).not_to eq('true')
filter/upload_link_filter_spec.rb:    it 'supports unescaped Unicode filenames' do
filter/upload_link_filter_spec.rb:      path = '/uploads/.png'
filter/upload_link_filter_spec.rb:      expect(doc.at_css('a')['href']).to eq("/-/project/#{project.id}/uploads/%ED%95%9C%EA%B8%80.png")
filter/upload_link_filter_spec.rb:      expect(doc.at_css('a').classes).to include('gfm')
filter/upload_link_filter_spec.rb:      expect(doc.at_css('a')['data-link']).to eq('true')
filter/upload_link_filter_spec.rb:    it 'supports escaped Unicode filenames' do
filter/upload_link_filter_spec.rb:      path = '/uploads/.png'
filter/upload_link_filter_spec.rb:      expect(doc.at_css('img')['src']).to eq("/-/project/#{project.id}/uploads/%ED%95%9C%EA%B8%80.png")
filter/upload_link_filter_spec.rb:      expect(doc.at_css('img').classes).to include('gfm')
filter/upload_link_filter_spec.rb:      expect(doc.at_css('img')['data-link']).not_to eq('true')
filter/upload_link_filter_spec.rb:  context 'to a group upload' do
filter/upload_link_filter_spec.rb:    let(:upload_link) { link('/uploads/e90decf88d8f96fe9e1389afc2e4a91f/test.jpg') }
filter/upload_link_filter_spec.rb:    context 'with an absolute URL' do
filter/upload_link_filter_spec.rb:      it 'rewrites the link correctly' do
filter/upload_link_filter_spec.rb:        expect(doc.at_css('a')['href']).to eq(absolute_path)
filter/upload_link_filter_spec.rb:        expect(doc.at_css('a').classes).to include('gfm')
filter/upload_link_filter_spec.rb:        expect(doc.at_css('a')['data-link']).to eq('true')
filter/upload_link_filter_spec.rb:    it 'rewrites the link correctly' do
filter/upload_link_filter_spec.rb:      expect(doc.at_css('a')['href']).to eq(relative_path)
filter/upload_link_filter_spec.rb:      expect(doc.at_css('a').classes).to include('gfm')
filter/upload_link_filter_spec.rb:      expect(doc.at_css('a')['data-link']).to eq('true')
filter/upload_link_filter_spec.rb:    it 'rewrites the link correctly for subgroup' do
filter/upload_link_filter_spec.rb:      expect(doc.at_css('a')['href']).to eq(relative_path)
filter/upload_link_filter_spec.rb:      expect(doc.at_css('a').classes).to include('gfm')
filter/upload_link_filter_spec.rb:      expect(doc.at_css('a')['data-link']).to eq('true')
filter/upload_link_filter_spec.rb:    it 'does not modify absolute URL' do
filter/upload_link_filter_spec.rb:      doc = filter(link('http://example.com'))
filter/upload_link_filter_spec.rb:      expect(doc.at_css('a')['href']).to eq 'http://example.com'
filter/upload_link_filter_spec.rb:      expect(doc.at_css('a').classes).not_to include('gfm')
filter/upload_link_filter_spec.rb:      expect(doc.at_css('a')['data-link']).not_to eq('true')
filter/upload_link_filter_spec.rb:  context 'to a personal snippet' do
filter/upload_link_filter_spec.rb:    let(:relative_path) { '/uploads/-/system/personal_snippet/6/674e4f07fbf0a7736c3439212896e51a/example.tar.gz' }
filter/upload_link_filter_spec.rb:    context 'with an absolute URL' do
filter/upload_link_filter_spec.rb:      it 'rewrites the link correctly' do
filter/upload_link_filter_spec.rb:        expect(doc.at_css('a')['href']).to eq(absolute_path)
filter/upload_link_filter_spec.rb:        expect(doc.at_css('a').classes).to include('gfm')
filter/upload_link_filter_spec.rb:        expect(doc.at_css('a')['data-link']).to eq('true')
filter/upload_link_filter_spec.rb:    context 'with a relative URL root' do
filter/upload_link_filter_spec.rb:      let(:gitlab_root) { '/gitlab' }
filter/upload_link_filter_spec.rb:      context 'with an absolute URL' do
filter/upload_link_filter_spec.rb:        it 'rewrites the link correctly' do
filter/upload_link_filter_spec.rb:          expect(doc.at_css('a')['href']).to eq(absolute_path)
filter/upload_link_filter_spec.rb:          expect(doc.at_css('a').classes).to include('gfm')
filter/upload_link_filter_spec.rb:          expect(doc.at_css('a')['data-link']).to eq('true')
filter/upload_link_filter_spec.rb:      it 'rewrites the link correctly' do
filter/upload_link_filter_spec.rb:        expect(doc.at_css('a')['href']).to eq(gitlab_root + relative_path)
filter/upload_link_filter_spec.rb:        expect(doc.at_css('a').classes).to include('gfm')
filter/upload_link_filter_spec.rb:        expect(doc.at_css('a')['data-link']).to eq('true')
filter/upload_link_filter_spec.rb:    it 'rewrites the link correctly' do
filter/upload_link_filter_spec.rb:      expect(doc.at_css('a')['href']).to eq(relative_path)
filter/upload_link_filter_spec.rb:      expect(doc.at_css('a').classes).to include('gfm')
filter/upload_link_filter_spec.rb:      expect(doc.at_css('a')['data-link']).to eq('true')
filter/upload_link_filter_spec.rb:    it 'does not modify absolute URL' do
filter/upload_link_filter_spec.rb:      doc = filter(link('http://example.com'))
filter/upload_link_filter_spec.rb:      expect(doc.at_css('a')['href']).to eq 'http://example.com'
filter/upload_link_filter_spec.rb:      expect(doc.at_css('a').classes).not_to include('gfm')
filter/upload_link_filter_spec.rb:      expect(doc.at_css('a')['data-link']).not_to eq('true')
filter/upload_link_filter_spec.rb:  context 'invalid input' do
filter/upload_link_filter_spec.rb:      'invalid URI'                  | '://foo'
filter/upload_link_filter_spec.rb:      'invalid UTF-8 byte sequences' | '%FF'
filter/upload_link_filter_spec.rb:      'garbled path'                 | 'open(/var/tmp/):%20/location%0Afrom:%20/test'
filter/upload_link_filter_spec.rb:      'whitespace'                   | "d18213acd3732630991986120e167e3d/Landscape_8.jpg\nand more"
filter/upload_link_filter_spec.rb:      'null byte'                    | "%00"
filter/upload_link_filter_spec.rb:  it_behaves_like 'pipeline timing check'
filter/blockquote_fence_legacy_filter_spec.rb:require 'spec_helper'
filter/blockquote_fence_legacy_filter_spec.rb:  it 'converts blockquote fences to blockquote lines', :unlimited_max_formatted_output_length do
filter/blockquote_fence_legacy_filter_spec.rb:    content = File.read(Rails.root.join('spec/fixtures/blockquote_fence_legacy_before.md'))
filter/blockquote_fence_legacy_filter_spec.rb:    expected = File.read(Rails.root.join('spec/fixtures/blockquote_fence_legacy_after.md'))
filter/blockquote_fence_legacy_filter_spec.rb:  it 'does not require newlines at start or end of string' do
filter/blockquote_fence_legacy_filter_spec.rb:  it 'allows trailing whitespace on blockquote fence lines' do
filter/blockquote_fence_legacy_filter_spec.rb:  context 'when incomplete blockquote fences with multiple blocks are present' do
filter/blockquote_fence_legacy_filter_spec.rb:    it 'does not raise timeout error' do
